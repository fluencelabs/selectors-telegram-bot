{"id":"a8cf126d77d55c8e5855612ee6198744","source_id_to_path":{"0":"lib/forge-std/src/Base.sol","1":"lib/forge-std/src/Script.sol","2":"lib/forge-std/src/StdChains.sol","3":"lib/forge-std/src/StdCheats.sol","4":"lib/forge-std/src/StdJson.sol","5":"lib/forge-std/src/StdMath.sol","6":"lib/forge-std/src/StdStorage.sol","7":"lib/forge-std/src/StdStyle.sol","8":"lib/forge-std/src/StdUtils.sol","9":"lib/forge-std/src/Vm.sol","10":"lib/forge-std/src/console.sol","11":"lib/forge-std/src/console2.sol","12":"lib/forge-std/src/interfaces/IERC165.sol","13":"lib/forge-std/src/interfaces/IERC20.sol","14":"lib/forge-std/src/interfaces/IERC721.sol","15":"lib/forge-std/src/interfaces/IMulticall3.sol","16":"lib/forge-std/src/mocks/MockERC20.sol","17":"lib/forge-std/src/mocks/MockERC721.sol","18":"lib/forge-std/src/safeconsole.sol","19":"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol","21":"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol","22":"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol","23":"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol","24":"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol","25":"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol","26":"lib/openzeppelin-contracts/contracts/utils/Address.sol","27":"lib/openzeppelin-contracts/contracts/utils/Errors.sol","28":"lib/openzeppelin-contracts/contracts/utils/Panic.sol","29":"lib/openzeppelin-contracts/contracts/utils/Strings.sol","30":"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol","31":"lib/openzeppelin-contracts/contracts/utils/math/Math.sol","32":"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol","33":"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol","34":"lib/openzeppelin-contracts/contracts//utils/structs/EnumerableSet.sol","35":"script/UpdateDiamondViewsMultisig.sol","36":"script/utils/Deployment.sol","37":"script/utils/SelectorsHelper.sol","38":"src/balance-keeper/IBalanceKeeper.sol","39":"src/core/DealStakerRewards.sol","40":"src/core/Snapshot.sol","41":"src/core/Vesting.sol","42":"src/core/interfaces/IBaseOffer.sol","43":"src/core/interfaces/ICapacity.sol","44":"src/core/interfaces/ICapacityConst.sol","45":"src/core/interfaces/ICore.sol","46":"src/core/interfaces/IDealFactory.sol","47":"src/core/interfaces/IEpochController.sol","48":"src/core/interfaces/IGlobalConst.sol","49":"src/core/interfaces/IMarket.sol","50":"src/core/interfaces/IMarketV2.sol","51":"src/core/interfaces/IOffer.sol","52":"src/core/interfaces/IOfferV2.sol","53":"src/deal/interfaces/IConfig.sol","54":"src/deal/interfaces/IDeal.sol","55":"src/deal/interfaces/IWorkerManager.sol","56":"src/deal/v1/interfaces/IConfig.sol","57":"src/deal/v1/interfaces/IDeal.sol","58":"src/deal/v1/interfaces/IWorkerManager.sol","59":"src/interfaces/IDiamond.sol","60":"src/interfaces/IDiamondCut.sol","61":"src/interfaces/IDiamondLoupe.sol","62":"src/interfaces/IERC165.sol","63":"src/interfaces/IERC173.sol","64":"src/interfaces/IMulticall.sol","65":"src/interfaces/IViewer.sol","66":"src/interfaces/IWhitelist.sol","67":"src/lib/LibBaseOffer.sol","68":"src/lib/LibCapacity.sol","69":"src/lib/LibCapacityConst.sol","70":"src/lib/LibDiamond.sol","71":"src/lib/LibEpochController.sol","72":"src/lib/LibGlobalConst.sol","73":"src/lib/LibOffer.sol","74":"src/lib/LibOfferV2.sol","75":"src/lib/LibOraclePrice.sol","76":"src/lib/LibSendValue.sol","77":"src/utils/Common.sol","78":"src/utils/OwnableUpgradableDiamond.sol"},"language":"Solidity","_format":"ethers-rs-sol-build-info-1","input":{"version":"0.8.26","language":"Solidity","sources":{"lib/forge-std/src/Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n    // The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"},"lib/forge-std/src/Script.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n// 💬 ABOUT\n// Forge Std's default Script.\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheatsSafe} from \"./StdCheats.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorageSafe} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\n// 📦 BOILERPLATE\nimport {ScriptBase} from \"./Base.sol\";\n\n// ⭐️ SCRIPT\nabstract contract Script is ScriptBase, StdChains, StdCheatsSafe, StdUtils {\n    // Note: IS_SCRIPT() must return true.\n    bool public IS_SCRIPT = true;\n}\n"},"lib/forge-std/src/StdChains.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)\n        private\n        view\n        returns (Chain memory)\n    {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // Distinguish 'not found' from 'cannot read'\n                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions\n                bytes memory oldNotFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                bytes memory newNotFoundError = abi.encodeWithSignature(\n                    \"CheatcodeError(string)\", string(abi.encodePacked(\"invalid rpc url: \", chainAlias))\n                );\n                bytes32 errHash = keccak256(err);\n                if (\n                    (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))\n                        || bytes(chain.rpcUrl).length == 0\n                ) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"holesky\", ChainData(\"Holesky\", 17000, \"https://rpc.holesky.ethpandaops.io\"));\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\n            \"optimism_sepolia\", ChainData(\"Optimism Sepolia\", 11155420, \"https://sepolia.optimism.io\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_sepolia\", ChainData(\"Arbitrum One Sepolia\", 421614, \"https://sepolia-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_amoy\", ChainData(\"Polygon Amoy\", 80002, \"https://rpc-amoy.polygon.technology\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n        setChainWithDefaultRpcUrl(\"moonbeam\", ChainData(\"Moonbeam\", 1284, \"https://rpc.api.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\n            \"moonriver\", ChainData(\"Moonriver\", 1285, \"https://rpc.api.moonriver.moonbeam.network\")\n        );\n        setChainWithDefaultRpcUrl(\"moonbase\", ChainData(\"Moonbase\", 1287, \"https://rpc.testnet.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\"base_sepolia\", ChainData(\"Base Sepolia\", 84532, \"https://sepolia.base.org\"));\n        setChainWithDefaultRpcUrl(\"base\", ChainData(\"Base\", 8453, \"https://mainnet.base.org\"));\n        setChainWithDefaultRpcUrl(\"blast_sepolia\", ChainData(\"Blast Sepolia\", 168587773, \"https://sepolia.blast.io\"));\n        setChainWithDefaultRpcUrl(\"blast\", ChainData(\"Blast\", 81457, \"https://rpc.blast.io\"));\n        setChainWithDefaultRpcUrl(\"fantom_opera\", ChainData(\"Fantom Opera\", 250, \"https://rpc.ankr.com/fantom/\"));\n        setChainWithDefaultRpcUrl(\n            \"fantom_opera_testnet\", ChainData(\"Fantom Opera Testnet\", 4002, \"https://rpc.ankr.com/fantom_testnet/\")\n        );\n        setChainWithDefaultRpcUrl(\"fraxtal\", ChainData(\"Fraxtal\", 252, \"https://rpc.frax.com\"));\n        setChainWithDefaultRpcUrl(\"fraxtal_testnet\", ChainData(\"Fraxtal Testnet\", 2522, \"https://rpc.testnet.frax.com\"));\n        setChainWithDefaultRpcUrl(\n            \"berachain_bartio_testnet\", ChainData(\"Berachain bArtio Testnet\", 80084, \"https://bartio.rpc.berachain.com\")\n        );\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"},"lib/forge-std/src/StdCheats.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {console2} from \"./console2.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    enum AddressType {\n        Payable,\n        NonPayable,\n        ZeroAddress,\n        Precompile,\n        ForgeAddress\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\n    // backwards compatibility, since this name was used in the original PR which has already has\n    // a release. This function can be removed in a future release once we want a breaking change.\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\n        assumeNotBlacklisted(token, addr);\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\n        if (addressType == AddressType.Payable) {\n            assumeNotPayable(addr);\n        } else if (addressType == AddressType.NonPayable) {\n            assumePayable(addr);\n        } else if (addressType == AddressType.ZeroAddress) {\n            assumeNotZeroAddress(addr);\n        } else if (addressType == AddressType.Precompile) {\n            assumeNotPrecompile(addr);\n        } else if (addressType == AddressType.ForgeAddress) {\n            assumeNotForgeAddress(addr);\n        }\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3,\n        AddressType addressType4\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n        assumeAddressIsNot(addr, addressType4);\n    }\n\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\n    // `addr` and checking the `success` return value.\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used.\n    function _isPayable(address addr) private returns (bool) {\n        require(\n            addr.balance < UINT256_MAX,\n            \"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\"\n        );\n        uint256 origBalanceTest = address(this).balance;\n        uint256 origBalanceAddr = address(addr).balance;\n\n        vm.deal(address(this), 1);\n        (bool success,) = payable(addr).call{value: 1}(\"\");\n\n        // reset balances\n        vm.deal(address(this), origBalanceTest);\n        vm.deal(addr, origBalanceAddr);\n\n        return success;\n    }\n\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used. See the\n    // `_isPayable` method for more information.\n    function assumePayable(address addr) internal virtual {\n        vm.assume(_isPayable(addr));\n    }\n\n    function assumeNotPayable(address addr) internal virtual {\n        vm.assume(!_isPayable(addr));\n    }\n\n    function assumeNotZeroAddress(address addr) internal pure virtual {\n        vm.assume(addr != address(0));\n    }\n\n    function assumeNotPrecompile(address addr) internal pure virtual {\n        assumeNotPrecompile(addr, _pureChainId());\n    }\n\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function assumeNotForgeAddress(address addr) internal pure virtual {\n        // vm, console, and Create2Deployer addresses\n        vm.assume(\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        console2_log_StdCheats(\"changePrank is deprecated. Please use vm.startPrank instead.\");\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n\n    function deployCodeTo(string memory what, address where) internal virtual {\n        deployCodeTo(what, \"\", 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\n        deployCodeTo(what, args, 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\n        bytes memory creationCode = vm.getCode(what);\n        vm.etch(where, abi.encodePacked(creationCode, args));\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\"\");\n        require(success, \"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        vm.etch(where, runtimeBytecode);\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n    function console2_log_StdCheats(string memory p0) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n        status;\n    }\n}\n"},"lib/forge-std/src/StdJson.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"<some_path>\");\n// json.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"},"lib/forge-std/src/StdMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"},"lib/forge-std/src/StdStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct FindData {\n    uint256 slot;\n    uint256 offsetLeft;\n    uint256 offsetRight;\n    bool found;\n}\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n    bool _enable_packed_slots;\n    bytes _calldata;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {\n        if (self._calldata.length == 0) {\n            return flatten(self._keys);\n        } else {\n            return self._calldata;\n        }\n    }\n\n    // Calls target contract with configured parameters\n    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {\n        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));\n        (bool success, bytes memory rdat) = self._target.staticcall(cald);\n        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);\n\n        return (success, result);\n    }\n\n    // Tries mutating slot value to determine if the targeted value is stored in it.\n    // If current value is 0, then we are setting slot value to type(uint256).max\n    // Otherwise, we set it to 0. That way, return value should always be affected.\n    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n        (bool success, bytes32 prevReturnValue) = callTarget(self);\n\n        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);\n        vm.store(self._target, slot, testVal);\n\n        (, bytes32 newReturnValue) = callTarget(self);\n\n        vm.store(self._target, slot, prevSlotValue);\n\n        return (success && (prevReturnValue != newReturnValue));\n    }\n\n    // Tries setting one of the bits in slot to 1 until return value changes.\n    // Index of resulted bit is an offset packed slot has from left/right side\n    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {\n        for (uint256 offset = 0; offset < 256; offset++) {\n            uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);\n            vm.store(self._target, slot, bytes32(valueToPut));\n\n            (bool success, bytes32 data) = callTarget(self);\n\n            if (success && (uint256(data) > 0)) {\n                return (true, offset);\n            }\n        }\n        return (false, 0);\n    }\n\n    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n\n        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);\n        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);\n\n        // `findOffset` may mutate slot value, so we are setting it to initial value\n        vm.store(self._target, slot, prevSlotValue);\n        return (foundLeft && foundRight, offsetLeft, offsetRight);\n    }\n\n    function find(StdStorage storage self) internal returns (FindData storage) {\n        return find(self, true);\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = getCallParams(self);\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            if (_clear) {\n                clear(self);\n            }\n            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        }\n        vm.record();\n        (, bytes32 callResult) = callTarget(self);\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n\n        if (reads.length == 0) {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        } else {\n            for (uint256 i = reads.length; --i >= 0;) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n\n                if (!checkSlotMutatesCall(self, reads[i])) {\n                    continue;\n                }\n\n                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);\n\n                if (self._enable_packed_slots) {\n                    bool found;\n                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);\n                    if (!found) {\n                        continue;\n                    }\n                }\n\n                // Check that value between found offsets is equal to the current call result\n                uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;\n\n                if (uint256(callResult) != curVal) {\n                    continue;\n                }\n\n                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));\n                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =\n                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);\n                break;\n            }\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        if (_clear) {\n            clear(self);\n        }\n        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        self._calldata = _calldata;\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        self._enable_packed_slots = true;\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        FindData storage data = find(self, false);\n        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);\n        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;\n        clear(self);\n        return abi.encode(value);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        return (uint256(parent_slot), key);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        bool found;\n        bytes32 root_slot;\n        bytes32 parent_slot;\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        while (found) {\n            root_slot = parent_slot;\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\n        }\n        return uint256(root_slot);\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n    function clear(StdStorage storage self) internal {\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n        delete self._enable_packed_slots;\n        delete self._calldata;\n    }\n\n    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`\n    // (slotValue & mask) >> offsetRight will be the value of the given packed variable\n    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {\n        // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;\n        // using assembly because (1 << 256) causes overflow\n        assembly {\n            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))\n        }\n    }\n\n    // Returns slot value with updated packed variable.\n    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)\n        internal\n        pure\n        returns (bytes32 newValue)\n    {\n        return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return find(self, true);\n    }\n\n    function find(StdStorage storage self, bool _clear) internal returns (uint256) {\n        return stdStorageSafe.find(self, _clear).slot;\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_calldata(self, _calldata);\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        return stdStorageSafe.enable_packed_slots(self);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function clear(StdStorage storage self) internal {\n        stdStorageSafe.clear(self);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write_int(StdStorage storage self, int256 val) internal {\n        checked_write(self, bytes32(uint256(val)));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = stdStorageSafe.getCallParams(self);\n\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            find(self, false);\n        }\n        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        if ((data.offsetLeft + data.offsetRight) > 0) {\n            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));\n            require(\n                uint256(set) < maxVal,\n                string(\n                    abi.encodePacked(\n                        \"stdStorage find(StdStorage): Packed slot. We can't fit value greater than \",\n                        vm.toString(maxVal)\n                    )\n                )\n            );\n        }\n        bytes32 curVal = vm.load(who, bytes32(data.slot));\n        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);\n\n        vm.store(who, bytes32(data.slot), valToSet);\n\n        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);\n\n        if (!success || callResult != set) {\n            vm.store(who, bytes32(data.slot), curVal);\n            revert(\"stdStorage find(StdStorage): Failed to write value.\");\n        }\n        clear(self);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        return stdStorageSafe.parent(self);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.root(self);\n    }\n}\n"},"lib/forge-std/src/StdStyle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"},"lib/forge-std/src/StdUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {MockERC20} from \"./mocks/MockERC20.sol\";\nimport {MockERC721} from \"./mocks/MockERC721.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", vm.toString(result));\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        console2_log_StdUtils(\"computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.\");\n        return vm.computeCreateAddress(deployer, nonce);\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initcodeHash, deployer);\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initCodeHash);\n    }\n\n    /// @dev returns an initialized mock ERC20 contract\n    function deployMockERC20(string memory name, string memory symbol, uint8 decimals)\n        internal\n        returns (MockERC20 mock)\n    {\n        mock = new MockERC20();\n        mock.initialize(name, symbol, decimals);\n    }\n\n    /// @dev returns an initialized mock ERC721 contract\n    function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {\n        mock = new MockERC721();\n        mock.initialize(name, symbol);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // This section is used to prevent the compilation of console, which shortens the compilation time when console is\n    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid\n    // any breaking changes to function signatures.\n    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)\n        internal\n        pure\n        returns (function(bytes memory) internal pure fnOut)\n    {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE2_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function console2_log_StdUtils(string memory p0) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function console2_log_StdUtils(string memory p0, string memory p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n}\n"},"lib/forge-std/src/Vm.sol":{"content":"// Automatically @generated by scripts/vm.py. Do not modify manually.\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\ninterface VmSafe {\n    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.\n    enum CallerMode {\n        // No caller modification is currently active.\n        None,\n        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.\n        Broadcast,\n        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.\n        RecurrentBroadcast,\n        // A one time prank triggered by a `vm.prank()` call is currently active.\n        Prank,\n        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.\n        RecurrentPrank\n    }\n\n    /// The kind of account access that occurred.\n    enum AccountAccessKind {\n        // The account was called.\n        Call,\n        // The account was called via delegatecall.\n        DelegateCall,\n        // The account was called via callcode.\n        CallCode,\n        // The account was called via staticcall.\n        StaticCall,\n        // The account was created.\n        Create,\n        // The account was selfdestructed.\n        SelfDestruct,\n        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).\n        Resume,\n        // The account's balance was read.\n        Balance,\n        // The account's codesize was read.\n        Extcodesize,\n        // The account's codehash was read.\n        Extcodehash,\n        // The account's code was copied.\n        Extcodecopy\n    }\n\n    /// Forge execution contexts.\n    enum ForgeContext {\n        // Test group execution context (test, coverage or snapshot).\n        TestGroup,\n        // `forge test` execution context.\n        Test,\n        // `forge coverage` execution context.\n        Coverage,\n        // `forge snapshot` execution context.\n        Snapshot,\n        // Script group execution context (dry run, broadcast or resume).\n        ScriptGroup,\n        // `forge script` execution context.\n        ScriptDryRun,\n        // `forge script --broadcast` execution context.\n        ScriptBroadcast,\n        // `forge script --resume` execution context.\n        ScriptResume,\n        // Unknown `forge` execution context.\n        Unknown\n    }\n\n    /// An Ethereum log. Returned by `getRecordedLogs`.\n    struct Log {\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The address of the log's emitter.\n        address emitter;\n    }\n\n    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.\n    struct Rpc {\n        // The alias of the RPC URL.\n        string key;\n        // The RPC URL.\n        string url;\n    }\n\n    /// An RPC log object. Returned by `eth_getLogs`.\n    struct EthGetLogs {\n        // The address of the log's emitter.\n        address emitter;\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The block hash.\n        bytes32 blockHash;\n        // The block number.\n        uint64 blockNumber;\n        // The transaction hash.\n        bytes32 transactionHash;\n        // The transaction index in the block.\n        uint64 transactionIndex;\n        // The log index.\n        uint256 logIndex;\n        // Whether the log was removed.\n        bool removed;\n    }\n\n    /// A single entry in a directory listing. Returned by `readDir`.\n    struct DirEntry {\n        // The error message, if any.\n        string errorMessage;\n        // The path of the entry.\n        string path;\n        // The depth of the entry.\n        uint64 depth;\n        // Whether the entry is a directory.\n        bool isDir;\n        // Whether the entry is a symlink.\n        bool isSymlink;\n    }\n\n    /// Metadata information about a file.\n    /// This structure is returned from the `fsMetadata` function and represents known\n    /// metadata about a file such as its permissions, size, modification\n    /// times, etc.\n    struct FsMetadata {\n        // True if this metadata is for a directory.\n        bool isDir;\n        // True if this metadata is for a symlink.\n        bool isSymlink;\n        // The size of the file, in bytes, this metadata is for.\n        uint256 length;\n        // True if this metadata is for a readonly (unwritable) file.\n        bool readOnly;\n        // The last modification time listed in this metadata.\n        uint256 modified;\n        // The last access time of this metadata.\n        uint256 accessed;\n        // The creation time listed in this metadata.\n        uint256 created;\n    }\n\n    /// A wallet with a public and private key.\n    struct Wallet {\n        // The wallet's address.\n        address addr;\n        // The wallet's public key `X`.\n        uint256 publicKeyX;\n        // The wallet's public key `Y`.\n        uint256 publicKeyY;\n        // The wallet's private key.\n        uint256 privateKey;\n    }\n\n    /// The result of a `tryFfi` call.\n    struct FfiResult {\n        // The exit code of the call.\n        int32 exitCode;\n        // The optionally hex-decoded `stdout` data.\n        bytes stdout;\n        // The `stderr` data.\n        bytes stderr;\n    }\n\n    /// Information on the chain and fork.\n    struct ChainInfo {\n        // The fork identifier. Set to zero if no fork is active.\n        uint256 forkId;\n        // The chain ID of the current fork.\n        uint256 chainId;\n    }\n\n    /// The result of a `stopAndReturnStateDiff` call.\n    struct AccountAccess {\n        // The chain and fork the access occurred.\n        ChainInfo chainInfo;\n        // The kind of account access that determines what the account is.\n        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.\n        // If kind is Create, then the account is the newly created account.\n        // If kind is SelfDestruct, then the account is the selfdestruct recipient.\n        // If kind is a Resume, then account represents a account context that has resumed.\n        AccountAccessKind kind;\n        // The account that was accessed.\n        // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.\n        address account;\n        // What accessed the account.\n        address accessor;\n        // If the account was initialized or empty prior to the access.\n        // An account is considered initialized if it has code, a\n        // non-zero nonce, or a non-zero balance.\n        bool initialized;\n        // The previous balance of the accessed account.\n        uint256 oldBalance;\n        // The potential new balance of the accessed account.\n        // That is, all balance changes are recorded here, even if reverts occurred.\n        uint256 newBalance;\n        // Code of the account deployed by CREATE.\n        bytes deployedCode;\n        // Value passed along with the account access\n        uint256 value;\n        // Input data provided to the CREATE or CALL\n        bytes data;\n        // If this access reverted in either the current or parent context.\n        bool reverted;\n        // An ordered list of storage accesses made during an account access operation.\n        StorageAccess[] storageAccesses;\n        // Call depth traversed during the recording of state differences\n        uint64 depth;\n    }\n\n    /// The storage accessed during an `AccountAccess`.\n    struct StorageAccess {\n        // The account whose storage was accessed.\n        address account;\n        // The slot that was accessed.\n        bytes32 slot;\n        // If the access was a write.\n        bool isWrite;\n        // The previous value of the slot.\n        bytes32 previousValue;\n        // The new value of the slot.\n        bytes32 newValue;\n        // If the access was reverted.\n        bool reverted;\n    }\n\n    /// Gas used. Returned by `lastCallGas`.\n    struct Gas {\n        // The gas limit of the call.\n        uint64 gasLimit;\n        // The total gas used.\n        uint64 gasTotalUsed;\n        // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>\n        uint64 gasMemoryUsed;\n        // The amount of gas refunded.\n        int64 gasRefunded;\n        // The amount of gas remaining.\n        uint64 gasRemaining;\n    }\n\n    // ======== Environment ========\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and returns true if it exists, else returns false.\n    function envExists(string calldata name) external view returns (bool result);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bool defaultValue) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        view\n        returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        view\n        returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        view\n        returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        view\n        returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, address defaultValue) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        view\n        returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        view\n        returns (uint256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        view\n        returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n\n    /// Returns true if `forge` command was executed in given context.\n    function isContext(ForgeContext context) external view returns (bool result);\n\n    /// Sets environment variables.\n    function setEnv(string calldata name, string calldata value) external;\n\n    // ======== EVM ========\n\n    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n\n    /// Gets the address for a given private key.\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n\n    /// Gets all the logs according to specified filter.\n    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)\n        external\n        returns (EthGetLogs[] memory logs);\n\n    /// Gets the current `block.blobbasefee`.\n    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlobBaseFee() external view returns (uint256 blobBaseFee);\n\n    /// Gets the current `block.number`.\n    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockNumber() external view returns (uint256 height);\n\n    /// Gets the current `block.timestamp`.\n    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockTimestamp() external view returns (uint256 timestamp);\n\n    /// Gets the map key and parent of a mapping at a given slot, for a given address.\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\n        external\n        returns (bool found, bytes32 key, bytes32 parent);\n\n    /// Gets the number of elements in the mapping at the given slot, for a given address.\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\n\n    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The\n    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\n\n    /// Gets the nonce of an account.\n    function getNonce(address account) external view returns (uint64 nonce);\n\n    /// Gets all the recorded logs.\n    function getRecordedLogs() external returns (Log[] memory logs);\n\n    /// Gets the gas used in the last call.\n    function lastCallGas() external view returns (Gas memory gas);\n\n    /// Loads a storage slot from an address.\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n\n    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n\n    /// Records all storage reads and writes.\n    function record() external;\n\n    /// Record all the transaction logs.\n    function recordLogs() external;\n\n    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n\n    /// Performs an Ethereum JSON-RPC request to the current fork URL.\n    function rpc(string calldata method, string calldata params) external returns (bytes memory data);\n\n    /// Performs an Ethereum JSON-RPC request to the given endpoint.\n    function rpc(string calldata urlOrAlias, string calldata method, string calldata params)\n        external\n        returns (bytes memory data);\n\n    /// Signs `digest` with `privateKey` using the secp256r1 curve.\n    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Starts recording all map SSTOREs for later retrieval.\n    function startMappingRecording() external;\n\n    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,\n    /// along with the context of the calls\n    function startStateDiffRecording() external;\n\n    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.\n    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);\n\n    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.\n    function stopMappingRecording() external;\n\n    // ======== Filesystem ========\n\n    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    /// `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n\n    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\n    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\n    /// Both `from` and `to` are relative to the project root.\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\n\n    /// Creates a new, empty directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - User lacks permissions to modify `path`.\n    /// - A parent of the given path doesn't exist and `recursive` is false.\n    /// - `path` already exists and `recursive` is false.\n    /// `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function deployCode(string calldata artifactPath) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionaly accepts abi-encoded constructor arguments.\n    function deployCode(string calldata artifactPath, bytes calldata constructorArgs)\n        external\n        returns (address deployedAddress);\n\n    /// Returns true if the given path points to an existing entity, else returns false.\n    function exists(string calldata path) external returns (bool result);\n\n    /// Performs a foreign function call via the terminal.\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n\n    /// Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n\n    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n\n    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.\n    function isDir(string calldata path) external returns (bool result);\n\n    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.\n    function isFile(string calldata path) external returns (bool result);\n\n    /// Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n\n    /// Prompts the user for a string value in the terminal.\n    function prompt(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for an address in the terminal.\n    function promptAddress(string calldata promptText) external returns (address);\n\n    /// Prompts the user for a hidden string value in the terminal.\n    function promptSecret(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for hidden uint256 in the terminal (usually pk).\n    function promptSecretUint(string calldata promptText) external returns (uint256);\n\n    /// Prompts the user for uint256 in the terminal.\n    function promptUint(string calldata promptText) external returns (uint256);\n\n    /// Reads the directory at the given path recursively, up to `maxDepth`.\n    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    /// Follows symbolic links if `followLinks` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n\n    /// Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n\n    /// Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n\n    /// Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n\n    /// Reads a symbolic link, returning the path that the link points to.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` is not a symbolic link.\n    /// - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n\n    /// Removes a directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` doesn't exist.\n    /// - `path` isn't a directory.\n    /// - User lacks permissions to modify `path`.\n    /// - The directory is not empty and `recursive` is false.\n    /// `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n\n    /// Removes a file from the filesystem.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` points to a directory.\n    /// - The file doesn't exist.\n    /// - The user lacks permissions to remove the file.\n    /// `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n\n    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\n\n    /// Returns the time since unix epoch in milliseconds.\n    function unixTime() external returns (uint256 milliseconds);\n\n    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n\n    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n\n    /// Writes line to file, creating a file if it does not exist.\n    /// `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n\n    // ======== JSON ========\n\n    /// Checks if `key` exists in a JSON object\n    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\n\n    /// Checks if `key` exists in a JSON object.\n    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address`.\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address[]`.\n    function parseJsonAddressArray(string calldata json, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool`.\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes`.\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.\n    function parseJsonBytes32Array(string calldata json, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256`.\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a JSON object.\n    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string`.\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string[]`.\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.\n    function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(string calldata json, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256`.\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a JSON object.\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a JSON object at `key`.\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.\n    /// Returns the stringified version of the specific JSON file up to that moment.\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(string calldata typeDescription, bytes calldata value)\n        external\n        pure\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(\n        string calldata objectKey,\n        string calldata valueKey,\n        string calldata typeDescription,\n        bytes calldata value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    function writeJson(string calldata json, string calldata path) external;\n\n    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Scripting ========\n\n    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function broadcast() external;\n\n    /// Has the next call (at this call depth only) create a transaction with the address provided\n    /// as the sender that can later be signed and sent onchain.\n    function broadcast(address signer) external;\n\n    /// Has the next call (at this call depth only) create a transaction with the private key\n    /// provided as the sender that can later be signed and sent onchain.\n    function broadcast(uint256 privateKey) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function startBroadcast() external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the address\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(address signer) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the private key\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(uint256 privateKey) external;\n\n    /// Stops collecting onchain transactions.\n    function stopBroadcast() external;\n\n    // ======== String ========\n\n    /// Returns the index of the first occurrence of a `key` in an `input` string.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.\n    /// Returns 0 in case of an empty `key`.\n    function indexOf(string calldata input, string calldata key) external pure returns (uint256);\n\n    /// Parses the given `string` into an `address`.\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n\n    /// Parses the given `string` into a `bool`.\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n\n    /// Parses the given `string` into `bytes`.\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n\n    /// Parses the given `string` into a `bytes32`.\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n\n    /// Parses the given `string` into a `int256`.\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n\n    /// Parses the given `string` into a `uint256`.\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n\n    /// Replaces occurrences of `from` in the given `string` with `to`.\n    function replace(string calldata input, string calldata from, string calldata to)\n        external\n        pure\n        returns (string memory output);\n\n    /// Splits the given `string` into an array of strings divided by the `delimiter`.\n    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);\n\n    /// Converts the given `string` value to Lowercase.\n    function toLowercase(string calldata input) external pure returns (string memory output);\n\n    /// Converts the given value to a `string`.\n    function toString(address value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given `string` value to Uppercase.\n    function toUppercase(string calldata input) external pure returns (string memory output);\n\n    /// Trims leading and trailing whitespace from the given `string` value.\n    function trim(string calldata input) external pure returns (string memory output);\n\n    // ======== Testing ========\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are equal.\n    function assertEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are equal.\n    function assertEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are equal.\n    function assertEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal.\n    function assertEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256 values are equal.\n    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal.\n    function assertEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal.\n    function assertEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal.\n    function assertEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are equal.\n    function assertEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal.\n    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal.\n    function assertEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are equal.\n    function assertEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are equal.\n    function assertEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is false.\n    function assertFalse(bool condition) external pure;\n\n    /// Asserts that the given condition is false and includes error message into revert string on failure.\n    function assertFalse(bool condition, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    function assertGe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    function assertGe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    function assertGt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    function assertGt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    function assertLe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    function assertLe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    function assertLt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    function assertLt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are not equal.\n    function assertNotEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are not equal.\n    function assertNotEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are not equal.\n    function assertNotEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal.\n    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal.\n    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal.\n    function assertNotEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal.\n    function assertNotEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal.\n    function assertNotEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal.\n    function assertNotEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are not equal.\n    function assertNotEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are not equal.\n    function assertNotEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is true.\n    function assertTrue(bool condition) external pure;\n\n    /// Asserts that the given condition is true and includes error message into revert string on failure.\n    function assertTrue(bool condition, string calldata error) external pure;\n\n    /// If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n\n    /// Writes a breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char) external;\n\n    /// Writes a conditional breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char, bool value) external;\n\n    /// Returns the RPC url for the given alias.\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n\n    /// Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n\n    /// Returns all rpc urls and their aliases `[alias, url][]`.\n    function rpcUrls() external view returns (string[2][] memory urls);\n\n    /// Suspends execution of the main thread for `duration` milliseconds.\n    function sleep(uint256 duration) external;\n\n    // ======== Toml ========\n\n    /// Checks if `key` exists in a TOML table.\n    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address`.\n    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address[]`.\n    function parseTomlAddressArray(string calldata toml, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool`.\n    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.\n    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes`.\n    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.\n    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.\n    function parseTomlBytes32Array(string calldata toml, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.\n    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256`.\n    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.\n    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a TOML table.\n    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string`.\n    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string[]`.\n    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256`.\n    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.\n    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a TOML table.\n    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a TOML table at `key`.\n    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.\n    function writeToml(string calldata json, string calldata path) external;\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.\n    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Utilities ========\n\n    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)\n        external\n        pure\n        returns (address);\n\n    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);\n\n    /// Compute the address a contract will be deployed at for a given deployer address and nonce.\n    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);\n\n    /// Derives a private key from the name, labels the account with that name, and returns the wallet.\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key and returns the wallet.\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Returns ENS namehash for provided string.\n    function ensNamehash(string calldata name) external pure returns (bytes32);\n\n    /// Gets the label for the specified address.\n    function getLabel(address account) external view returns (string memory currentLabel);\n\n    /// Get a `Wallet`'s nonce.\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\n\n    /// Labels an address in call traces.\n    function label(address account, string calldata newLabel) external;\n\n    /// Returns a random `address`.\n    function randomAddress() external returns (address);\n\n    /// Returns a random uint256 value.\n    function randomUint() external returns (uint256);\n\n    /// Returns random uin256 value between the provided range (=min..=max).\n    function randomUint(uint256 min, uint256 max) external returns (uint256);\n\n    /// Adds a private key to the local forge wallet and returns the address.\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n\n    /// Signs data with a `Wallet`.\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Encodes a `bytes` value to a base64url string.\n    function toBase64URL(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64url string.\n    function toBase64URL(string calldata data) external pure returns (string memory);\n\n    /// Encodes a `bytes` value to a base64 string.\n    function toBase64(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64 string.\n    function toBase64(string calldata data) external pure returns (string memory);\n}\n\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\ninterface Vm is VmSafe {\n    // ======== EVM ========\n\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n\n    /// In forking mode, explicitly grant the given address cheatcode access.\n    function allowCheatcodes(address account) external;\n\n    /// Sets `block.blobbasefee`\n    function blobBaseFee(uint256 newBlobBaseFee) external;\n\n    /// Sets the blobhashes in the transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function blobhashes(bytes32[] calldata hashes) external;\n\n    /// Sets `block.chainid`.\n    function chainId(uint256 newChainId) external;\n\n    /// Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// Sets `block.coinbase`.\n    function coinbase(address newCoinbase) external;\n\n    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Sets an address' balance.\n    function deal(address account, uint256 newBalance) external;\n\n    /// Removes the snapshot with the given ID created by `snapshot`.\n    /// Takes the snapshot ID to delete.\n    /// Returns `true` if the snapshot was successfully deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function deleteSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// Removes _all_ snapshots previously created by `snapshot`.\n    function deleteSnapshots() external;\n\n    /// Sets `block.difficulty`.\n    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    /// Reverts if used on unsupported EVM versions.\n    function difficulty(uint256 newDifficulty) external;\n\n    /// Dump a genesis JSON file's `allocs` to disk.\n    function dumpState(string calldata pathToStateJson) external;\n\n    /// Sets an address' code.\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n\n    /// Sets `block.basefee`.\n    function fee(uint256 newBasefee) external;\n\n    /// Gets the blockhashes from the current transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function getBlobhashes() external view returns (bytes32[] memory hashes);\n\n    /// Returns true if the account is marked as persistent.\n    function isPersistent(address account) external view returns (bool persistent);\n\n    /// Load a genesis JSON file's `allocs` into the in-memory revm state.\n    function loadAllocs(string calldata pathToAllocsJson) external;\n\n    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    /// Meaning, changes made to the state of this account will be kept when switching forks.\n    function makePersistent(address account) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1, address account2) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address[] calldata accounts) external;\n\n    /// Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address.\n    function prank(address msgSender) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(address msgSender, address txOrigin) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(uint256 newPrevrandao) external;\n\n    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\n\n    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.\n    function resetNonce(address account) external;\n\n    /// Revert the state of the EVM to a previous snapshot\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted.\n    /// Returns `false` if the snapshot does not exist.\n    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n\n    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted and deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function revertToAndDelete(uint256 snapshotId) external returns (bool success);\n\n    /// Revokes persistent status from the address, previously added via `makePersistent`.\n    function revokePersistent(address account) external;\n\n    /// See `revokePersistent(address)`.\n    function revokePersistent(address[] calldata accounts) external;\n\n    /// Sets `block.height`.\n    function roll(uint256 newHeight) external;\n\n    /// Updates the currently active fork to given block number\n    /// This is similar to `roll` but for the currently active fork.\n    function rollFork(uint256 blockNumber) external;\n\n    /// Updates the currently active fork to given transaction. This will `rollFork` with the number\n    /// of the block the transaction was mined in and replays all transaction mined before it in the block.\n    function rollFork(bytes32 txHash) external;\n\n    /// Updates the given fork to given block number.\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n\n    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n\n    /// Set blockhash for the current block.\n    /// It only sets the blockhash for blocks where `block.number - 256 <= number < block.number`.\n    function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;\n\n    /// Sets the nonce of an account. Must be higher than the current nonce of the account.\n    function setNonce(address account, uint64 newNonce) external;\n\n    /// Sets the nonce of an account to an arbitrary value.\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n\n    /// Snapshot the current state of the evm.\n    /// Returns the ID of the snapshot that was created.\n    /// To revert a snapshot use `revertTo`.\n    function snapshot() external returns (uint256 snapshotId);\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(address msgSender, address txOrigin) external;\n\n    /// Resets subsequent calls' `msg.sender` to be `address(this)`.\n    function stopPrank() external;\n\n    /// Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n\n    /// Fetches the given transaction from the active fork and executes it on the current state.\n    function transact(bytes32 txHash) external;\n\n    /// Fetches the given transaction from the given fork and executes it on the current state.\n    function transact(uint256 forkId, bytes32 txHash) external;\n\n    /// Sets `tx.gasprice`.\n    function txGasPrice(uint256 newGasPrice) external;\n\n    /// Sets `block.timestamp`.\n    function warp(uint256 newTimestamp) external;\n\n    // ======== Testing ========\n\n    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n\n    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n\n    /// Expects a call to an address with the specified calldata.\n    /// Calldata can either be a strict or a partial match.\n    function expectCall(address callee, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n\n    /// Expects a call to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n\n    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n\n    /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)\n        external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(\n        bool checkTopic0,\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        address emitter\n    ) external;\n\n    /// Prepare an expected anonymous log with all topic and data checks enabled.\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmitAnonymous() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(address emitter) external;\n\n    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    /// Prepare an expected log with all topic and data checks enabled.\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmit() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(address emitter) external;\n\n    /// Expects an error on next call with any revert data.\n    function expectRevert() external;\n\n    /// Expects an error on next call that starts with the revert data.\n    function expectRevert(bytes4 revertData) external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    /// to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n\n    /// Marks a test as skipped. Must be called at the top of the test.\n    function skip(bool skipTest) external;\n\n    /// Stops all safe memory expectation in the current subcontext.\n    function stopExpectSafeMemory() external;\n}\n"},"lib/forge-std/src/console.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(int p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, int p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"},"lib/forge-std/src/console2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {console as console2} from \"./console.sol\";\n"},"lib/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"},"lib/forge-std/src/interfaces/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC165.sol\";\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\n    /// may be created and assigned without emitting Transfer. At the time of\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    /// reaffirmed. The zero address indicates there is no approved address.\n    /// When a Transfer event emits, this also indicates that the approved\n    /// address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    /// function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    /// about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\n    /// `onERC721Received` on `_to` and throws if the return value is not\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    /// except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    /// THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\n    /// operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    /// all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    /// multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    /// after a `transfer`. This function MAY throw to revert and reject the\n    /// transfer. Return of other than the magic value MUST result in the\n    /// transaction being reverted.\n    /// Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\n        external\n        returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    /// 3986. The URI may point to a JSON file that conforms to the \"ERC721\n    /// Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable is IERC721 {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    /// them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    /// (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    /// `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    /// (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"},"lib/forge-std/src/interfaces/IMulticall3.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"},"lib/forge-std/src/mocks/MockERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol\ncontract MockERC20 is IERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal _totalSupply;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    mapping(address => mapping(address => uint256)) internal _allowance;\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal INITIAL_CHAIN_ID;\n\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               INITIALIZE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev A bool to track whether the contract has been initialized.\n    bool private initialized;\n\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\n    /// syntaxes, we add an initialization function that can be called only once.\n    function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {\n        require(!initialized, \"ALREADY_INITIALIZED\");\n\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n\n        INITIAL_CHAIN_ID = _pureChainId();\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        initialized = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);\n\n        _balanceOf[from] = _sub(_balanceOf[from], amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n        virtual\n    {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        address recoveredAddress = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            keccak256(\n                                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                            ),\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n        _allowance[recoveredAddress][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(_name)),\n                keccak256(\"1\"),\n                _pureChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply = _add(_totalSupply, amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _balanceOf[from] = _sub(_balanceOf[from], amount);\n        _totalSupply = _sub(_totalSupply, amount);\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MATH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERC20: addition overflow\");\n        return c;\n    }\n\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b, \"ERC20: subtraction underflow\");\n        return a - b;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n"},"lib/forge-std/src/mocks/MockERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {IERC721Metadata, IERC721TokenReceiver} from \"../interfaces/IERC721.sol\";\n\n/// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol\ncontract MockERC721 is IERC721Metadata {\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string internal _name;\n\n    string internal _symbol;\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {}\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual override returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _getApproved;\n\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\n\n    function getApproved(uint256 id) public view virtual override returns (address) {\n        return _getApproved[id];\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _isApprovedForAll[owner][operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INITIALIZE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev A bool to track whether the contract has been initialized.\n    bool private initialized;\n\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\n    /// syntaxes, we add an initialization function that can be called only once.\n    function initialize(string memory name_, string memory symbol_) public {\n        require(!initialized, \"ALREADY_INITIALIZED\");\n\n        _name = name_;\n        _symbol = symbol_;\n\n        initialized = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public payable virtual override {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        _getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public payable virtual override {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        _balanceOf[from]--;\n\n        _balanceOf[to]++;\n\n        _ownerOf[id] = to;\n\n        delete _getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {\n        transferFrom(from, to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\")\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data)\n        public\n        payable\n        virtual\n        override\n    {\n        transferFrom(from, to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n\n        _balanceOf[to]++;\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        _balanceOf[owner]--;\n\n        delete _ownerOf[id];\n\n        delete _getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\")\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _isContract(address _addr) private view returns (bool) {\n        uint256 codeLength;\n\n        // Assembly required for versions < 0.8.0 to check extcodesize.\n        assembly {\n            codeLength := extcodesize(_addr)\n        }\n\n        return codeLength > 0;\n    }\n}\n"},"lib/forge-std/src/safeconsole.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Code generated automatically by script.\nlibrary safeconsole {\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\n\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\n    // for the view-to-pure log trick.\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\n        function(uint256, uint256) internal pure pureSendLogPayload;\n        assembly {\n            pureSendLogPayload := fnIn\n        }\n        pureSendLogPayload(offset, size);\n    }\n\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\n        assembly {\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\n        }\n    }\n\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\n        assembly {\n            pureMemcopy := fnIn\n        }\n        pureMemcopy(fromOffset, toOffset, length);\n    }\n\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\n        assembly {\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\n        }\n    }\n\n    function logMemory(uint256 offset, uint256 length) internal pure {\n        if (offset >= 0x60) {\n            // Sufficient memory before slice to prepare call header.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            assembly {\n                m0 := mload(sub(offset, 0x60))\n                m1 := mload(sub(offset, 0x40))\n                m2 := mload(sub(offset, 0x20))\n                // Selector of `logBytes(bytes)`.\n                mstore(sub(offset, 0x60), 0xe17bf956)\n                mstore(sub(offset, 0x40), 0x20)\n                mstore(sub(offset, 0x20), length)\n            }\n            _sendLogPayload(offset - 0x44, length + 0x44);\n            assembly {\n                mstore(sub(offset, 0x60), m0)\n                mstore(sub(offset, 0x40), m1)\n                mstore(sub(offset, 0x20), m2)\n            }\n        } else {\n            // Insufficient space, so copy slice forward, add header and reverse.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            uint256 endOffset = offset + length;\n            assembly {\n                m0 := mload(add(endOffset, 0x00))\n                m1 := mload(add(endOffset, 0x20))\n                m2 := mload(add(endOffset, 0x40))\n            }\n            _memcopy(offset, offset + 0x60, length);\n            assembly {\n                // Selector of `logBytes(bytes)`.\n                mstore(add(offset, 0x00), 0xe17bf956)\n                mstore(add(offset, 0x20), 0x20)\n                mstore(add(offset, 0x40), length)\n            }\n            _sendLogPayload(offset + 0x1c, length + 0x44);\n            _memcopy(offset + 0x60, offset, length);\n            assembly {\n                mstore(add(endOffset, 0x00), m0)\n                mstore(add(endOffset, 0x20), m1)\n                mstore(add(endOffset, 0x40), m2)\n            }\n        }\n    }\n\n    function log(address p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(address)`.\n            mstore(0x00, 0x2c2ecbc2)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bool p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(bool)`.\n            mstore(0x00, 0x32458eed)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(uint256 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(uint256)`.\n            mstore(0x00, 0xf82c50f1)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bytes32 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(string)`.\n            mstore(0x00, 0x41304fac)\n            mstore(0x20, 0x20)\n            writeString(0x40, p0)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,address)`.\n            mstore(0x00, 0xdaf0d4aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,bool)`.\n            mstore(0x00, 0x75b605d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,uint256)`.\n            mstore(0x00, 0x8309e8a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,string)`.\n            mstore(0x00, 0x759f86bb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,address)`.\n            mstore(0x00, 0x853c4849)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,bool)`.\n            mstore(0x00, 0x2a110e83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,uint256)`.\n            mstore(0x00, 0x399174d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,string)`.\n            mstore(0x00, 0x8feac525)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,address)`.\n            mstore(0x00, 0x69276c86)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,bool)`.\n            mstore(0x00, 0x1c9d7eb3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,uint256)`.\n            mstore(0x00, 0xf666715a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,string)`.\n            mstore(0x00, 0x643fd0df)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,address)`.\n            mstore(0x00, 0x319af333)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,bool)`.\n            mstore(0x00, 0xc3b55635)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,uint256)`.\n            mstore(0x00, 0xb60e72cc)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,string)`.\n            mstore(0x00, 0x4b5c4277)\n            mstore(0x20, 0x40)\n            mstore(0x40, 0x80)\n            writeString(0x60, p0)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,address)`.\n            mstore(0x00, 0x018c84c2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,bool)`.\n            mstore(0x00, 0xf2a66286)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,uint256)`.\n            mstore(0x00, 0x17fe6185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,address,string)`.\n            mstore(0x00, 0x007150be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,address)`.\n            mstore(0x00, 0xf11699ed)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,bool)`.\n            mstore(0x00, 0xeb830c92)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,uint256)`.\n            mstore(0x00, 0x9c4f99fb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,bool,string)`.\n            mstore(0x00, 0x212255cc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,address)`.\n            mstore(0x00, 0x7bc0d848)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,bool)`.\n            mstore(0x00, 0x678209a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,uint256)`.\n            mstore(0x00, 0xb69bcaf6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,uint256,string)`.\n            mstore(0x00, 0xa1f2e8aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,address)`.\n            mstore(0x00, 0xf08744e8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,bool)`.\n            mstore(0x00, 0xcf020fb1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,uint256)`.\n            mstore(0x00, 0x67dd6ff1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(address,string,string)`.\n            mstore(0x00, 0xfb772265)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,address)`.\n            mstore(0x00, 0xd2763667)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,bool)`.\n            mstore(0x00, 0x18c9c746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,uint256)`.\n            mstore(0x00, 0x5f7b9afb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,address,string)`.\n            mstore(0x00, 0xde9a9270)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,address)`.\n            mstore(0x00, 0x1078f68d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,bool)`.\n            mstore(0x00, 0x50709698)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,uint256)`.\n            mstore(0x00, 0x12f21602)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,bool,string)`.\n            mstore(0x00, 0x2555fa46)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,address)`.\n            mstore(0x00, 0x088ef9d2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,bool)`.\n            mstore(0x00, 0xe8defba9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,uint256)`.\n            mstore(0x00, 0x37103367)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,uint256,string)`.\n            mstore(0x00, 0xc3fc3970)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,address)`.\n            mstore(0x00, 0x9591b953)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,bool)`.\n            mstore(0x00, 0xdbb4c247)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,uint256)`.\n            mstore(0x00, 0x1093ee11)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(bool,string,string)`.\n            mstore(0x00, 0xb076847f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,address)`.\n            mstore(0x00, 0xbcfd9be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,bool)`.\n            mstore(0x00, 0x9b6ec042)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,uint256)`.\n            mstore(0x00, 0x5a9b5ed5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,address,string)`.\n            mstore(0x00, 0x63cb41f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,address)`.\n            mstore(0x00, 0x35085f7b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,bool)`.\n            mstore(0x00, 0x20718650)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,uint256)`.\n            mstore(0x00, 0x20098014)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,bool,string)`.\n            mstore(0x00, 0x85775021)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,address)`.\n            mstore(0x00, 0x5c96b331)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,bool)`.\n            mstore(0x00, 0x4766da72)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,uint256)`.\n            mstore(0x00, 0xd1ed7a3c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,uint256,string)`.\n            mstore(0x00, 0x71d04af2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,address)`.\n            mstore(0x00, 0x7afac959)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,bool)`.\n            mstore(0x00, 0x4ceda75a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,uint256)`.\n            mstore(0x00, 0x37aa7d4c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(uint256,string,string)`.\n            mstore(0x00, 0xb115611f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,address)`.\n            mstore(0x00, 0xfcec75e0)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,bool)`.\n            mstore(0x00, 0xc91d5ed4)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,uint256)`.\n            mstore(0x00, 0x0d26b925)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,address,string)`.\n            mstore(0x00, 0xe0e9ad4f)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,address)`.\n            mstore(0x00, 0x932bbb38)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,bool)`.\n            mstore(0x00, 0x850b7ad6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,uint256)`.\n            mstore(0x00, 0xc95958d6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,bool,string)`.\n            mstore(0x00, 0xe298f47d)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,address)`.\n            mstore(0x00, 0x1c7ec448)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,bool)`.\n            mstore(0x00, 0xca7733b1)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,uint256)`.\n            mstore(0x00, 0xca47c4eb)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,uint256,string)`.\n            mstore(0x00, 0x5970e089)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,address)`.\n            mstore(0x00, 0x95ed0195)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,bool)`.\n            mstore(0x00, 0xb0e0f9b5)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,uint256)`.\n            mstore(0x00, 0x5821efa1)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            // Selector of `log(string,string,string)`.\n            mstore(0x00, 0x2ced7cef)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, 0xe0)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n            writeString(0x100, p2)\n        }\n        _sendLogPayload(0x1c, 0x124);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n        }\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,address)`.\n            mstore(0x00, 0x665bf134)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,bool)`.\n            mstore(0x00, 0x0e378994)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,uint256)`.\n            mstore(0x00, 0x94250d77)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,address,string)`.\n            mstore(0x00, 0xf808da20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,address)`.\n            mstore(0x00, 0x9f1bc36e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,bool)`.\n            mstore(0x00, 0x2cd4134a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,uint256)`.\n            mstore(0x00, 0x3971e78c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,bool,string)`.\n            mstore(0x00, 0xaa6540c8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,address)`.\n            mstore(0x00, 0x8da6def5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,bool)`.\n            mstore(0x00, 0x9b4254e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,uint256)`.\n            mstore(0x00, 0xbe553481)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,uint256,string)`.\n            mstore(0x00, 0xfdb4f990)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,address)`.\n            mstore(0x00, 0x8f736d16)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,bool)`.\n            mstore(0x00, 0x6f1a594e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,uint256)`.\n            mstore(0x00, 0xef1cefe7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,address,string,string)`.\n            mstore(0x00, 0x21bdaf25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,address)`.\n            mstore(0x00, 0x660375dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,bool)`.\n            mstore(0x00, 0xa6f50b0f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,uint256)`.\n            mstore(0x00, 0xa75c59de)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,address,string)`.\n            mstore(0x00, 0x2dd778e6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,address)`.\n            mstore(0x00, 0xcf394485)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,bool)`.\n            mstore(0x00, 0xcac43479)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,uint256)`.\n            mstore(0x00, 0x8c4e5de6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,bool,string)`.\n            mstore(0x00, 0xdfc4a2e8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,address)`.\n            mstore(0x00, 0xccf790a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,bool)`.\n            mstore(0x00, 0xc4643e20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,uint256)`.\n            mstore(0x00, 0x386ff5f4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,uint256,string)`.\n            mstore(0x00, 0x0aa6cfad)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,address)`.\n            mstore(0x00, 0x19fd4956)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,bool)`.\n            mstore(0x00, 0x50ad461d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,uint256)`.\n            mstore(0x00, 0x80e6a20b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,bool,string,string)`.\n            mstore(0x00, 0x475c5c33)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,address)`.\n            mstore(0x00, 0x478d1c62)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,bool)`.\n            mstore(0x00, 0xa1bcc9b3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,uint256)`.\n            mstore(0x00, 0x100f650e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,address,string)`.\n            mstore(0x00, 0x1da986ea)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,address)`.\n            mstore(0x00, 0xa31bfdcc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,bool)`.\n            mstore(0x00, 0x3bf5e537)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,uint256)`.\n            mstore(0x00, 0x22f6b999)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,bool,string)`.\n            mstore(0x00, 0xc5ad85f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,address)`.\n            mstore(0x00, 0x20e3984d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,bool)`.\n            mstore(0x00, 0x66f1bc67)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,uint256)`.\n            mstore(0x00, 0x34f0e636)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,uint256,string)`.\n            mstore(0x00, 0x4a28c017)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,address)`.\n            mstore(0x00, 0x5c430d47)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,bool)`.\n            mstore(0x00, 0xcf18105c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,uint256)`.\n            mstore(0x00, 0xbf01f891)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,uint256,string,string)`.\n            mstore(0x00, 0x88a8c406)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,address)`.\n            mstore(0x00, 0x0d36fa20)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,bool)`.\n            mstore(0x00, 0x0df12b76)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,uint256)`.\n            mstore(0x00, 0x457fe3cf)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,address,string)`.\n            mstore(0x00, 0xf7e36245)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,address)`.\n            mstore(0x00, 0x205871c2)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,bool)`.\n            mstore(0x00, 0x5f1d5c9f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,uint256)`.\n            mstore(0x00, 0x515e38b6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,bool,string)`.\n            mstore(0x00, 0xbc0b61fe)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,address)`.\n            mstore(0x00, 0x63183678)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,bool)`.\n            mstore(0x00, 0x0ef7e050)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,uint256)`.\n            mstore(0x00, 0x1dc8e1b8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,uint256,string)`.\n            mstore(0x00, 0x448830a8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,address)`.\n            mstore(0x00, 0xa04e2f87)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,bool)`.\n            mstore(0x00, 0x35a5071f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,uint256)`.\n            mstore(0x00, 0x159f8927)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(address,string,string,string)`.\n            mstore(0x00, 0x5d02c50b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,address)`.\n            mstore(0x00, 0x1d14d001)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,bool)`.\n            mstore(0x00, 0x46600be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,uint256)`.\n            mstore(0x00, 0x0c66d1be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,address,string)`.\n            mstore(0x00, 0xd812a167)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,address)`.\n            mstore(0x00, 0x1c41a336)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,bool)`.\n            mstore(0x00, 0x6a9c478b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,uint256)`.\n            mstore(0x00, 0x07831502)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,bool,string)`.\n            mstore(0x00, 0x4a66cb34)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,address)`.\n            mstore(0x00, 0x136b05dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,bool)`.\n            mstore(0x00, 0xd6019f1c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,uint256)`.\n            mstore(0x00, 0x7bf181a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,uint256,string)`.\n            mstore(0x00, 0x51f09ff8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,address)`.\n            mstore(0x00, 0x6f7c603e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,bool)`.\n            mstore(0x00, 0xe2bfd60b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,uint256)`.\n            mstore(0x00, 0xc21f64c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,address,string,string)`.\n            mstore(0x00, 0xa73c1db6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,address)`.\n            mstore(0x00, 0xf4880ea4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,bool)`.\n            mstore(0x00, 0xc0a302d8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,uint256)`.\n            mstore(0x00, 0x4c123d57)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,address,string)`.\n            mstore(0x00, 0xa0a47963)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,address)`.\n            mstore(0x00, 0x8c329b1a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,bool)`.\n            mstore(0x00, 0x3b2a5ce0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,uint256)`.\n            mstore(0x00, 0x6d7045c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,bool,string)`.\n            mstore(0x00, 0x2ae408d4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,address)`.\n            mstore(0x00, 0x54a7a9a0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,bool)`.\n            mstore(0x00, 0x619e4d0e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,uint256)`.\n            mstore(0x00, 0x0bb00eab)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,uint256,string)`.\n            mstore(0x00, 0x7dd4d0e0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,address)`.\n            mstore(0x00, 0xf9ad2b89)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,bool)`.\n            mstore(0x00, 0xb857163a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,uint256)`.\n            mstore(0x00, 0xe3a9ca2f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,bool,string,string)`.\n            mstore(0x00, 0x6d1e8751)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,address)`.\n            mstore(0x00, 0x26f560a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,bool)`.\n            mstore(0x00, 0xb4c314ff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,uint256)`.\n            mstore(0x00, 0x1537dc87)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,address,string)`.\n            mstore(0x00, 0x1bb3b09a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,address)`.\n            mstore(0x00, 0x9acd3616)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,bool)`.\n            mstore(0x00, 0xceb5f4d7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,uint256)`.\n            mstore(0x00, 0x7f9bbca2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,bool,string)`.\n            mstore(0x00, 0x9143dbb1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,address)`.\n            mstore(0x00, 0x00dd87b9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,bool)`.\n            mstore(0x00, 0xbe984353)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,uint256)`.\n            mstore(0x00, 0x374bb4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,uint256,string)`.\n            mstore(0x00, 0x8e69fb5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,address)`.\n            mstore(0x00, 0xfedd1fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,bool)`.\n            mstore(0x00, 0xe5e70b2b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,uint256)`.\n            mstore(0x00, 0x6a1199e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,uint256,string,string)`.\n            mstore(0x00, 0xf5bc2249)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,address)`.\n            mstore(0x00, 0x2b2b18dc)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,bool)`.\n            mstore(0x00, 0x6dd434ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,uint256)`.\n            mstore(0x00, 0xa5cada94)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,address,string)`.\n            mstore(0x00, 0x12d6c788)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,address)`.\n            mstore(0x00, 0x538e06ab)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,bool)`.\n            mstore(0x00, 0xdc5e935b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,uint256)`.\n            mstore(0x00, 0x1606a393)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,bool,string)`.\n            mstore(0x00, 0x483d0416)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,address)`.\n            mstore(0x00, 0x1596a1ce)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,bool)`.\n            mstore(0x00, 0x6b0e5d53)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,uint256)`.\n            mstore(0x00, 0x28863fcb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,uint256,string)`.\n            mstore(0x00, 0x1ad96de6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,address)`.\n            mstore(0x00, 0x97d394d8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,bool)`.\n            mstore(0x00, 0x1e4b87e5)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,uint256)`.\n            mstore(0x00, 0x7be0c3eb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(bool,string,string,string)`.\n            mstore(0x00, 0x1762e32a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,address)`.\n            mstore(0x00, 0x2488b414)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,bool)`.\n            mstore(0x00, 0x091ffaf5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,uint256)`.\n            mstore(0x00, 0x736efbb6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,address,string)`.\n            mstore(0x00, 0x031c6f73)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,address)`.\n            mstore(0x00, 0xef72c513)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,bool)`.\n            mstore(0x00, 0xe351140f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,uint256)`.\n            mstore(0x00, 0x5abd992a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,bool,string)`.\n            mstore(0x00, 0x90fb06aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,address)`.\n            mstore(0x00, 0x15c127b5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,bool)`.\n            mstore(0x00, 0x5f743a7c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,uint256)`.\n            mstore(0x00, 0x0c9cd9c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,uint256,string)`.\n            mstore(0x00, 0xddb06521)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,address)`.\n            mstore(0x00, 0x9cba8fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,bool)`.\n            mstore(0x00, 0xcc32ab07)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,uint256)`.\n            mstore(0x00, 0x46826b5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,address,string,string)`.\n            mstore(0x00, 0x3e128ca3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,address)`.\n            mstore(0x00, 0xa1ef4cbb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,bool)`.\n            mstore(0x00, 0x454d54a5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,uint256)`.\n            mstore(0x00, 0x078287f5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,address,string)`.\n            mstore(0x00, 0xade052c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,address)`.\n            mstore(0x00, 0x69640b59)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,bool)`.\n            mstore(0x00, 0xb6f577a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,uint256)`.\n            mstore(0x00, 0x7464ce23)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,bool,string)`.\n            mstore(0x00, 0xdddb9561)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,address)`.\n            mstore(0x00, 0x88cb6041)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,bool)`.\n            mstore(0x00, 0x91a02e2a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,uint256)`.\n            mstore(0x00, 0xc6acc7a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,uint256,string)`.\n            mstore(0x00, 0xde03e774)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,address)`.\n            mstore(0x00, 0xef529018)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,bool)`.\n            mstore(0x00, 0xeb928d7f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,uint256)`.\n            mstore(0x00, 0x2c1d0746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,bool,string,string)`.\n            mstore(0x00, 0x68c8b8bd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,address)`.\n            mstore(0x00, 0x56a5d1b1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,bool)`.\n            mstore(0x00, 0x15cac476)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,uint256)`.\n            mstore(0x00, 0x88f6e4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,address,string)`.\n            mstore(0x00, 0x6cde40b8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,address)`.\n            mstore(0x00, 0x9a816a83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,bool)`.\n            mstore(0x00, 0xab085ae6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,uint256)`.\n            mstore(0x00, 0xeb7f6fd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,bool,string)`.\n            mstore(0x00, 0xa5b4fc99)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,address)`.\n            mstore(0x00, 0xfa8185af)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,bool)`.\n            mstore(0x00, 0xc598d185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\n            mstore(0x00, 0x193fb800)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,uint256,string)`.\n            mstore(0x00, 0x59cfcbe3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,address)`.\n            mstore(0x00, 0x42d21db7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,bool)`.\n            mstore(0x00, 0x7af6ab25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,uint256)`.\n            mstore(0x00, 0x5da297eb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,uint256,string,string)`.\n            mstore(0x00, 0x27d8afd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,address)`.\n            mstore(0x00, 0x6168ed61)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,bool)`.\n            mstore(0x00, 0x90c30a56)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,uint256)`.\n            mstore(0x00, 0xe8d3018d)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,address,string)`.\n            mstore(0x00, 0x9c3adfa1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,address)`.\n            mstore(0x00, 0xae2ec581)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,bool)`.\n            mstore(0x00, 0xba535d9c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,uint256)`.\n            mstore(0x00, 0xcf009880)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,bool,string)`.\n            mstore(0x00, 0xd2d423cd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,address)`.\n            mstore(0x00, 0x3b2279b4)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,bool)`.\n            mstore(0x00, 0x691a8f74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,uint256)`.\n            mstore(0x00, 0x82c25b74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,uint256,string)`.\n            mstore(0x00, 0xb7b914ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,address)`.\n            mstore(0x00, 0xd583c602)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,bool)`.\n            mstore(0x00, 0xb3a6b6bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,uint256)`.\n            mstore(0x00, 0xb028c9bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(uint256,string,string,string)`.\n            mstore(0x00, 0x21ad0683)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,address)`.\n            mstore(0x00, 0xed8f28f6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,bool)`.\n            mstore(0x00, 0xb59dbd60)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,uint256)`.\n            mstore(0x00, 0x8ef3f399)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,address,string)`.\n            mstore(0x00, 0x800a1c67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,address)`.\n            mstore(0x00, 0x223603bd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,bool)`.\n            mstore(0x00, 0x79884c2b)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,uint256)`.\n            mstore(0x00, 0x3e9f866a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,bool,string)`.\n            mstore(0x00, 0x0454c079)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,address)`.\n            mstore(0x00, 0x63fb8bc5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,bool)`.\n            mstore(0x00, 0xfc4845f0)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,uint256)`.\n            mstore(0x00, 0xf8f51b1e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,uint256,string)`.\n            mstore(0x00, 0x5a477632)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,address)`.\n            mstore(0x00, 0xaabc9a31)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,bool)`.\n            mstore(0x00, 0x5f15d28c)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,uint256)`.\n            mstore(0x00, 0x91d1112e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,address,string,string)`.\n            mstore(0x00, 0x245986f2)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,address)`.\n            mstore(0x00, 0x33e9dd1d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,bool)`.\n            mstore(0x00, 0x958c28c6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,uint256)`.\n            mstore(0x00, 0x5d08bb05)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,address,string)`.\n            mstore(0x00, 0x2d8e33a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,address)`.\n            mstore(0x00, 0x7190a529)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,bool)`.\n            mstore(0x00, 0x895af8c5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,uint256)`.\n            mstore(0x00, 0x8e3f78a9)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,bool,string)`.\n            mstore(0x00, 0x9d22d5dd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,address)`.\n            mstore(0x00, 0x935e09bf)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,bool)`.\n            mstore(0x00, 0x8af7cf8a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,uint256)`.\n            mstore(0x00, 0x64b5bb67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,uint256,string)`.\n            mstore(0x00, 0x742d6ee7)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,address)`.\n            mstore(0x00, 0xe0625b29)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,bool)`.\n            mstore(0x00, 0x3f8a701d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,uint256)`.\n            mstore(0x00, 0x24f91465)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,bool,string,string)`.\n            mstore(0x00, 0xa826caeb)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,address)`.\n            mstore(0x00, 0x5ea2b7ae)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,bool)`.\n            mstore(0x00, 0x82112a42)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,uint256)`.\n            mstore(0x00, 0x4f04fdc6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,address,string)`.\n            mstore(0x00, 0x9ffb2f93)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,address)`.\n            mstore(0x00, 0xe0e95b98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,bool)`.\n            mstore(0x00, 0x354c36d6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,uint256)`.\n            mstore(0x00, 0xe41b6f6f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,bool,string)`.\n            mstore(0x00, 0xabf73a98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,address)`.\n            mstore(0x00, 0xe21de278)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,bool)`.\n            mstore(0x00, 0x7626db92)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,uint256)`.\n            mstore(0x00, 0xa7a87853)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,uint256,string)`.\n            mstore(0x00, 0x854b3496)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,address)`.\n            mstore(0x00, 0x7c4632a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,bool)`.\n            mstore(0x00, 0x7d24491d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,uint256)`.\n            mstore(0x00, 0xc67ea9d1)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,uint256,string,string)`.\n            mstore(0x00, 0x5ab84e1f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,address)`.\n            mstore(0x00, 0x439c7bef)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,bool)`.\n            mstore(0x00, 0x5ccd4e37)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,uint256)`.\n            mstore(0x00, 0x7cc3c607)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,address,string)`.\n            mstore(0x00, 0xeb1bff80)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,address)`.\n            mstore(0x00, 0xc371c7db)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,bool)`.\n            mstore(0x00, 0x40785869)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,uint256)`.\n            mstore(0x00, 0xd6aefad2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,bool,string)`.\n            mstore(0x00, 0x5e84b0ea)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,address)`.\n            mstore(0x00, 0x1023f7b2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,bool)`.\n            mstore(0x00, 0xc3a8a654)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,uint256)`.\n            mstore(0x00, 0xf45d7d2c)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,uint256,string)`.\n            mstore(0x00, 0x5d1a971a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,address)`.\n            mstore(0x00, 0x6d572f44)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,bool)`.\n            mstore(0x00, 0x2c1754ed)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,uint256)`.\n            mstore(0x00, 0x8eafb02b)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        bytes32 m11;\n        bytes32 m12;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            m11 := mload(0x160)\n            m12 := mload(0x180)\n            // Selector of `log(string,string,string,string)`.\n            mstore(0x00, 0xde68f20a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, 0x140)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n            writeString(0x160, p3)\n        }\n        _sendLogPayload(0x1c, 0x184);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n            mstore(0x160, m11)\n            mstore(0x180, m12)\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"},"script/UpdateDiamondViewsMultisig.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n/*\n * Helper script for diamond upgrade (only viewer facets)\n *\n * Usage:\n * 1. Check that the old deployment json is present (deployments/<env>.json) and not rewritten with something new\n * 2. Run the script with the following command:\n *    CONTRACTS_ENV_NAME=stage forge script UpdateDiamondViewMultisig --rpc-url https://rpc.stage.fluence.dev -vvv --skip-simulation --private-key ... --broadcast\n *    The script will deploy new facets and DealImpl, and generate a multicall transaction to update the diamond.\n * 3. Check the output of the script, especially the generated transaction.\n * 4. The script also upgrades Diamond on fork (not really) to check if the transaction is valid.\n *    It checks difficulty before and after upgrade and logs it in console.\n * 5. If everything is fine, run the transaction in the multisig UI.\n */\n\npragma solidity ^0.8.19;\n\nimport {Script, console2} from \"forge-std/Script.sol\";\n\nimport {Deployment} from \"script/utils/Deployment.sol\";\nimport {SelectorsHelper} from \"script/utils/SelectorsHelper.sol\";\nimport {IDiamondCut} from \"src/interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"src/interfaces/IDiamondLoupe.sol\";\nimport {ICapacityConst} from \"src/core/interfaces/ICapacityConst.sol\";\nimport {IViewer} from \"src/interfaces/IViewer.sol\";\n\n\ncontract UpdateDiamondViewsMultisig is Script, Deployment, SelectorsHelper {\n    string constant DEPLOYMENTS_PATH = \"/deployments/\";\n    string private fullDeploymentsPath;\n    string envName;\n\n    address constant REAL_MULTISIG_ON_ALL_ENVS = 0xEaf9135D113b720259d923c044d621e604E1B533;\n\n    function setUp() external {\n        envName = vm.envString(\"CONTRACTS_ENV_NAME\");\n        string memory fileNames = string.concat(envName, \".json\");\n        fullDeploymentsPath = string.concat(vm.projectRoot(), DEPLOYMENTS_PATH, fileNames);\n    }\n\n    function contractAddress(string memory env, string memory name) private view returns (address) {\n        string memory path = string.concat(vm.projectRoot(), \"/deployments/\", env, \".json\");\n        console2.log(\"path: %s\", path);\n        string memory json = vm.readFile(path);\n        bytes memory data = vm.parseJson(json, string.concat(\".\", name, \".addr\"));\n        address c = abi.decode(data, (address));\n        console2.log(\"contract %s@%s is: %s\", name, env, c);\n        return c;\n    }\n\n    function makeDiamondCut() private returns (bytes memory) {\n        address diamond = contractAddress(envName, \"Diamond\");\n\n        address viewerFacet = contractAddress(envName, \"ViewerFacet\");\n\n        // EMERGENCY BLOCK (use if we don't have the actual addresses in the deployment json)\n        // address viewerFacet = IDiamondLoupe(diamond).facetAddress(IViewer.getCommitmentStatuses.selector);\n        // END OF EMERGENCY BLOCK\n\n        // let's check validity of facet address in deployment json\n        IDiamondLoupe.Facet[] memory actualFacets = IDiamondLoupe(diamond).facets();\n        bool found = false;\n        for (uint256 j = 0; j < actualFacets.length; j++) {\n            if (actualFacets[j].facetAddress == viewerFacet) {\n                found = true;\n                break;\n            }\n        }\n        require(found, \"UpdateDiamondViewsMultisig: viewer facet not matched, probably you have unwanted local changes\");\n\n        // first part of diamondCut is for removing all selectors from facets\n        // second part is for adding new facets\n        // so we need to double the length of facets\n        IDiamondCut.FacetCut[] memory diamondCut = new IDiamondCut.FacetCut[](2);\n        bytes4[] memory facetFunctionSelectors = IDiamondLoupe(diamond).facetFunctionSelectors(viewerFacet);\n        diamondCut[0] = IDiamondCut.FacetCut({\n            facetAddress: address(0),\n            action: IDiamondCut.FacetCutAction.Remove,\n            functionSelectors: facetFunctionSelectors\n        });\n\n        // deploy new facets\n        address newViewerFacet = _deployContract(\"ViewerFacet\", \"ViewerFacet\", new bytes(0));\n\n        diamondCut[1] = IDiamondCut.FacetCut({\n            facetAddress: newViewerFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getViewerSelectors()\n        });\n        bytes memory _calldata = abi.encodeWithSelector(IDiamondCut.diamondCut.selector, diamondCut, address(0), \"\");\n\n        return _calldata;\n    }\n\n    function _startDeploy() internal virtual {\n        _loadDeployment(fullDeploymentsPath);\n\n        console2.log(\"\\nStart deploying...\");\n    }\n\n    function _stopDeploy() internal virtual {\n        _printDeployments();\n        _saveDeployment(fullDeploymentsPath);\n\n        console2.log(\"\\nDeploy finished\");\n    }\n\n\n    function run() external {\n        vm.startBroadcast();\n        _startDeploy();\n\n        address diamond = contractAddress(envName, \"Diamond\");\n\n        bytes memory _tx = makeDiamondCut();\n\n        _stopDeploy();\n        vm.stopBroadcast(); // we have stopped the broadcast, so we don't send any transactions below (do it on fork)\n\n        console2.log(\"\\n\\n\\nUpgrade bytecode:\\n\");\n        console2.logBytes(_tx); // log the transaction\n        console2.log(\"\\n\\n\\n=================\\n\");\n\n        // check if the transaction is valid and difficulty isn't changed\n        bytes32 difficultyBefore = ICapacityConst(diamond).difficulty();\n\n        vm.startPrank(REAL_MULTISIG_ON_ALL_ENVS);\n        (bool success, ) = diamond.call(_tx);\n        require(success, \"UpdateDiamondMultisig: failed to update diamond\");\n\n        bytes32 difficultyAfter = ICapacityConst(diamond).difficulty();\n        require(difficultyBefore == difficultyAfter, \"UpdateDiamondMultisig: difficulty changed\");\n        console2.log(\"Difficulty not changed:\");\n        console2.logBytes32(ICapacityConst(diamond).difficulty());\n    }\n}\n"},"script/utils/Deployment.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\npragma solidity ^0.8.19;\n\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {ScriptBase, stdJson, StdStyle, console} from \"forge-std/Script.sol\";\n\ncontract Deployment is ScriptBase {\n    using Strings for string;\n    using stdJson for string;\n\n    // ------------------ Types ------------------\n\n    struct DeployedContract {\n        address addr;\n        bytes32 codeHash;\n        uint256 blockNumber;\n        bytes32 creationCodeHash;\n    }\n\n    struct DeploymentInfo {\n        string[] contractNames;\n        mapping(string => DeployedContract) contracts;\n    }\n\n    // ------------------ Variables ------------------\n    DeploymentInfo deployment;\n\n    // ------------------ Internal functions ------------------\n    function _loadDeployment(string memory path) internal {\n        if (!vm.exists(path)) {\n            return;\n        }\n\n        string memory file = vm.readFile(path);\n        string[] memory keys = vm.parseJsonKeys(file, \"\");\n\n        deployment.contractNames = keys;\n        for (uint256 i = 0; i < keys.length; i++) {\n            string memory key = keys[i];\n\n            DeployedContract memory deployedContract;\n\n            deployedContract.addr = abi.decode(vm.parseJson(file, string.concat(\".\", key, \".addr\")), (address));\n            deployedContract.codeHash = abi.decode(vm.parseJson(file, string.concat(\".\", key, \".codeHash\")), (bytes32));\n            deployedContract.blockNumber =\n                abi.decode(vm.parseJson(file, string.concat(\".\", key, \".blockNumber\")), (uint256));\n            deployedContract.creationCodeHash =\n                abi.decode(vm.parseJson(file, string.concat(\".\", key, \".creationCodeHash\")), (bytes32));\n\n            deployment.contracts[key] = deployedContract;\n        }\n    }\n\n    function _saveDeployment(string memory path) internal {\n        string memory mainJsonKey = \"\";\n        string memory json = \"\";\n        for (uint256 i = 0; i < deployment.contractNames.length; i++) {\n            string memory name = deployment.contractNames[i];\n            DeployedContract memory deployedContract = deployment.contracts[name];\n\n            string memory envName = vm.envString(\"CONTRACTS_ENV_NAME\");\n            if (envName.equal(\"local\")) {\n                // in local.json we need only addresses\n                deployedContract.blockNumber = 1;\n                deployedContract.codeHash = \"\";\n                deployedContract.creationCodeHash = \"\";\n            }\n\n            name.serialize(\"addr\", deployedContract.addr);\n            name.serialize(\"codeHash\", deployedContract.codeHash);\n\n            name.serialize(\"blockNumber\", deployedContract.blockNumber);\n            string memory deployedContractObject = name.serialize(\"creationCodeHash\", deployedContract.creationCodeHash);\n\n            json = mainJsonKey.serialize(name, deployedContractObject);\n        }\n\n        if (json.equal(\"\")) {\n            return;\n        }\n\n        json.write(path);\n\n        // TODO: rm hack below on solving https://github.com/foundry-rs/forge-std/issues/488.\n        string memory a = \"\";\n        json = a.serialize(a, a.serialize(\"creationCodeHash\", a));\n    }\n\n    function _deployContract(string memory contractName, string memory artifactName, bytes memory args)\n        internal\n        returns (address)\n    {\n        (address addr,) = _tryDeployContract(contractName, artifactName, args);\n\n        return addr;\n    }\n\n    function _deployContract(string memory contractName, string memory artifactName, bytes memory args, bool force)\n        internal\n        returns (address)\n    {\n        (address addr,) = _tryDeployContract(contractName, artifactName, args, force);\n\n        return addr;\n    }\n\n    function _tryDeployContract(string memory contractName, string memory artifactName, bytes memory args)\n        internal\n        returns (address, bool)\n    {\n        return _tryDeployContract(contractName, artifactName, args, false);\n    }\n\n    function _tryDeployContract(string memory contractName, string memory artifactName, bytes memory args, bool force)\n        internal\n        returns (address, bool)\n    {\n        if (force) {\n            delete deployment.contracts[contractName];\n        }\n\n        DeployedContract memory deployedContract = deployment.contracts[contractName];\n\n        string memory artifact = string.concat(artifactName, \".sol\");\n        bytes memory creationCode = abi.encodePacked(vm.getCode(artifact), args);\n        bytes memory code = vm.getDeployedCode(artifact);\n\n        bytes32 codeHash = keccak256(code);\n        bytes32 creationCodeHash = keccak256(creationCode);\n\n        bool isNew = deployedContract.addr == address(0) || deployedContract.codeHash != codeHash\n            || deployedContract.creationCodeHash != creationCodeHash || _extcodehash(deployedContract.addr) == bytes32(0x00);\n\n        if (!isNew) {\n            address deployedAddr = deployedContract.addr;\n            console.log(\"Reusing %s at %s\", contractName, deployedAddr);\n            return (deployedAddr, isNew);\n        }\n\n        address addr;\n\n        assembly (\"memory-safe\") {\n            addr := create(0, add(creationCode, 0x20), mload(creationCode))\n        }\n\n        require(addr != address(0), \"Failed to deploy contract\");\n\n        console.log(\"Deploy %s at %s\", contractName, addr);\n\n        deployedContract = DeployedContract({\n            addr: addr,\n            codeHash: codeHash,\n            blockNumber: block.number,\n            creationCodeHash: creationCodeHash\n        });\n        deployment.contracts[contractName] = deployedContract;\n\n        if (isNew) {\n            deployment.contractNames.push(contractName);\n        }\n\n        return (addr, isNew);\n    }\n\n    function _doNeedToRedeploy(string memory contractName, string memory artifactName) internal view returns (bool) {\n        DeployedContract memory deployedContract = deployment.contracts[contractName];\n\n        string memory artifact = string.concat(artifactName, \".sol\");\n        bytes memory code = vm.getDeployedCode(artifact);\n        bytes32 codeHash = keccak256(code);\n\n        bool isNew = deployedContract.addr == address(0) || _extcodehash(deployedContract.addr) == bytes32(0x00)\n            || deployedContract.codeHash != codeHash;\n\n        return isNew;\n    }\n\n    function _getDeployedContract(string memory contractName) internal view returns (address) {\n        address deployedContract = deployment.contracts[contractName].addr;\n        require(deployedContract != address(0), string.concat(\"Deployment not found: \", contractName));\n        return deployedContract;\n    }\n\n    function _printDeployments() internal view {\n        console.log(\"\\n\");\n        console.log(\"----------------- Deployments -----------------\");\n        for (uint256 i = 0; i < deployment.contractNames.length; i++) {\n            string memory name = deployment.contractNames[i];\n            DeployedContract memory deployedContract = deployment.contracts[name];\n\n            console.log(StdStyle.green(name), deployedContract.addr);\n        }\n    }\n\n    function _setContract(string memory contractName, address addr, bytes32 codeHash, bytes32 creationCodeHash)\n        internal\n    {\n        if (deployment.contracts[contractName].addr == address(0)) {\n            deployment.contractNames.push(contractName);\n        }\n\n        deployment.contracts[contractName] = DeployedContract({\n            addr: addr,\n            codeHash: codeHash,\n            blockNumber: block.number,\n            creationCodeHash: creationCodeHash\n        });\n    }\n\n    // ------------------ Private functions ------------------\n    function _extcodehash(address addr) private view returns (bytes32 hash) {\n        assembly {\n            hash := extcodehash(addr)\n        }\n    }\n}\n"},"script/utils/SelectorsHelper.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\npragma solidity ^0.8.19;\n\nimport {IBaseOffer} from \"src/core/interfaces/IBaseOffer.sol\";\nimport {ICore} from \"src/core/interfaces/ICore.sol\";\nimport {ICapacityConst} from \"src/core/interfaces/ICapacityConst.sol\";\nimport {IEpochController} from \"src/core/interfaces/IEpochController.sol\";\nimport {IGlobalConst} from \"src/core/interfaces/IGlobalConst.sol\";\nimport {IMarket} from \"src/core/interfaces/IMarket.sol\";\nimport {IMarketV2} from \"src/core/interfaces/IMarketV2.sol\";\nimport {IOffer} from \"src/core/interfaces/IOffer.sol\";\nimport {IOfferV2} from \"src/core/interfaces/IOfferV2.sol\";\nimport {IDealFactory} from \"src/core/interfaces/IDealFactory.sol\";\nimport {IDiamondCut} from \"src/interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"src/interfaces/IDiamondLoupe.sol\";\nimport {IMulticall} from \"src/interfaces/IMulticall.sol\";\nimport {ICapacity} from \"src/core/interfaces/ICapacity.sol\";\nimport {IViewer} from \"src/interfaces/IViewer.sol\";\nimport {IERC165} from \"src/interfaces/IERC165.sol\";\nimport {IERC173} from \"src/interfaces/IERC173.sol\";\nimport {IWhitelist} from \"src/interfaces/IWhitelist.sol\";\n\nabstract contract SelectorsHelper {\n    function getDiamondCut(\n        address coreFacet,\n        address offerFacet,\n        address marketFacet,\n        address offerV2Facet,\n        address marketV2Facet,\n        address capacityFacet,\n        address dealFactoryFacet,\n        address diamondLoupeFacet,\n        address ownershipFacet,\n        address multicallFacet,\n        address viewerFacet\n    ) internal pure returns (IDiamondCut.FacetCut[] memory) {\n        uint256 COUNT = 11;\n        uint256 i = 0;\n        IDiamondCut.FacetCut[] memory diamondCut = new IDiamondCut.FacetCut[](COUNT);\n\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: coreFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getCoreSelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: offerFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getOfferSelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: marketFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getMarketSelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: offerV2Facet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getOfferV2Selectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: marketV2Facet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getMarketV2Selectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: capacityFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getCapacitySelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: dealFactoryFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getDealFactorySelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: diamondLoupeFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getDiamondLoupeSelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: ownershipFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getOwnershipSelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: multicallFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getMulticallSelectors()\n        });\n        diamondCut[i++] = IDiamondCut.FacetCut({\n            facetAddress: viewerFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: getViewerSelectors()\n        });\n\n        assert(i == COUNT);\n        return diamondCut;\n    }\n\n    function getOwnershipSelectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 2;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n        selectors[i++] = IERC173.transferOwnership.selector;\n        selectors[i++] = IERC173.owner.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getCoreSelectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 50;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n        selectors[i++] = ICore.dealImpl.selector;\n        selectors[i++] = ICore.dealV2Impl.selector;\n        selectors[i++] = ICore.setDealImpl.selector;\n        selectors[i++] = ICore.setDealV2Impl.selector;\n        selectors[i++] = IGlobalConst.precision.selector;\n        selectors[i++] = IGlobalConst.minDealDepositedEpochs.selector;\n        selectors[i++] = IGlobalConst.minDealRematchingEpochs.selector;\n        selectors[i++] = IGlobalConst.minProtocolVersion.selector;\n        selectors[i++] = IGlobalConst.maxProtocolVersion.selector;\n        selectors[i++] = IGlobalConst.maxUnitCountPerProvider.selector;\n        selectors[i++] = IGlobalConst.setConstant.selector;\n        selectors[i++] = IGlobalConst.addPaymentTokenToWhitelist.selector;\n        selectors[i++] = IGlobalConst.removePaymentTokenFromWhitelist.selector;\n        selectors[i++] = IGlobalConst.isPaymentTokenAllowed.selector;\n        selectors[i++] = IGlobalConst.getAllConstants.selector;\n        selectors[i++] = ICapacityConst.fltPrice.selector;\n        selectors[i++] = ICapacityConst.fltPriceAtEpoch.selector;\n        selectors[i++] = ICapacityConst.fltCollateralPerUnit.selector;\n        selectors[i++] = ICapacityConst.usdCollateralPerUnit.selector;\n        selectors[i++] = ICapacityConst.usdTargetRevenuePerEpoch.selector;\n        selectors[i++] = ICapacityConst.minDuration.selector;\n        selectors[i++] = ICapacityConst.maxDuration.selector;\n        selectors[i++] = ICapacityConst.minCUPerCommitment.selector;\n        selectors[i++] = ICapacityConst.maxCUPerCommitment.selector;\n        selectors[i++] = ICapacityConst.minRewardPerEpoch.selector;\n        selectors[i++] = ICapacityConst.maxRewardPerEpoch.selector;\n        selectors[i++] = ICapacityConst.vestingPeriodDuration.selector;\n        selectors[i++] = ICapacityConst.vestingPeriodCount.selector;\n        selectors[i++] = ICapacityConst.slashingRate.selector;\n        selectors[i++] = ICapacityConst.minProofsPerEpoch.selector;\n        selectors[i++] = ICapacityConst.maxProofsPerEpoch.selector;\n        selectors[i++] = ICapacityConst.withdrawEpochsAfterFailed.selector;\n        selectors[i++] = ICapacityConst.maxFailedRatio.selector;\n        selectors[i++] = ICapacityConst.activeUnitCount.selector;\n        selectors[i++] = ICapacityConst.difficulty.selector;\n        selectors[i++] = ICapacityConst.randomXProxy.selector;\n        selectors[i++] = ICapacityConst.oracle.selector;\n        selectors[i++] = ICapacityConst.getRewardPool.selector;\n        selectors[i++] = ICapacityConst.setFLTPrice.selector;\n        selectors[i++] = ICapacityConst.setDifficulty.selector;\n        selectors[i++] = ICapacityConst.setCapacityConstant.selector;\n        selectors[i++] = ICapacityConst.setOracle.selector;\n        selectors[i++] = ICapacityConst.lastPriceSetting.selector;\n        selectors[i++] = IEpochController.currentEpoch.selector;\n        selectors[i++] = IEpochController.epochDuration.selector;\n        selectors[i++] = IEpochController.initTimestamp.selector;\n        selectors[i++] = IEpochController.epochTimestamp.selector;\n        selectors[i++] = IWhitelist.isApproved.selector;\n        selectors[i++] = IWhitelist.grantAccess.selector;\n        selectors[i++] = IWhitelist.revokeAccess.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getOfferSelectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 21;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n\n        selectors[i++] = IBaseOffer.getProviderInfo.selector;\n        selectors[i++] = IBaseOffer.getBaseOffer.selector;\n        selectors[i++] = IBaseOffer.getComputePeer.selector;\n        selectors[i++] = IBaseOffer.getComputeUnit.selector;\n        selectors[i++] = IBaseOffer.getComputeUnitIds.selector;\n        selectors[i++] = IBaseOffer.getComputeUnits.selector;\n        selectors[i++] = IBaseOffer.setProviderInfo.selector;\n        selectors[i++] = IBaseOffer.changePaymentToken.selector;\n\n        selectors[i++] = IOffer.getOffer.selector;\n        selectors[i++] = IOffer.getEffectorInfo.selector;\n        selectors[i++] = IOffer.registerMarketOffer.selector;\n        selectors[i++] = IOffer.addComputePeers.selector;\n        selectors[i++] = IOffer.addComputeUnits.selector;\n        selectors[i++] = IOffer.removeOffer.selector;\n        selectors[i++] = IOffer.removeComputePeer.selector;\n        selectors[i++] = IOffer.removeComputeUnit.selector;\n        selectors[i++] = IOffer.changeMinPricePerCuPerEpoch.selector;\n        selectors[i++] = IOffer.addEffector.selector;\n        selectors[i++] = IOffer.removeEffector.selector;\n        selectors[i++] = IOffer.setEffectorInfo.selector;\n        selectors[i++] = IOffer.removeEffectorInfo.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getMarketSelectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 3;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n        selectors[i++] = IMarket.matchDeal.selector;\n        selectors[i++] = IMarket.moveResourcesFromDeal.selector;\n        selectors[i++] = IMarket.reportWorkerActivated.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getOfferV2Selectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 23;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n\n        selectors[i++] = IOfferV2.registerMarketOfferV2.selector;\n        selectors[i++] = IOfferV2.upgradeMarketOfferV2.selector;\n        selectors[i++] = IOfferV2.addComputePeersV2.selector;\n        selectors[i++] = IOfferV2.addComputeUnitsV2.selector;\n        selectors[i++] = IOfferV2.removeOfferV2.selector;\n        selectors[i++] = IOfferV2.removeComputePeerV2.selector;\n        selectors[i++] = IOfferV2.removeComputeUnitV2.selector;\n        selectors[i++] = IOfferV2.changeResourcePriceV2.selector;\n        selectors[i++] = IOfferV2.changeResourceMaxSupplyV2.selector;\n        selectors[i++] = IOfferV2.removePeerResource.selector;\n        selectors[i++] = IOfferV2.registerPeerResource.selector;\n        selectors[i++] = IOfferV2.registerResources.selector;\n        selectors[i++] = IOfferV2.updateResourceMetadata.selector;\n        selectors[i++] = IOfferV2.ramPerVcpu.selector;\n        selectors[i++] = IOfferV2.vcpuPerCu.selector;\n        selectors[i++] = IOfferV2.bytesPerRam.selector;\n        selectors[i++] = IOfferV2.bytesPerStorage.selector;\n        selectors[i++] = IOfferV2.changeResourceDetails.selector;\n        selectors[i++] = IOfferV2.createDatacenter.selector;\n        selectors[i++] = IOfferV2.createDatacenters.selector;\n        selectors[i++] = IOfferV2.updateDatacenter.selector;\n        selectors[i++] = IOfferV2.setOfferDatacenter.selector;\n        selectors[i++] = IOfferV2.getOfferDatacenter.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getMarketV2Selectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 5;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n\n        selectors[i++] = IMarketV2.matchDealV2.selector;\n        selectors[i++] = IMarketV2.reportWorkerActivatedV2.selector;\n        selectors[i++] = IMarketV2.reportAppCIDUpdatedV2.selector;\n        selectors[i++] = IMarketV2.moveResourcesFromDealV2.selector;\n        selectors[i++] = IMarketV2.getWorkerData.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getCapacitySelectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 20;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n        selectors[i++] = ICapacity.getStatus.selector;\n        selectors[i++] = ICapacity.getCommitment.selector;\n        selectors[i++] = ICapacity.totalRewards.selector;\n        selectors[i++] = ICapacity.unlockedRewards.selector;\n        selectors[i++] = ICapacity.withdrawnRewards.selector;\n        selectors[i++] = ICapacity.getGlobalNonce.selector;\n        selectors[i++] = ICapacity.getRewardInfo.selector;\n        selectors[i++] = ICapacity.getRewardBalance.selector;\n        selectors[i++] = ICapacity.createCommitment.selector;\n        selectors[i++] = ICapacity.removeCommitment.selector;\n        selectors[i++] = ICapacity.finishCommitment.selector;\n        selectors[i++] = ICapacity.depositCollateral.selector;\n        selectors[i++] = ICapacity.submitProofs.selector;\n        selectors[i++] = ICapacity.submitProof.selector;\n        selectors[i++] = ICapacity.removeCUFromCC.selector;\n        selectors[i++] = ICapacity.withdrawReward.selector;\n        selectors[i++] = ICapacity.diamondReceive.selector;\n        selectors[i++] = ICapacity.withdrawCollateral.selector;\n        selectors[i++] = ICapacity.getProofCounts.selector;\n        selectors[i++] = ICapacity.getUnitExitStatuses.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getDealFactorySelectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 13;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n        selectors[i++] = IDealFactory.hasDeal.selector;\n        selectors[i++] = IDealFactory.deployDeal.selector;\n        selectors[i++] = IDealFactory.deployDealV2.selector;\n        selectors[i++] = IDealFactory.fundDeal.selector;\n        selectors[i++] = IDealFactory.fundDealV2.selector;\n        selectors[i++] = IDealFactory.setBalanceKeeper.selector;\n        selectors[i++] = IDealFactory.balanceKeeper.selector;\n        selectors[i++] = IDealFactory.setVodopad.selector;\n        selectors[i++] = IDealFactory.vodopad.selector;\n        selectors[i++] = IDealFactory.stopDealHandler.selector;\n        selectors[i++] = IDealFactory.stopDealHandlerV2.selector;\n        selectors[i++] = IDealFactory.storedDealCount.selector;\n        selectors[i++] = IDealFactory.storedDeals.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n\n    function getDiamondLoupeSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](5);\n        selectors[0] = IDiamondLoupe.facets.selector;\n        selectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\n        selectors[2] = IDiamondLoupe.facetAddresses.selector;\n        selectors[3] = IDiamondLoupe.facetAddress.selector;\n        selectors[4] = IERC165.supportsInterface.selector;\n        return selectors;\n    }\n\n    function getDiamondCutSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = IDiamondCut.diamondCut.selector;\n        return selectors;\n    }\n\n    function getMulticallSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = IMulticall.multicall.selector;\n        return selectors;\n    }\n\n    function getViewerSelectors() internal pure returns (bytes4[] memory) {\n        uint256 COUNT = 9;\n        uint256 i = 0;\n\n        bytes4[] memory selectors = new bytes4[](COUNT);\n        selectors[i++] = IViewer.getCommitmentStatuses.selector;\n        selectors[i++] = IViewer.getDatacenter.selector;\n        selectors[i++] = IViewer.getDatacenters.selector;\n        selectors[i++] = IViewer.getResources.selector;\n        selectors[i++] = IViewer.getResource.selector;\n        selectors[i++] = IViewer.getOffersV2.selector;\n        selectors[i++] = IViewer.getOfferV2.selector;\n        selectors[i++] = IViewer.getPeersV2.selector;\n        selectors[i++] = IViewer.getPeerV2.selector;\n\n        assert(i == COUNT);\n        return selectors;\n    }\n}\n"},"src/balance-keeper/IBalanceKeeper.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBalanceKeeper {\n    enum BalanceChangeReason {\n        USER_TOP_UP,\n        MOVE_FROM_DEAL,\n        MOVE_FREE_BALANCE,\n        MOVE_TO_DEAL,\n        WITHDRAW_BY_DEAL,\n        TERMINATE,\n        SEND_TO_LIMBO,\n        FUND_FROM_LIMBO,\n        REFUND\n    }\n\n    enum DealDepositReason {\n        FUND_DEAL,\n        DEPLOY_DEAL\n    }\n\n    struct DealDepositInfo {\n        IERC20 token;\n        address deal;\n        address user;\n        DealDepositReason reason;\n        uint256 amount;\n        uint256 blockNumber;\n        uint256 reserved1; // to extend the struct as elements are stacked in array\n        uint256 reserved2; // to extend the struct as elements are stacked in array\n        uint256 reserved3; // to extend the struct as elements are stacked in array\n    }\n\n    event FreeBalanceIncrease(IERC20 indexed token, address indexed user, BalanceChangeReason indexed reason, uint256 amount, address info);\n    event FreeBalanceDecrease(IERC20 indexed token, address indexed user, BalanceChangeReason indexed reason, uint256 amount, address info);\n    event BalanceMoved(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint8 reserved);\n    event DealDeposit(\n        IERC20 indexed token,\n        address indexed deal,\n        address indexed user,\n        uint256 amount,\n        DealDepositReason reason,\n        uint256 blockNumber,\n        uint256 depositIndex // index in array\n    );\n    event DealWithdraw(IERC20 indexed token, address indexed deal, address indexed user, uint256 amount, uint8 reserved);\n    event CoordinatorSet(address indexed coordinator, address initiator);\n    event PoolTopUp(IERC20 indexed token, address indexed initiator, uint256 amount);\n    event PoolWithdraw(IERC20 indexed token, address indexed initiator, uint256 amount);\n    event UserBalanceIncrease(IERC20 indexed token, address indexed user, address indexed initiator, uint256 amount, string topUpId);\n    event DealMigrated(address indexed deal, IERC20 indexed token, uint256 amount);\n    event ManualWithdrawEnabled(address initiator);\n    event ManualWithdrawDisabled(address initiator);\n    event Refunded(IERC20 indexed token, address indexed user, uint256 amount, address initiator);\n    event SentToLimbo(IERC20 indexed token, address indexed user, address initiator, uint256 amount);\n    event AccountFreezeStateChanged(address indexed user, bool frozen, address initiator);\n    event Withdrawn(IERC20 indexed token, address indexed user, uint256 amount, uint8 reserved, address initiator);\n    event TerminationVeto(IERC20 indexed token, address indexed user, address initiator);\n    event TerminationRequestCreated(IERC20 indexed token, address indexed user, address initiator);\n    event TerminationExecuted(IERC20 indexed token, address indexed user, address initiator);\n    event WithdrawnFromLimbo(IERC20 indexed token, address indexed user, address indexed to, address initiator, uint256 amount);\n    event FundedFromLimbo(IERC20 indexed token, address indexed user, address initiator, uint256 amount);\n\n    // STATE\n    function diamond() external view returns (address);\n    function coordinator() external view returns (address);\n    function manualWithdrawEnabled() external view returns (bool);\n    function WITHDRAW_REQUEST_DELAY() external view returns (uint256);\n    function freeBalanceTotal(IERC20 token) external view returns (uint256);\n    function dealBalancesTotal(IERC20 token) external view returns (uint256);\n    function poolBalance(IERC20 token) external view returns (uint256);\n    function limbo(IERC20 token, address user) external view returns (uint256);\n    function limboTotal(IERC20 token) external view returns (uint256);\n    function frozen(address user) external view returns (bool);\n    function topUpIds(string calldata) external view returns (bool);\n\n    // INITIALIZATION\n    function initialize(address _diamond) external;\n\n    // VIEW METHODS\n    function getFreeBalance(IERC20 token, address user) external view returns (uint256);\n    function getFullBalance(IERC20 token, address user) external view returns (uint256);\n    function getDepositInfoLength() external view returns (uint256);\n    function getDepositInfo(uint256 from, uint256 to) external view returns (DealDepositInfo[] memory);\n\n    // COORDINATOR\n    function poolTopUp(IERC20 token, uint256 amount) external;\n    function poolWithdraw(IERC20 token, uint256 amount) external;\n    function enableOnchainRefund() external;\n    function disableOnchainRefund() external;\n    function refund(IERC20 token, address user, uint256 amount) external;\n    function freezeAccount(address user) external;\n    function unfreezeAccount(address user) external;\n    function sendToLimbo(IERC20 token, address user) external;\n    function terminationVeto(IERC20 token, address user) external;\n\n    // VODOPAD\n    function userTopUp(IERC20 token, address user, uint256 amount, string memory topUpId) external;\n\n    // DEAL\n    function moveBalanceFromDeal(IERC20 token, address user, uint256 amount, uint8 reserved) external;\n    function moveBalanceToDeal(IERC20 token, address user, uint256 amount, DealDepositReason reason) external;\n    function moveFreeBalance(IERC20 token, address from, address to, uint256 amount, uint8 reserved) external;\n    function withdrawByDeal(IERC20 token, address user, uint256 amount, uint8 reserved) external;\n\n    // USER\n    function terminationRequest(IERC20 token) external;\n    function terminate(IERC20 token) external;\n\n    // ADMIN\n    function setCoordinator(address _coordinator) external;\n    function withdrawFromLimbo(IERC20 token, address user, address to, uint256 amount) external;\n    function fundFromLimbo(IERC20 token, address user, uint256 amount) external;\n}\n"},"src/core/DealStakerRewards.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {PRECISION} from \"src/utils/Common.sol\";\nimport {LibCapacityConst} from \"src/lib/LibCapacityConst.sol\";\n\nlibrary DealStakerRewards {\n    using DealStakerRewards for Info;\n\n    event EntityAdded(bytes32 indexed commitmentId, bytes32 entityId, uint256 rewardPerEpoch, uint256 currentEpoch);\n    event EntityRemoved(bytes32 indexed commitmentId, bytes32 entityId, uint256 currentEpoch);\n    event StateUpdated(bytes32 indexed commitmentId, VestingState state);\n\n    struct Info {\n        bytes32 commitmentId;\n        uint256 totalWithdrawnRewardFlt;\n\n        mapping(bytes32 => EntityInfo) entities;\n        uint256 currentRewardPerEpochUsd;\n\n        VestingParams params;\n        VestingState vestingState;\n\n        uint256 lastUpdateEpoch;\n    }\n\n    struct VestingParams {\n        uint256 reservedSlot; // previous periodDuration\n        uint256 periodCount;\n    }\n\n    struct EntityInfo {\n        uint256 rewardPerEpochUsd;\n    }\n\n    struct VestingState {\n        // params.vestingCount elements since lastUpdateEpoch in FLT\n        uint256[] items;\n        uint256 accumulatedUnlockedFlt;\n    }\n\n    function init(Info storage self, bytes32 commitmentId, uint256 currentEpoch, uint256 vestingPeriodCount, uint256 vestingPeriodDuration) internal {\n        self.lastUpdateEpoch = currentEpoch;\n        self.commitmentId = commitmentId;\n        self.params.periodCount = vestingPeriodCount * vestingPeriodDuration;\n\n        // Vesting params difference (vestingPeriodDuration = 4, vestingPeriodCount = 3)\n        // CC rewards vesting:          *           *           *\n        // DS rewards vesting: *  *  *  *  *  *  *  *  *  *  *  *\n        // epoch               1  2  3  4  5  6  7  8  9 10 11 12\n\n        // 1 epoch shift difference\n        // earned at:          *\n        // CC rewards vesting:    *  *  *  *  *\n        // De rewards vesting: *  *  *  *  *\n        // epoch               1  2  3  4  5  6\n\n        // Unhandled unpaid deals -- payments continue\n        /// provier rew: *        *  *\n        //  worker  in:  *\n        //  worker  out:                *\n        //  staker  rew: *  *  *  *  *  *\n        // epoch         1  2  3  4  5  6\n\n\n        // Using average FLT price explanation/maths\n        // fltPrice       1 5 2 3 6\n        // rewardPerEpoch x x x x x\n        // epoch          1 2 3 4 5\n\n        // 1: 1 * x / 1 = 1x\n        // 2: (1 + 5) * x / 2 * 2 = 6x\n        // 3: (1 + 5 + 2) * x / 3 * 3 = 8x\n        // self.params.periodDuration = 0; // not used\n        self.vestingState.items = new uint256[](self.params.periodCount);\n    }\n\n    function total(Info storage self, uint256 currentEpoch) internal view returns (uint256) {\n        VestingState memory vestingState = self._updateVestingState(currentEpoch);\n\n        uint256 unvested = 0;\n        for (uint256 i = 0; i < self.params.periodCount; i++) {\n            unvested += vestingState.items[i];\n        }\n\n        return vestingState.accumulatedUnlockedFlt + unvested - self.totalWithdrawnRewardFlt;\n    }\n\n    function unlocked(Info storage self, uint256 currentEpoch) internal view returns (uint256) {\n        VestingState memory vestingState = self._updateVestingState(currentEpoch);\n\n        return vestingState.accumulatedUnlockedFlt - self.totalWithdrawnRewardFlt;\n    }\n\n    // long name to not mix up with withdraw method\n    function totalWithdrawn(Info storage self) internal view returns (uint256) {\n        return self.totalWithdrawnRewardFlt;\n    }\n\n    function withdraw(Info storage self, uint256 currentEpoch) internal returns (uint256) {\n        self._update(currentEpoch);\n        uint256 withdrawAmount = self.vestingState.accumulatedUnlockedFlt - self.totalWithdrawnRewardFlt;\n        //no require because CCs has 2 sources of rewards\n        //require(withdrawAmount > 0, \"Nothing to withdraw\");\n\n        self.totalWithdrawnRewardFlt += withdrawAmount;\n        return withdrawAmount;\n    }\n\n    function addEntity(\n        Info storage self,\n        bytes32 id,\n        uint256 rewardPerEpoch,\n        uint256 currentEpoch\n    ) internal {\n        self._update(currentEpoch);\n        self.entities[id].rewardPerEpochUsd = rewardPerEpoch;\n        self.currentRewardPerEpochUsd += rewardPerEpoch;\n        emit EntityAdded(self.commitmentId, id, rewardPerEpoch, currentEpoch);\n    }\n\n    function removeEntity(\n        Info storage self,\n        bytes32 id,\n        uint256 currentEpoch\n    ) internal {\n        self._update(currentEpoch);\n        self.currentRewardPerEpochUsd -= self.entities[id].rewardPerEpochUsd;\n        delete self.entities[id];\n        emit EntityRemoved(self.commitmentId, id, currentEpoch);\n    }\n\n    function _update(Info storage self, uint256 currentEpoch) internal {\n        self.vestingState = self._updateVestingState(currentEpoch);\n        self.lastUpdateEpoch = currentEpoch;\n        emit StateUpdated(self.commitmentId, self.vestingState);\n    }\n\n    function _updateVestingState(Info storage self, uint256 currentEpoch) internal view returns (VestingState memory) {\n        VestingState memory vestingState = self.vestingState;\n        if (currentEpoch == self.lastUpdateEpoch) {\n            return vestingState;\n        }\n\n        uint256 vestedEpochs = currentEpoch - self.lastUpdateEpoch;\n        // important: this code does not use price from ongoing epoch, so it will always return the same value for any call during epoch.\n        // from start of lastUpdateEpoch to 1s before the start of currentEpoch\n        // important: we have to use price in flt/usd units so that we can just multiply\n        // otherwise, meanRewardPerEpochFlt would be incorrect\n        // usdReward is constant during period\n        // (usdReward * fltUsd_1 + .. + usdReward * fltUsd_n) / n = usdReward * meanFltUsd\n        // (usdReward / usdFlt_1 + .. + usdReward / usdFlt_n) / n != usdReward / meanUsdFlt\n        uint256 meanRevFltPrice = LibCapacityConst.meanRevFltPrice(self.lastUpdateEpoch, currentEpoch - 1);\n        // (usd * USD_PRECISION) * (meanRevFltPrice * USD_PRECISION) * FLT_PRECISION / (USD_PRECISION * USD_PRECISION) =\n        // = flt * FLT_PRECISION\n        uint256 meanRewardPerEpochFlt = self.currentRewardPerEpochUsd * meanRevFltPrice * (1 ether) / (PRECISION * PRECISION);\n\n        (uint256 addUnlocked, uint256[] memory deceleration) = _calcAdditionalVesting(vestedEpochs, meanRewardPerEpochFlt, self.params.periodCount);\n\n        vestingState.accumulatedUnlockedFlt += addUnlocked;\n\n        for (uint256 i = 0; i < self.params.periodCount; i++) {\n            if (i < vestedEpochs) {\n                vestingState.accumulatedUnlockedFlt += vestingState.items[i];\n            }\n\n            if (i + vestedEpochs < self.params.periodCount) {\n                vestingState.items[i] = vestingState.items[i + vestedEpochs];\n            } else {\n                vestingState.items[i] = 0;\n            }\n\n            vestingState.items[i] += deceleration[i];\n        }\n\n        return vestingState;\n    }\n\n    function _calcAdditionalVesting(uint256 vestedEpochs, uint256 rewardPerEpoch, uint256 periodCount) internal pure returns (uint256, uint256[] memory) {\n        if (rewardPerEpoch == 0) {\n            return (0, new uint256[](periodCount));\n        }\n\n        uint256 rewardPerPart = rewardPerEpoch / periodCount;\n\n        uint256 maxSpeedEpochs = 0;\n        uint256 accelerationEpochs = min(periodCount, vestedEpochs);\n        if (vestedEpochs > accelerationEpochs) {\n            maxSpeedEpochs = vestedEpochs - accelerationEpochs;\n        }\n\n\n        uint256 accelerationParts = accelerationEpochs * (accelerationEpochs + 1) / 2;\n        uint256 maxSpeedParts = maxSpeedEpochs * periodCount;\n\n        uint256 unlockedRewards = (accelerationParts + maxSpeedParts) * rewardPerPart;\n        uint256[] memory deceleration = new uint256[](periodCount);\n        for (uint256 i = 0; i < periodCount; i++) {\n            if (accelerationEpochs + i >= periodCount) {\n                if (accelerationEpochs > 0) {\n                    accelerationEpochs--;\n                }\n            }\n\n            deceleration[i] = accelerationEpochs * rewardPerPart;\n        }\n\n        return (unlockedRewards, deceleration);\n        // acceleration | maxSpeed | decelerarion\n        // acceleration - time when rewards per epoch is increasing\n        // maxSpeed - time when rewards per epoch are max\n        // deceleration - time when rewards per epoch are decreasing\n        // acceleration + maxSpeed -- unlocked at the end of currentEpoch\n        // deceleration - lingering vesting from accounted epochs, after currentEpoch\n        // vesting period count = 5\n        // period = 7\n        // acceleration 5\n        // maxSpeed     2\n        // deceleration = vesting period count = 5\n        // 1 1 1 1 1 0 0 0 0 0 0 0\n        // 0 1 1 1 1 1 0 0 0 0 0 0\n        // 0 0 1 1 1 1 1 0 0 0 0 0\n        // 0 0 0 1 1 1 1 1 0 0 0 0\n        // 0 0 0 0 1 1 1 1 1 0 0 0\n        // 0 0 0 0 0 1 1 1 1 1 0 0\n        // 0 0 0 0 0 0 1 1 1 1 1 0\n    // tot 1 2 3 4 5 5 5|4 3 2 1 0\n        // tot 1 2 3 4 5|4 3 2 1 0\n          // tot 1 2 3 4|4 3 2 1 0\n            // tot 1 2 3|3 3 2 1 0\n              // tot 1 2|2 2 2 1 0\n                // tot 1|1 1 1 1 0\n\n    }\n\n    function min(uint256 lhs, uint256 rhs) internal pure returns (uint256) {\n        if (lhs < rhs) {\n            return lhs;\n        } else {\n            return rhs;\n        }\n    }\n}\n"},"src/core/Snapshot.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {ICapacity} from \"src/core/interfaces/ICapacity.sol\";\n\nlibrary Snapshot {\n    struct Cache {\n        Params initial;\n        Params current;\n    }\n\n    struct Params {\n        ICapacity.CCStatus status;\n        uint256 failedEpoch;\n        uint256 totalFailCount;\n        uint256 activeUnitCount;\n        uint256 nextAdditionalActiveUnitCount;\n        uint256 snapshotEpoch;\n        uint256 currentSuccessCount;\n    }\n    \n    function init(ICapacity.Commitment storage commitment) internal view returns (Cache memory cache) {\n        cache.initial.status = commitment.info.status;\n        cache.initial.failedEpoch = commitment.finish.failedEpoch;\n        cache.initial.totalFailCount = commitment.progress.totalFailCount;\n        cache.initial.activeUnitCount = commitment.progress.activeUnitCount;\n        cache.initial.nextAdditionalActiveUnitCount = commitment.progress.nextAdditionalActiveUnitCount;\n        cache.initial.snapshotEpoch = commitment.progress.snapshotEpoch;\n        cache.initial.currentSuccessCount = commitment.progress.currentSuccessCount;\n\n        cache.current.status = cache.initial.status;\n        cache.current.failedEpoch = cache.initial.failedEpoch;\n        cache.current.totalFailCount = cache.initial.totalFailCount;\n        cache.current.activeUnitCount = cache.initial.activeUnitCount;\n        cache.current.nextAdditionalActiveUnitCount = cache.initial.nextAdditionalActiveUnitCount;\n        cache.current.snapshotEpoch = cache.initial.snapshotEpoch;\n        cache.current.currentSuccessCount = cache.initial.currentSuccessCount;\n    }\n    \n    function save(Cache memory self, ICapacity.Commitment storage commitment) internal {\n        if (self.initial.status != self.current.status) {\n            commitment.info.status = self.current.status;\n        }\n        if (self.initial.failedEpoch != self.current.failedEpoch) {\n            commitment.finish.failedEpoch = self.current.failedEpoch;\n        }\n        if (self.initial.totalFailCount != self.current.totalFailCount) {\n            commitment.progress.totalFailCount = self.current.totalFailCount;\n        }\n        if (self.initial.activeUnitCount != self.current.activeUnitCount) {\n            commitment.progress.activeUnitCount = self.current.activeUnitCount;\n        }\n        if (self.initial.nextAdditionalActiveUnitCount != self.current.nextAdditionalActiveUnitCount) {\n            commitment.progress.nextAdditionalActiveUnitCount = self.current.nextAdditionalActiveUnitCount;\n        }\n        if (self.initial.snapshotEpoch != self.current.snapshotEpoch) {\n            commitment.progress.snapshotEpoch = self.current.snapshotEpoch;\n        }\n        if (self.initial.currentSuccessCount != self.current.currentSuccessCount) {\n            commitment.progress.currentSuccessCount = self.current.currentSuccessCount;\n        }\n    }\n}\n"},"src/core/Vesting.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nlibrary Vesting {\n    struct Info {\n        uint256 totalWithdrawnReward;\n        Item[] items;\n    }\n\n    struct Item {\n        uint256 epoch;\n        uint256 cumulativeAmount;\n    }\n\n    event VestingScheduleItem(bytes32 indexed commitmentId, uint256 indexed id, uint256 indexed epoch, uint256 cumulativeAmount);\n    event VestingUpdateItem(bytes32 indexed commitmentId, uint256 indexed id, uint256 cumulativeAmount);\n\n    function total(Info storage self) internal view returns (uint256) {\n        uint256 length = self.items.length;\n        if (length == 0) {\n            return 0;\n        }\n\n        return self.items[length - 1].cumulativeAmount - self.totalWithdrawnReward;\n    }\n\n    function unlocked(Info storage self, uint256 withdrawEpoch) internal view returns (uint256) {\n        int256 index = _findClosest(self, withdrawEpoch);\n        if (index < 0) {\n            return 0;\n        }\n\n        return self.items[uint256(index)].cumulativeAmount - self.totalWithdrawnReward;\n    }\n\n    // long name to not mix up with withdraw method\n    function totalWithdrawn(Info storage self) internal view returns (uint256) {\n        return self.totalWithdrawnReward;\n    }\n\n    function withdraw(Info storage self, uint256 withdrawEpoch) internal returns (uint256 withdrawAmount) {\n        // mv find closest min vesting to offchain\n        (int256 index) = _findClosest(self, withdrawEpoch);\n\n        if (index < 0) {\n            // no valid vesting found\n            return 0;\n        }\n\n        Item storage item = self.items[uint256(index)];\n        uint256 totalWithdrawnReward = self.totalWithdrawnReward;\n\n        withdrawAmount = item.cumulativeAmount - totalWithdrawnReward;\n        self.totalWithdrawnReward = totalWithdrawnReward + withdrawAmount;\n    }\n\n    function add(\n        Info storage self,\n        bytes32 commitmentId,\n        uint256 reward,\n        uint256 startEpoch,\n        uint256 vestingPeriodDuration,\n        uint256 vestingPeriodCount\n    ) internal {\n        uint256 length = self.items.length;\n        uint256 rewardPerPeriod = reward / vestingPeriodCount;\n\n        // find next epoch divisible by vestingPeriodDuration\n        uint256 startVestingEpoch = (startEpoch + (vestingPeriodDuration - startEpoch % vestingPeriodDuration));\n        int256 index = _findClosest(self, startVestingEpoch);\n\n        // if startVestingEpoch is lower than all epochs in self.items, then it will be added to the back of the array,\n        // making self.items[i] non-monotonous\n        if (index == -1 && length != 0) {\n            revert(\"Vesting: startEpoch is below than all seen epochs\");\n        }\n\n        uint256 prevCumulativeAmount = 0;\n        // if startVestingEpoch is larger than any epoch in items, we need to skip this item\n        if (index >= 0 && self.items[uint256(index)].epoch < startVestingEpoch) {\n            prevCumulativeAmount = self.items[uint256(index)].cumulativeAmount;\n            index++;\n        }\n\n        for (uint256 i = 0; i < vestingPeriodCount; i++) {\n            uint256 cumulativeAmountIncrease = rewardPerPeriod * (i + 1);\n            if (index >= 0 && index < int256(length)) {\n                // update item\n                Item storage item = self.items[uint256(index)];\n                prevCumulativeAmount = item.cumulativeAmount; // Do NOT add rewardPerPeriod * (i + 1) here, it will break logic\n                item.cumulativeAmount = prevCumulativeAmount + cumulativeAmountIncrease;\n\n                emit VestingUpdateItem(commitmentId, uint256(index), prevCumulativeAmount + cumulativeAmountIncrease);\n\n                index++;\n            } else {\n                // create item\n                uint256 epoch = startVestingEpoch + (vestingPeriodDuration * i);\n                self.items.push(\n                    Item({\n                        epoch: epoch,\n                        cumulativeAmount: prevCumulativeAmount + cumulativeAmountIncrease\n                    })\n                );\n\n                emit VestingScheduleItem(commitmentId, self.items.length - 1, epoch, prevCumulativeAmount + cumulativeAmountIncrease);\n            }\n        }\n    }\n\n    // Returns:\n    // if exists, highest index such that self.items[index].epoch <= withdrawEpoch\n    // -1 otherwise\n    function _findClosest(Info storage self, uint256 withdrawEpoch) private view returns (int256 index) {\n        uint256 length = self.items.length;\n        index = -1;\n\n        if (length == 0) {\n            return index;\n        }\n\n        uint256 low = 0;\n        uint256 high = length - 1;\n\n        while (low <= high) {\n            uint256 mid = (low + high) / 2;\n\n            Item storage item = self.items[mid];\n            uint256 itemEpoch = item.epoch;\n\n            if (withdrawEpoch > itemEpoch) {\n                index = int256(mid);\n                low = mid + 1;\n            } else if (withdrawEpoch < itemEpoch) {\n                if (mid == 0) {\n                    return -1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                return int256(mid);\n            }\n        }\n    }\n}\n"},"src/core/interfaces/IBaseOffer.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {CIDV1} from \"src/utils/Common.sol\";\n\n/// @title Offer contract interface\n/// @dev Offer contract is responsible for managing the offers in the market\ninterface IBaseOffer {\n    struct BaseOffer {\n        address provider;\n        address paymentToken;\n        uint256 peerCount;\n        uint256 minProtocolVersion;\n        uint256 maxProtocolVersion;\n    }\n\n    struct ProviderInfo {\n        string name;\n        CIDV1 metadata;\n        uint256 unitCount;\n    }\n\n    struct ComputePeer {\n        bytes32 offerId;\n        bytes32 commitmentId;\n        uint256 unitCount;\n        address owner;\n    }\n\n    struct ComputeUnit {\n        address deal;\n        bytes32 peerId;\n        uint256 startEpoch;\n        bytes32 onchainWorkerId;\n    }\n\n    struct ComputeUnitView {\n        bytes32 id;\n        address deal;\n        uint256 startEpoch;\n        bytes32 onchainWorkerId;\n    }\n\n    // ------------------ Events ------------------\n    /// @dev Emitted when a provider info is updated\n    /// @param provider The provider address\n    /// @param name The new name of the provider\n    /// @param metadata The new metadata of the provider\n    event ProviderInfoUpdated(address indexed provider, string name, CIDV1 metadata);\n\n    /// @dev Emitted when a new offer is registered\n    /// @param provider The provider address\n    /// @param offerId The offer id\n    /// @param minPricePerCuPerEpoch The min price per cu per epoch which the provider specify for the matching with the deal\n    /// @param paymentToken The payment token of the offer\n    /// @param effectors The effectors of the offer\n    event MarketOfferRegistered(\n        address indexed provider,\n        bytes32 offerId,\n        uint256 minPricePerCuPerEpoch,\n        address paymentToken,\n        CIDV1[] effectors,\n        uint256 minProtocolVersion,\n        uint256 maxProtocolVersion\n    );\n\n    /// @dev Emitted when an offer removed\n    /// @param offerId The offer i\n    event MarketOfferRemoved(bytes32 indexed offerId);\n\n    /// @dev Emitted when a peer created for an offer\n    event PeerCreated(bytes32 indexed offerId, bytes32 peerId, address owner);\n\n    /// @dev Emitted when a peer removed from an offer\n    /// @param offerId The offer id\n    /// @param peerId The peer id\n    event PeerRemoved(bytes32 indexed offerId, bytes32 indexed peerId);\n\n    /// @dev Emitted when a compute unit created for a peer\n    /// @param peerId The peer id\n    /// @param unitId The compute unit id\n    event ComputeUnitCreated(bytes32 indexed peerId, bytes32 unitId);\n\n    /// @dev Emitted when a compute unit removed from a peer\n    /// @param peerId The peer id\n    /// @param unitId The compute unit id\n    event ComputeUnitRemoved(bytes32 indexed peerId, bytes32 indexed unitId);\n\n    /// @dev Emitted when the payment token of an offer is updated\n    /// @param offerId The offer id\n    /// @param paymentToken The new payment token\n    event PaymentTokenUpdated(bytes32 indexed offerId, address paymentToken);\n\n    /// @dev Emitted when protocol version of an offer is updated\n    /// @param offerId The offer id\n    /// @param minProtocolVersion The new minimum supported protocol version\n    /// @param maxProtocolVersion The new maximum supported protocol version\n    event ProtocolVersionUpgraded(bytes32 indexed offerId, uint256 minProtocolVersion, uint256 maxProtocolVersion);\n\n\n    // ----------------- Public View -----------------\n    /// @dev Returns the provider info\n    /// @param provider The provider address\n    /// @return providerInfo The provider info\n    function getProviderInfo(address provider) external view returns (ProviderInfo memory);\n\n\n    /// @dev Returns the offer info\n    /// @param offerId The offer id\n    /// @return offer The offer info\n    function getBaseOffer(bytes32 offerId) external view returns (BaseOffer memory);\n\n    /// @dev Returns the compute peer info\n    function getComputePeer(bytes32 peerId) external view returns (ComputePeer memory);\n\n    /// @dev Returns the compute unit info\n    function getComputeUnit(bytes32 unitId) external view returns (ComputeUnit memory);\n\n    /// @dev Returns the compute unit ids of a peer\n    function getComputeUnitIds(bytes32 peerId) external view returns (bytes32[] memory);\n\n    /// @dev Returns the compute units info of a peer\n    function getComputeUnits(bytes32 peerId) external view returns (ComputeUnitView[] memory);\n\n    // ----------------- Public Mutable -----------------\n    function changePaymentToken(bytes32 offerId, address newPaymentToken) external;\n\n    /// @dev Set the provider info\n    /// @param name The name of the provider\n    /// @param metadata The metadata of the provider\n    function setProviderInfo(string calldata name, CIDV1 calldata metadata) external;\n}\n"},"src/core/interfaces/ICapacity.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {Vesting} from \"src/core/Vesting.sol\";\nimport {DealStakerRewards} from \"src/core/DealStakerRewards.sol\";\n\n/// @title Capacity contract interface\n/// @dev Capacity contract is responsible for managing the commitments\ninterface ICapacity {\n    // ------------------ Events ------------------\n\n    /// @dev Emitted when a new commitment is created\n    /// @param peerId Peer id which linked to the commitment\n    /// @param commitmentId Commitment id\n    /// @param duration The duration of the commitment in Epochs\n    /// @param delegator The delegator address. If address is zero, the commitment has no delegator\n    /// @param rewardDelegationRate The reward delegation rate in precision\n    /// @param fltCollateralPerUnit The flt collateral per compute unit\n    event CommitmentCreated(\n        bytes32 indexed peerId,\n        bytes32 commitmentId,\n        uint256 duration,\n        address delegator,\n        uint256 rewardDelegationRate,\n        uint256 fltCollateralPerUnit\n    );\n\n    /// @dev Emitted when a commitment is removed. Commitment can be removed only if it is in WaitDelegation status\n    /// @param commitmentId Commitment id\n    event CommitmentRemoved(bytes32 indexed commitmentId);\n\n    /// @dev Emitted when a commitment is activated. Commitment can be activated only if delegator deposited collateral.\n    /// @param peerId Peer id which linked to the commitment\n    /// @param commitmentId Commitment id which activated\n    /// @param startEpoch The start epoch of the commitment\n    /// @param endEpoch The end epoch of the commitment\n    /// @param unitIds Compute unit ids which linked to the commitment\n    event CommitmentActivated(\n        bytes32 indexed peerId, bytes32 indexed commitmentId, uint256 startEpoch, uint256 endEpoch, bytes32[] unitIds\n    );\n\n    /// @dev Emitted when a commitment is finished. Commitment can be finished only if it is in Failed or Ended\n    /// @param commitmentId Commitment id which finished\n    event CommitmentFinished(bytes32 indexed commitmentId);\n\n    /// @dev Emitted when a delegator deposited collateral to commitment\n    /// @param commitmentId Commitment id\n    /// @param totalCollateral The total collateral deposited to commitment\n    event CollateralDeposited(bytes32 indexed commitmentId, address indexed stakerAddress, uint256 totalCollateral);\n\n    /// @dev Emitted when a someone withdraws deposited collateral from commitment\n    /// @param commitmentId Commitment id\n    /// @param amountWithdrawn The returned part of the collateral after slashing\n    /// @param amountSlashed The slashed part of the collateral\n    event CollateralWithdrawn(bytes32 commitmentId, uint256 amountWithdrawn, uint256 amountSlashed);\n\n    event CommitmentFailed(bytes32 indexed commitmentId, uint256 failedEpoch);\n\n    /// @dev Emitted when a proof is submitted\n    /// @param commitmentId Commitment id\n    /// @param unitId Compute unit id which linked to the proof\n    /// @param localUnitNonce The local nonce of the unit for calculating the target hash\n    event ProofSubmitted(bytes32 indexed commitmentId, bytes32 indexed unitId, bytes32 localUnitNonce);\n\n    /// @dev Emitted when a reward is withdrawn\n    /// @param commitmentId Commitment id\n    /// @param providerReward The amount withdrawn for provider\n    /// @param dealStakerRewardsAmount The amount withdrawn for staker (with deal reward)\n    event RewardWithdrawn(bytes32 indexed commitmentId, uint256 providerReward, uint256 dealStakerRewardsAmount);\n\n    /// @dev Emitted when a unit deactivated. Unit is deactivated when it moved to deal\n    /// @param commitmentId Commitment id\n    /// @param unitId Compute unit id which deactivated\n    event UnitDeactivated(bytes32 indexed commitmentId, bytes32 indexed unitId);\n\n    /// @dev Emitted when a unit activated. Unit is activated when it returned from deal\n    /// @param commitmentId Commitment id\n    /// @param unitId Compute unit id which activated\n    event UnitActivated(bytes32 indexed commitmentId, bytes32 indexed unitId, uint256 startEpoch);\n\n    /// @dev Emitted in proof submission\n    /// @param unitIds Compute unit ids\n    /// @param confirmed Confirmation status of the proofs\n    event ProofsConfirmed(bytes32 indexed peerId, bytes32[] unitIds, bool[] confirmed);\n\n    // To fetch updates on changes in CC stats (currently only in stats related to CUs).\n    event CommitmentStatsUpdated(\n        bytes32 commitmentId,\n        uint256 totalFailCount,\n        uint256 exitedUnitCount,\n        uint256 activeUnitCount,\n        uint256 nextAdditionalActiveUnitCount,\n        // Aka Snapshot epoch but in order to not mislead with actual snapshotting, it renamed to changedEpoch.\n        uint256 changedEpoch\n    );\n\n    // ------------------ Errors ------------------\n    /// @dev Capacity commitment is not active\n    error CapacityCommitmentIsNotActive(CCStatus status);\n\n    /// @dev Invalid CC status\n    error InvalidCCStatus(CCStatus status);\n\n    // ------------------ Types ------------------\n    enum CCStatus {\n        Inactive,\n        Active,\n        // WaitDelegation - before collateral is deposited.\n        WaitDelegation,\n        // Status is WaitStart - means collateral deposited, and epoch should be proceed before Active.\n        WaitStart,\n        Failed,\n        Removed\n    }\n\n    struct UnitInfo {\n        bool isInactive;\n        uint256 lastSnapshotEpoch;\n        uint256 slashedCollateral;\n        mapping(uint256 => uint256) proofCountByEpoch;\n    }\n\n    struct Commitment {\n        CommitmentInfo info;\n        CommitmentProgress progress;\n        CommitmentFinish finish;\n        Vesting.Info vesting;\n        mapping(bytes32 => UnitInfo) unitInfoById;\n        mapping(bytes32 => bool) isUnitExited;\n        DealStakerRewards.Info dealRewards;\n    }\n\n    struct CommitmentInfo {\n        CCStatus status;\n        bytes32 peerId;\n        uint256 collateralPerUnit;\n        uint256 duration;\n        uint256 rewardDelegatorRate;\n        address delegator;\n        uint256 startEpoch;\n    }\n\n    struct CommitmentFinish {\n        uint256 failedEpoch;\n        uint256 exitedUnitCount;\n        uint256 totalSlashedCollateral;\n        bool collateralWithdrawn;\n    }\n\n    struct CommitmentProgress {\n        uint256 currentSuccessCount;\n        uint256 totalFailCount;\n        uint256 snapshotEpoch;\n        uint256 activeUnitCount;\n        uint256 nextAdditionalActiveUnitCount;\n    }\n\n    struct CommitmentView {\n        CCStatus status;\n        bytes32 peerId;\n        uint256 collateralPerUnit;\n        uint256 unitCount;\n        uint256 startEpoch;\n        uint256 endEpoch;\n        uint256 rewardDelegatorRate;\n        address delegator;\n        uint256 totalFailCount;\n        uint256 failedEpoch;\n        uint256 exitedUnitCount;\n    }\n\n    struct RewardInfo {\n        uint256 minProofsPerEpoch;\n        uint256 maxProofsPerEpoch;\n        uint256 totalSuccessProofs;\n    }\n\n    struct CCRewardsView {\n        uint256 ccRewards;\n        uint256 dealStakerRewards;\n    }\n\n    // ------------------ Views ------------------\n    /// @dev Returns the commitment status\n    /// @param commitmentId Commitment id\n    /// @return status commitment status\n    function getStatus(bytes32 commitmentId) external view returns (CCStatus);\n\n    /// @dev Returns the commitment info\n    /// @param commitmentId Commitment id\n    /// @return info commitment info\n    function getCommitment(bytes32 commitmentId) external view returns (CommitmentView memory);\n\n    /// @dev Returns the total rewards of the commitment.\n    /// @param commitmentId Commitment id\n    /// @return CCRewardsView Returns the total rewards of the commitment minus withdrawn rewards.\n    function totalRewards(bytes32 commitmentId) external view returns (CCRewardsView memory);\n\n    /// @dev Returns the unlocked rewards of the commitment\n    /// @param commitmentId Commitment id\n    /// @return CCRewardsView the unlocked rewards of the commitment minus withdrawn rewards.\n    function unlockedRewards(bytes32 commitmentId) external view returns (CCRewardsView memory);\n\n    /// @dev Returns rewards withdrawn from the commitment\n    /// @param commitmentId Commitment id\n    /// @return CCRewardsView rewards withdrawn from the commitment\n    function withdrawnRewards(bytes32 commitmentId) external view returns (CCRewardsView memory);\n\n    function getGlobalNonce() external view returns (bytes32);\n\n    /// @dev Returns proof counts for each CU in current epoch\n    /// @param commitmentId Commitment id\n    /// @return unitIds unit ids\n    /// @return counts proof numbers sent in current epoch\n    function getProofCounts(bytes32 commitmentId)\n        external\n        view\n        returns (bytes32[] memory unitIds, uint256[] memory counts);\n\n    /// @dev Returns list of units wth exited units marked\n    /// @param commitmentId Commitment id\n    /// @return unitIds unit ids\n    /// @return isExited if unit has exited the cc via removeCUFromCC function\n    function getUnitExitStatuses(bytes32 commitmentId)\n        external\n        view\n        returns (bytes32[] memory unitIds, bool[] memory isExited);\n\n    /// @dev Returns balance of the reward pool\n    function getRewardBalance() external view returns (uint256);\n\n    // ----------------- Mutable -----------------\n    /// @dev Creates a new commitment\n    /// @param peerId Peer id which linked to the commitment\n    /// @param duration The duration of the commitment in Epochs\n    /// @param delegator The delegator address. If address is zero, the commitment has no delegator\n    /// @param rewardDelegationRate The reward delegation rate in precision\n    function createCommitment(bytes32 peerId, uint256 duration, address delegator, uint256 rewardDelegationRate)\n        external\n        returns (bytes32);\n\n    /// @dev Removes the commitment if it is in WaitDelegation status\n    /// @param commitmentId Commitment id\n    function removeCommitment(bytes32 commitmentId) external;\n\n    /// @dev Finishes the commitment if it is in Failed or Ended status\n    /// @param commitmentId Commitment id\n    function finishCommitment(bytes32 commitmentId) external;\n\n    /// @dev Deposits collateral for commitments. It makes commitments active\n    /// @dev Note: this method consists of indirect potential delegator address update\n    /// @dev  (set delegator to msg.sender if 0x0 before).\n    /// @param commitmentIds Commitment ids\n    function depositCollateral(bytes32[] calldata commitmentIds) external payable;\n\n    /// @dev Submits proofs for the commitment\n    /// @param unitIds Compute unit ids which provide the proof\n    /// @param localUnitNonces Local nonces of the units for calculating the target hashes. It's the proof\n    /// @param resultHashes Target hashes of this proof\n    function submitProofs(bytes32[] memory unitIds, bytes32[] memory localUnitNonces, bytes32[] memory resultHashes)\n        external;\n\n    /// @dev Submits a proof for the commitment\n    /// @param unitId Compute unit id which provide the proof\n    /// @param localUnitNonce Local nonce of the unit for calculating the target hash. It's the proof\n    /// @param resultHash Target hash of this proof\n    function submitProof(bytes32 unitId, bytes32 localUnitNonce, bytes32 resultHash) external;\n\n    // @dev Returns number of submitted proofs along with min and max required number of proofs\n    // @param epoch\n    // @return reward info for given epoch\n    function getRewardInfo(uint256 epoch) external view returns (RewardInfo memory);\n\n    /// @dev Remove CU from Ended or Failed CC. Need to call this function before finish the commitment\n    /// @param commitmentId Commitment id\n    /// @param unitIds Compute unit ids which will be removed from the commitment\n    function removeCUFromCC(bytes32 commitmentId, bytes32[] calldata unitIds) external;\n\n    /// @dev Withdraws the reward from the commitment\n    /// @param commitmentId Commitment id\n    function withdrawReward(bytes32 commitmentId) external;\n\n    /// @dev Withdraws the collateral from the commitment. Commitment must be Failed or Inactive.\n    /// @param commitmentId Commitment id\n    function withdrawCollateral(bytes32 commitmentId) external;\n\n    /// @dev to add reward balance by msg.value\n    function diamondReceive() external payable;\n}\n"},"src/core/interfaces/ICapacityConst.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IEpochController} from \"src/core/interfaces/IEpochController.sol\";\n\n\n/// @title Capacity constants contract interface\n/// @dev The constants contract is responsible for managing the constants for the capacity commitment\ninterface ICapacityConst is IEpochController {\n    // ------------------ Events ------------------\n    /// @dev Emitted when a constant with a uint256 value is updated\n    /// @param constantType The type of the constant\n    /// @param newValue The new value of the constant\n    event CapacityConstantUpdated(CapacityConstantType constantType, uint256 newValue);\n\n    /// @dev Emitted when new oracle address is set\n    /// @param oracle The oracle address\n    event OracleSet(address oracle);\n\n    /// @dev Emitted when the FLT price is updated\n    /// @param newValue The new value of the FLT price\n    event FLTPriceUpdated(uint256 newValue);\n\n    /// @dev Emitted when the difficulty is updated\n    /// @param difficulty The new value of the difficulty\n    event DifficultyUpdated(bytes32 difficulty);\n\n    // ------------------ Types ------------------\n    enum CapacityConstantType {\n        MinDuration,\n        MaxDuration,\n        MinCUPerCommitment,\n        MaxCUPerCommitment,\n        USDCollateralPerUnit,\n        SlashingRate,\n        WithdrawEpochsAfterFailed,\n        MaxFailedRatio,\n        USDTargetRevenuePerEpoch,\n        MinRewardPerEpoch,\n        MaxRewardPerEpoch,\n        MinProofsPerEpoch,\n        MaxProofsPerEpoch\n    }\n\n    struct CapacityConstInitArgs {\n        uint256 fltPrice;\n        uint256 fltPriceUpdatePeriod;\n        uint256 usdCollateralPerUnit;\n        uint256 usdTargetRevenuePerEpoch;\n        uint256 minDuration;\n        uint256 maxDuration;\n        uint256 minCUPerCommitment;\n        uint256 maxCUPerCommitment;\n        uint256 minRewardPerEpoch;\n        uint256 maxRewardPerEpoch;\n        uint256 vestingPeriodDuration;\n        uint256 vestingPeriodCount;\n        uint256 slashingRate;\n        uint256 minProofsPerEpoch;\n        uint256 maxProofsPerEpoch;\n        uint256 withdrawEpochsAfterFailed;\n        uint256 maxFailedRatio;\n        bytes32 difficulty;\n        uint256 initRewardPool;\n        address randomXProxy;\n        address oracle;\n        address payable wfltAddress;\n    }\n\n    // #region ------------------ External View Functions ------------------\n    /// @dev Returns the last set flt price in usd/flt\n    function fltPrice() external view returns (uint256);\n\n    // #region ------------------ External View Functions ------------------\n    /// @dev Returns the flt price at the end of the epoch previous to given one.\n    /// @dev It means that this function will always return the same result for the same arguments.\n    /// @dev Epoch must be less or equal than current epoch.\n    /// @param epoch - epoch where\n    /// @return price in flt/usd\n    function fltPriceAtEpoch(uint256 epoch) external view returns (uint256);\n\n    /// @dev Returns the flt collateral per compute unit for creating CC\n    function fltCollateralPerUnit() external view returns (uint256);\n\n    /// @dev Returns the usd collateral per compute for creating CC\n    function usdCollateralPerUnit() external view returns (uint256);\n\n    /// @dev Returns the target revenue in usd value per epoch\n    function usdTargetRevenuePerEpoch() external view returns (uint256);\n\n    /// @dev Returns the min duration of CC in Epochs\n    function minDuration() external view returns (uint256);\n\n    /// @dev Returns the max duration of CC in Epochs\n    function maxDuration() external view returns (uint256);\n\n    /// @dev Returns the min number of CU in CC\n    function minCUPerCommitment() external view returns (uint256);\n\n    /// @dev Returns the max number of CU in CC\n    function maxCUPerCommitment() external view returns (uint256);\n\n    /// @dev Returns the min reward pool per epoch\n    function minRewardPerEpoch() external view returns (uint256);\n\n    /// @dev Returns the max reward pool per epoch\n    function maxRewardPerEpoch() external view returns (uint256);\n\n    /// @dev Returns the vesting duration for one period in Epochs\n    function vestingPeriodDuration() external view returns (uint256);\n\n    /// @dev Returns the total vesting periods\n    function vestingPeriodCount() external view returns (uint256);\n\n    /// @dev Returns the slashing rate for failed CU\n    function slashingRate() external view returns (uint256);\n\n    /// @dev Returns the min required randomX proofs per epoch for the 1 CU.\n    /// @dev  If lower than this - CU is failed and CC slashed.\n    function minProofsPerEpoch() external view returns (uint256);\n\n    /// @dev Returns the max randomX proofs per epoch\n    function maxProofsPerEpoch() external view returns (uint256);\n\n    /// @dev Returns the delay for withdraw collateral in Epochs after failed CC\n    function withdrawEpochsAfterFailed() external view returns (uint256);\n\n    /// @dev Returns the max failed ratio for CC\n    function maxFailedRatio() external view returns (uint256);\n\n    /// @dev Returns the active compute unit count\n    function activeUnitCount() external view returns (uint256);\n\n    /// @dev Returns the difficulty for randomX\n    function difficulty() external view returns (bytes32);\n\n    /// @dev Returns the randomX proxy address for verification of randomX proofs\n    function randomXProxy() external view returns (address);\n\n    /// @dev Returns the oracle address\n    function oracle() external view returns (address);\n\n    /// @dev Returns the reward pool per epoch\n    function getRewardPool(uint256 epoch) external view returns (uint256);\n    // #endregion ------------------ External View Functions ------------------\n\n    // #region ------------------ External Mutable Functions ------------------\n    /// @dev Sets the flt price\n    function setFLTPrice(uint256 fltPrice_) external;\n\n    /// @dev Sets the randomX difficulty\n    function setDifficulty(bytes32 difficulty_) external;\n\n    /// @dev Sets a constant with a uint256 value\n    function setCapacityConstant(CapacityConstantType constantType, uint256 v) external;\n\n    /// @dev Sets a new oracle\n    function setOracle(address oracle_) external;\n\n    /// @dev Gets last set flt price in usd/flt and timestamp of the last stored price\n    // Needed for oracle to understand if it should update the price\n    function lastPriceSetting() external view returns (uint256 timestamp, uint256 price);\n}\n"},"src/core/interfaces/ICore.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IDeal} from \"src/deal/v1/interfaces/IDeal.sol\";\nimport {IDealV2} from \"src/deal/interfaces/IDeal.sol\";\nimport {IGlobalConst} from \"src/core/interfaces/IGlobalConst.sol\";\nimport {IWhitelist} from \"src/interfaces/IWhitelist.sol\";\n\n/// @title Core contract interface\n/// @dev Core contract is the main contract of the system and it is responsible for navigation between modules\ninterface ICore is IWhitelist, IGlobalConst {\n    event DealImplSet(IDeal dealImpl);\n    event DealV2ImplSet(IDealV2 dealImpl);\n\n    function dealImpl() external view returns (IDeal);\n    function dealV2Impl() external view returns (IDealV2);\n    function setDealImpl(IDeal dealImpl_) external;\n    function setDealV2Impl(IDealV2 dealImpl_) external;\n}\n"},"src/core/interfaces/IDealFactory.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IDeal} from \"src/deal/v1/interfaces/IDeal.sol\";\nimport {IDealV2} from \"src/deal/interfaces/IDeal.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\nimport {IConfig} from \"src/deal/v1/interfaces/IConfig.sol\";\nimport {IConfigV2} from \"src/deal/interfaces/IConfig.sol\";\nimport {IOfferV2} from \"src/core/interfaces/IOfferV2.sol\";\nimport {IBalanceKeeper} from \"src/balance-keeper/IBalanceKeeper.sol\";\n\n/// @title Deal factory contract interface\n/// @dev Deal factory contract is responsible for creating deals\ninterface IDealFactory {\n    // ----------------- Events -----------------\n    /// @dev Emitted when a new deal is created\n    /// @param owner The owner of the deal\n    /// @param deal The deal address\n    /// @param createdAtEpoch The creation time of the deal in Epochs\n    /// @param paymentToken The payment token of the deal. User can choose any ERC20 token for payment\n    /// @param minWorkers The min workers of the deal. Deel will be activated only if the number of workers is greater\n    /// @param targetWorkers The target workers of the deal. It's the max number of workers for the deal\n    /// @param cuCountPerWorker CU count per worker\n    /// @param maxWorkersPerProvider The max workers per provider of the deal\n    /// @param pricePerCuPerEpoch The price per CU per epoch of the deal\n    /// @param effectors The effectors of the deal\n    /// @param appCID The app cid of the deal\n    /// @param providersAccessType_ The providers access type of the deal (None, Whitelist, Blacklist)\n    /// @param providersAccessList_ The providers access list of the deal\n    /// @param protocolVersion_ Protocol version\n    event DealCreated(\n        address indexed owner,\n        IDeal deal,\n        uint256 createdAtEpoch,\n        IERC20 paymentToken,\n        uint256 minWorkers,\n        uint256 targetWorkers,\n        uint256 cuCountPerWorker,\n        uint256 maxWorkersPerProvider,\n        uint256 pricePerCuPerEpoch,\n        CIDV1[] effectors,\n        CIDV1 appCID,\n        IConfig.AccessType providersAccessType_,\n        address[] providersAccessList_,\n        uint256 protocolVersion_\n    );\n\n    event DealCreatedV2(\n        address indexed owner,\n        IDealV2 deal,\n        uint256 createdAtEpoch,\n        IERC20 paymentToken,\n        uint256 targetWorkers,\n        IOfferV2.ResourceRequirement[] resources,\n        uint256 pricePerEpoch,\n        uint256 maxWorkersPerProvider,\n        CIDV1 appCID,\n        IConfigV2.AccessTypeV2 providersAccessType_,\n        address[] providersAccessList_,\n        uint256 protocolVersion_\n    );\n\n    event DealStopped(address indexed owner, address indexed deal, uint256 endedEpoch);\n    event DealStoppedV2(address indexed owner, address indexed deal, uint256 endedEpoch);\n\n    event DealFunded(address indexed owner, address indexed deal, uint256 amount, uint256 newMaxPaidEpoch);\n    event DealFundedV2(address indexed owner, address indexed deal, uint256 amount, uint256 newMaxPaidEpoch);\n\n    event VodopadSet(address indexed vodopad, address initiator);\n\n    // ----------------- View -----------------\n    /// @dev Returns true if the deal exists\n    /// @param deal The deal address\n    function hasDeal(address deal) external view returns (bool);\n\n    // ----------------- Mutable -----------------\n    /// @dev Creates a new deal\n    /// @param appCID_ The app cid of the deal\n    /// @param paymentToken_ The payment token of the deal. User can choose any ERC20 token for payment\n    /// @param depositAmount_ The deposit amount of the deal\n    /// @param minWorkers_ The min workers of the deal. Deel will be activated only if the number of workers is greater\n    /// @param targetWorkers_ The target workers of the deal. It's the max number of workers for the deal\n    /// @param maxWorkersPerProvider_ The max workers per provider of the deal\n    /// @param pricePerCuPerEpoch_ The price per CU per epoch of the deal\n    /// @param effectors_ The effectors of the deal\n    /// @param providersAccessType_ The providers access type of the deal (None, Whitelist, Blacklist)\n    /// @param providersAccessList_ The providers access list of the deal\n    /// @param protocolVersion_ Protocol version\n    /// @return The deal address\n    function deployDeal(\n        CIDV1 calldata appCID_,\n        IERC20 paymentToken_,\n        uint256 depositAmount_,\n        uint256 minWorkers_,\n        uint256 targetWorkers_,\n        uint256 cuCountPerWorker_,\n        uint256 maxWorkersPerProvider_,\n        uint256 pricePerCuPerEpoch_,\n        CIDV1[] calldata effectors_,\n        IConfig.AccessType providersAccessType_,\n        address[] calldata providersAccessList_,\n        uint256 protocolVersion_,\n        address owner_\n    ) external returns (IDeal);\n\n    /// @dev Creates a new deal v2\n    function deployDealV2(\n        CIDV1 calldata appCID_,\n        IERC20 paymentToken_,\n        uint256 depositAmount_,\n        uint256 targetWorkers_,\n        IOfferV2.ResourceRequirement[] calldata resources_,\n        uint256 pricePerEpoch_,\n        uint256 maxWorkersPerProvider_,\n        IConfigV2.AccessTypeV2 providersAccessType_,\n        address[] calldata providersAccessList_,\n        uint256 protocolVersion_,\n        address owner_\n    ) external returns (IDealV2);\n\n    // ----------------- Mutable -----------------\n    // TODO move to market contract\n    function fundDeal(IDeal deal, uint256 targetMaxPaidEpoch) external;\n    function fundDealV2(IDealV2 deal, uint256 targetMaxPaidEpoch) external;\n    function setBalanceKeeper(IBalanceKeeper balanceKeeper) external;\n    function balanceKeeper() external view returns (IBalanceKeeper);\n    function setVodopad(address vodopad) external;\n    function vodopad() external view returns (address);\n    function stopDealHandler() external;\n    function stopDealHandlerV2() external;\n    function storedDealCount() external returns (uint256);\n    function storedDeals(uint256 from, uint256 to) external returns (address[] memory);\n}\n"},"src/core/interfaces/IEpochController.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\n/// @title Epoch controller contract interface\n/// @dev Epoch controller contract is responsible for changing epochs\ninterface IEpochController {\n    /// @dev Returns current epoch\n    /// @return current epoch number\n    function currentEpoch() external view returns (uint256);\n\n    /// @dev Returns epoch duration\n    /// @return epochDuration in seconds\n    function epochDuration() external view returns (uint256);\n\n    /// @dev Returns epoch init timestamp\n    /// @return initTimestamp in seconds\n    function initTimestamp() external view returns (uint256);\n\n    /// @dev Returns timestamp of the given epoch\n    /// @return start epoch timestamp in seconds\n    function epochTimestamp(uint256 epoch) external view returns (uint256);\n}\n"},"src/core/interfaces/IGlobalConst.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\n\nimport {ICapacityConst} from \"src/core/interfaces/ICapacityConst.sol\";\n\n/// @title Global Constants contract interface\n/// @dev Global Constants contract stores global constants of the system and it is responsible for changing them\ninterface IGlobalConst is ICapacityConst {\n    // ------------------ Events ------------------\n    /// @dev Emitted when a constant with uint256 value is updated\n    /// @param constantType Constant type\n    /// @param newValue New uint256 value\n    event ConstantUpdated(ConstantType constantType, uint256 newValue);\n\n    event PaymentTokenAddedToWhitelist(address indexed paymentToken);\n\n    event PaymentTokenRemovedFromWhitelist(address indexed paymentToken);\n\n    // ------------------ Types ------------------\n    enum ConstantType {\n        MinDealDepositedEpochs,\n        MinDealRematchingEpochs,\n        MinProtocolVersion,\n        MaxProtocolVersion,\n        MaxUnitCountPerProvider\n    }\n\n    struct Constants1 {\n        uint256 fltPrice;\n        uint256 fltCollateralPerUnit;\n        uint256 usdCollateralPerUnit;\n        uint256 usdTargetRevenuePerEpoch;\n        uint256 minDuration;\n        uint256 maxDuration;\n        uint256 minRewardPerEpoch;\n        uint256 maxRewardPerEpoch;\n        uint256 vestingPeriodDuration;\n        uint256 vestingPeriodCount;\n        uint256 slashingRate;\n        uint256 minProofsPerEpoch;\n        uint256 maxProofsPerEpoch;\n        uint256 withdrawEpochsAfterFailed;\n        uint256 maxFailedRatio;\n    }\n\n    struct Constants2 {\n        uint256 epochDuration;\n        uint256 minDealRematchingEpoch;\n        uint256 minDealDepositedEpoch;\n        uint256 minCUPerCommitment;\n        uint256 maxCUPerCommitment;\n        uint256 precision;\n        uint256 initTimestamp;\n        bytes32 difficulty;\n    }\n\n    struct GlobalConstants {\n        Constants1 constants1;\n        Constants2 constants2;\n    }\n\n    // ------------------ External Constants ------------------\n    /// @dev Returns precision for decimal values (USD, percentage)\n    function precision() external view returns (uint256);\n\n    // ------------------ External View Functions ------------------\n\n    /// @dev Returns min deposited Epochs constant for new deals\n    /// @return min deposited Epochs for new deals\n    function minDealDepositedEpochs() external view returns (uint256);\n\n    /// @dev Returns min rematching Epochs constant for all deals\n    /// @return min rematching Epochs for all deals\n    function minDealRematchingEpochs() external view returns (uint256);\n\n    /// @dev Returns min protocol version which can be specified in offers and deals\n    /// @return min protocol version\n    function minProtocolVersion() external view returns (uint256);\n\n    /// @dev Returns max protocol version which can be specified in offers and deals\n    /// @return max protocol version\n    function maxProtocolVersion() external view returns (uint256);\n\n    /// @dev Returns max unit count allowed for single provider to have in all offers combined\n    /// @return max unit count per provider\n    function maxUnitCountPerProvider() external view returns (uint256);\n\n    /// @dev Adds payment token address to whitelist\n    function addPaymentTokenToWhitelist(address paymentToken) external;\n\n    /// @dev Removes payment token address from whitelist\n    function removePaymentTokenFromWhitelist(address paymentToken) external;\n\n    /// @dev Checks if address is allowed to use as payment token in deals/offers\n    /// @return true if address is allowed\n    function isPaymentTokenAllowed(address paymentToken) external view returns (bool);\n\n    // ------------------ External Mutable Functions ------------------\n    /// @dev Sets constant with uint256 value\n    /// @param constantType Constant type\n    /// @param v New uint256 value\n    function setConstant(ConstantType constantType, uint256 v) external;\n\n    /// @dev Returns all chain constants\n    /// @return all chain constants\n    function getAllConstants() external view returns (GlobalConstants memory);\n}\n"},"src/core/interfaces/IMarket.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IDeal} from \"src/deal/v1/interfaces/IDeal.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\n\n/// @title Market contract interface\n/// @dev Market contract is responsible for managing the deals and offers\ninterface IMarket {\n    // ------------------ Errors ------------------\n    /// @dev Throws if the min workers of the deal is not matched\n    /// @param _minWorkers The min workers of the deal\n    error MinWorkersNotMatched(uint256 _minWorkers);\n\n    // ----------------- Events -----------------\n    /// @dev Emitted when a deal is matched with a compute unit\n    /// @param peerId The peer id of the deal\n    /// @param deal The deal address\n    /// @param onchainWorkerId onchain worker id, for use in tools that interact with chain\n    /// @param cuIds ids of compute units matched\n    /// @param appCID The app cid of the deal\n    event ComputeUnitsMatched(\n        bytes32 indexed peerId,\n        IDeal deal,\n        bytes32 onchainWorkerId,\n        bytes32[] cuIds,\n        CIDV1 appCID\n    );\n\n    /// @dev Emitted when a compute unit removed from a peer\n    /// @param cuIds The list of compute unit ids\n    /// @param deal The deal address\n    /// @param peerId The peer id\n    event ComputeUnitsRemovedFromDeal(bytes32 indexed peerId, IDeal indexed deal, bytes32[] cuIds, bytes32 onchainWorkerId);\n\n\n    /// @dev Emitted when a worker is activated\n    /// @param peer_id The peer id\n    /// @param deal The deal address\n    /// @param onchain_worker_id The onchain worker id\n    /// @param offchain_worker_id The offchain worker id\n    event WorkerActivated(bytes32 indexed peer_id, IDeal indexed deal, bytes32 onchain_worker_id, bytes32 offchain_worker_id);\n\n\n    /**\n     * @dev Match Deal with Compute Units provided.\n     * @notice Match deal with offers and compute units (peers checks through compute units).\n     * @notice It validates provided CUs and silently ignore unvalidated ones on checking:\n     * @notice - deal.maxWorkersPerProvider and silently ignore other CUs out of this limit.\n     * @notice - Offer, or Peer not allowed to match (deal.isProviderAllowed, allowed prices, paymentToken, effectors)\n     * @notice - Compute Unit (CU): Active CC status, also note, protocol does not allow more than one CU per peer\n     * @notice    for the same Deal. But, when deal consists of whitelisted provider - CUs of this Provider\n     * @notice    could be matched without even CC.\n     * @notice TODO: consolidate workaround: when it comes to check CC status, on wrong status the whole transaction\n     * @notice  will be failed instead of to be silenced.\n     * @dev There should be `bytes32[][] calldata peers` as well, but it is not supported by subgraph codegen.\n     * @dev  Ref to https://github.com/graphprotocol/graph-tooling/issues/342.\n     * @notice This method is mirrored in ts-client/src/dealMatcherClient/dealMatcherClient.ts.\n     * @param deal: Deal to match.\n     * @param offers: Offers array that represents offers in computeUnits 3D array.\n     * @param computeUnits: Compute Units per offer id (3D array: provider -> peer -> CU) to match with.\n     */\n    function matchDeal(IDeal deal, bytes32[] calldata offers, bytes32[][][] calldata computeUnits) external;\n\n    // Unit management\n    /// @dev Return resources from deal\n    function moveResourcesFromDeal(bytes32[] memory unitIds, bytes32 onchainWorkerId) external;\n\n    /// @dev Report that a worker is activated, only throws event\n    /// @param peerId The peer id\n    /// @param onchainWorkerId The onchain worker id\n    /// @param offchainWorkerId The offchain worker id\n    function reportWorkerActivated(bytes32 peerId, bytes32 onchainWorkerId, bytes32 offchainWorkerId) external;\n}\n"},"src/core/interfaces/IMarketV2.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IOfferV2} from \"src/core/interfaces/IOfferV2.sol\";\nimport {IDealV2} from \"src/deal/interfaces/IDeal.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\n\n/// @title Market contract interface\n/// @dev Market contract is responsible for managing the deals and offers\ninterface IMarketV2 {\n\n    // ----------------- Events -----------------\n    /// @dev Emitted when a deal is matched with a compute unit\n    /// @param peerId The peer id of the deal\n    /// @param deal The deal address\n    /// @param onchainWorkerId onchain worker id, for use in tools that interact with chain\n    /// @param cuIds ids of compute units matched\n    /// @param appCID The app cid of the deal\n    struct WorkerResourceAllocation {\n        bytes32 resourceId;\n        IOfferV2.ResourceType ty;\n        string metadata; // metadaa for resource from chain\n        string details; // peer-specific data\n        uint256 quantity;\n    }\n\n    struct WorkerData {\n        address deal;\n        bytes32 peerId;\n        bytes32 offchainWorkerId;\n        uint256[3] reserved; // adding fields to the end breaks compiler, so we add reserved fields for future upgrades\n        bytes32[] unitIds;\n        IMarketV2.WorkerResourceAllocation[] resources;\n    }\n\n    event WorkerCreatedV2(\n        bytes32 indexed peerId,\n        IDealV2 deal,\n        bytes32 onchainWorkerId,\n        bytes32[] cuIds,\n        CIDV1 appCID,\n        WorkerResourceAllocation[] resources\n    );\n\n    event WorkerRemovedV2(\n        bytes32 indexed peerId,\n        IDealV2 deal,\n        bytes32 onchainWorkerId,\n        bytes32[] cuIds,\n        WorkerResourceAllocation[] resources\n    );\n\n    event WorkerActivatedV2(\n        bytes32 indexed peerId,\n        IDealV2 deal,\n        bytes32 onchainWorkerId,\n        bytes32 offchainWorkerId\n    );\n\n    event DealAppCIDChangedV2(\n        IDealV2 indexed deal,\n        CIDV1 newCID\n    );\n\n    /**\n     * @dev Match Deal with Compute Units provided.\n     * @notice Match deal with offers and compute units (peers checks through compute units).\n     * @notice It validates provided CUs and silently ignore unvalidated ones on checking:\n     * @notice - deal.maxWorkersPerProvider and silently ignore other CUs out of this limit.\n     * @notice - Offer, or Peer not allowed to match (deal.isProviderAllowed, allowed prices, paymentToken, effectors)\n     * @notice - Compute Unit (CU): Active CC status, also note, protocol does not allow more than one CU per peer\n     * @notice    for the same Deal. But, when deal consists of whitelisted provider - CUs of this Provider\n     * @notice    could be matched without even CC.\n     * @notice TODO: consolidate workaround: when it comes to check CC status, on wrong status the whole transaction\n     * @notice  will be failed instead of to be silenced.\n     * @dev There should be `bytes32[][] calldata peers` as well, but it is not supported by subgraph codegen.\n     * @dev  Ref to https://github.com/graphprotocol/graph-tooling/issues/342.\n     * @notice This method is mirrored in ts-client/src/dealMatcherClient/dealMatcherClient.ts.\n     * @param deal: Deal to match.\n     * @param peerIds: PeerIds array that represents peers to match with Deal.\n     * @param computeUnitIds: PeerIds array that represents peers to match with Deal.\n     */\n    function matchDealV2(IDealV2 deal, bytes32[] calldata peerIds, bytes32[][] calldata computeUnitIds) external;\n\n    function moveResourcesFromDealV2(bytes32 onchainWorkerId) external;\n\n    function reportWorkerActivatedV2(bytes32 peerId, bytes32 onchainWorkerId, bytes32 offchainWorkerId) external;\n\n    function reportAppCIDUpdatedV2(CIDV1 calldata newAppCID) external;\n\n    function getWorkerData(bytes32 onchainWorkerId) external view returns(WorkerData memory);\n}\n"},"src/core/interfaces/IOffer.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IBaseOffer} from \"src/core/interfaces/IBaseOffer.sol\";\nimport {IDeal} from \"src/deal/v1/interfaces/IDeal.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\n\n/// @title Offer contract interface\n/// @dev Offer contract is responsible for managing the offers in the market\ninterface IOffer is IBaseOffer {\n    struct RegisterComputePeer {\n        bytes32 peerId;\n        address owner;\n        bytes32[] unitIds;\n    }\n\n    struct Offer {\n        address provider;\n        uint256 minPricePerCuPerEpoch;\n        address paymentToken;\n        uint256 peerCount;\n        uint256 minProtocolVersion;\n        uint256 maxProtocolVersion;\n    }\n\n    struct EffectorInfo {\n        string description;\n        CIDV1 metadata;\n    }\n\n    /// @dev Emitted when the min price per worker per epoch of an offer is updated\n    /// @param offerId The offer id\n    /// @param minPricePerCuPerEpoch The new min price per worker per epoch\n    event MinPricePerCuPerEpochUpdated(bytes32 indexed offerId, uint256 minPricePerCuPerEpoch);\n\n    /// @dev Emitted when an effector added to an offer\n    /// @param offerId The offer id\n    /// @param effector The effector cid\n    event EffectorAdded(bytes32 indexed offerId, CIDV1 effector);\n\n    /// @dev Emitted when an effector removed from an offer\n    /// @param offerId The offer id\n    /// @param effector The effector cid\n    event EffectorRemoved(bytes32 indexed offerId, CIDV1 effector);\n\n    /// @dev Emitted when the effector info is set. Effector info can be added by the contract owner\n    /// @param id The effector cid\n    /// @param description The description of the effector\n    /// @param metadata The metadata of the effector\n    event EffectorInfoSet(CIDV1 id, string description, CIDV1 metadata);\n\n    /// @dev Emitted when the effector info is removed\n    /// @param id The effector cid\n    event EffectorInfoRemoved(CIDV1 id);\n\n    /// @dev Returns the offer info\n    /// @param offerId The offer id\n    /// @return offer The offer info\n    function getOffer(bytes32 offerId) external view returns (Offer memory);\n\n    /// @dev Returns the effector info\n    /// @param id The effector cid\n    function getEffectorInfo(CIDV1 calldata id) external view returns (EffectorInfo memory);\n\n    // ----------------- Public Mutable -----------------\n\n    /// @dev Register a new offer\n    /// @param minPricePerCuPerEpoch The min price per CU per epoch which the provider specify for the matching with the deal\n    /// @param paymentToken The payment token of the offer\n    /// @param effectors The effectors of the offer\n    /// @param peers The compute peers of the offer\n    function registerMarketOffer(\n        uint256 minPricePerCuPerEpoch,\n        address paymentToken,\n        CIDV1[] calldata effectors,\n        RegisterComputePeer[] calldata peers,\n        uint256 minProtocolVersion,\n        uint256 maxProtocolVersion\n    ) external returns (bytes32);\n\n    /// @dev Add compute peers to an offer\n    function addComputePeers(bytes32 offerId, RegisterComputePeer[] calldata peers) external;\n\n    /// @dev Add compute units to a peer\n    function addComputeUnits(bytes32 peerId, bytes32[] calldata unitIds) external;\n\n    function removeOffer(bytes32 offerId) external;\n\n    function removeComputePeer(bytes32 peerId) external;\n\n    function removeComputeUnit(bytes32 unitId) external;\n\n    // Change offer\n    /// @dev Change the min price per CU per epoch of an offer\n    function changeMinPricePerCuPerEpoch(bytes32 offerId, uint256 newMinPricePerCuPerEpoch) external;\n\n    /// @dev Add effectors to an offer\n    function addEffector(bytes32 offerId, CIDV1[] calldata newEffectors) external;\n\n    /// @dev Remove effectors from an offer\n    function removeEffector(bytes32 offerId, CIDV1[] calldata effectors) external;\n\n    // Effector info\n    /// @dev Set the effector info. Effector info can be added by the contract owner\n    function setEffectorInfo(CIDV1 calldata id, string calldata description, CIDV1 calldata metadata) external;\n\n    /// @dev Remove the effector info. Effector info can be removed by the contract owner\n    function removeEffectorInfo(CIDV1 calldata id) external;\n}\n"},"src/core/interfaces/IOfferV2.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IDealV2} from \"src/deal/interfaces/IDeal.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\nimport {IBaseOffer} from \"src/core/interfaces/IBaseOffer.sol\";\nimport {LibOfferV2} from \"src/lib/LibOfferV2.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts//utils/structs/EnumerableSet.sol\";\n\n/// @title Offer contract interface\n/// @dev Offer contract is responsible for managing the offers in the market\ninterface IOfferV2 {\n    enum ResourceType {\n        VCPU,\n        RAM,\n        STORAGE,\n        PUBLIC_IP,\n        NETWORK_BANDWIDTH,\n        GPU\n    }\n\n    struct Datacenter {\n        bytes32 id;\n        string countryCode;\n        string cityCode;\n        uint256 index;\n        uint256 tier;\n        string[] certifications;\n    }\n\n    // Unique across chain, not just per resource type\n    struct ResourceDescription {\n        ResourceType ty;\n        string metadata;\n    }\n\n    // Unique across chain, not just per resource type\n    struct ResourceDescriptionView {\n        bytes32 id;\n        ResourceType ty;\n        string metadata;\n    }\n\n    struct OfferResourcesParams {\n        mapping(bytes32 resourceId => uint256 price) resourcePrices;\n        EnumerableSet.Bytes32Set resourceIds;\n    }\n\n    struct PeerResourceParams {\n        mapping(bytes32 resourceId => PeerResource) resources;\n        EnumerableSet.Bytes32Set resourceIds;\n    }\n\n    struct PeerResource {\n        uint256 availableSupply;\n        uint256 maxSupply;\n        string details;\n    }\n\n    struct ResourceRequirement {\n        bytes32 resourceId;\n        IOfferV2.ResourceType ty;\n        uint256 quantity;\n    }\n\n    struct RegisterResourcePrice {\n        ResourceType ty;\n        bytes32 resourceId;\n        uint256 price;\n    }\n\n    struct RegisterPeerResource {\n        bytes32 resourceId;\n        uint256 supply;\n        string details;\n    }\n\n    struct RegisterComputePeerV2 {\n        bytes32 peerId;\n        address owner;\n        RegisterPeerResource[] resources;\n        bytes32[] unitIds;\n    }\n\n    struct UpgradeComputePeerV2 {\n        bytes32 peerId;\n        RegisterPeerResource[] resources;\n    }\n\n    struct RegisterDatacenter {\n        string countryCode;\n        string cityCode;\n        uint256 index;\n        uint256 tier;\n        string[] certifications;\n    }\n\n    struct OfferV2PriceView {\n        bytes32 resourceId;\n        ResourceType ty;\n        string metadata;\n        uint256 price;\n    }\n\n    struct PeerV2ResourceView {\n        bytes32 resourceId;\n        ResourceType ty;\n        string metadata;\n        string details;\n        uint256 availableSupply;\n        uint256 maxSupply;\n    }\n\n    struct OfferV2View {\n        bytes32 offerId;\n        address provider;\n        address paymentToken;\n        //bytes32 datacenterId; //todo unlock when breaking api\n        OfferV2PriceView[] prices;\n    }\n\n    struct PeerV2View {\n        bytes32 offerId;\n        bytes32 peerId;\n        bytes32 commitmentId;\n        IBaseOffer.ComputeUnitView[] unitIds;\n        PeerV2ResourceView[] resources;\n    }\n\n    event OfferV2Created(\n        bytes32 indexed offerId,\n        address paymentToken,\n        address provider,\n        bytes32 datacenterId\n    );\n\n    event PeerResourceRegistered(bytes32 indexed peerId, bytes32 resourceId, uint256 maxSupply, string details);\n\n    event PeerResourceRemoved(bytes32 indexed peerId, bytes32 resourceId);\n\n    event PeerResourceSupplyUpdated(bytes32 indexed peerId, bytes32 resourceId, uint256 newAvailableSupply, uint256 newMaxSupply);\n\n    event PeerResourceDetailsUpdated(bytes32 indexed peerId, bytes32 resourceId, string details);\n\n    event ResourceCreated(bytes32 indexed resourceId, ResourceType ty, string metadata);\n\n    event ResourceMetadataUpdated(bytes32 indexed resourceId, string metadata);\n\n    event ResourcePriceUpdated(bytes32 indexed offerId, bytes32 resourceId, uint256 price);\n\n    event OfferDatacenterUpdated(bytes32 indexed offerId, bytes32 datacenterId);\n\n    event DatacenterCreated(bytes32 indexed id, string countryCode, string cityCode, uint256 index, uint256 tier, string[] certifications);\n\n    event DatacenterUpdated(bytes32 indexed id, uint256 tier, string[] certifications);\n\n    function registerMarketOfferV2(\n        address paymentToken,\n        RegisterResourcePrice[] calldata resourcePrices,\n        RegisterComputePeerV2[] calldata peers,\n        bytes32 datacenterId\n    ) external returns (bytes32);\n\n    function upgradeMarketOfferV2(\n        bytes32 offerId,\n        RegisterResourcePrice[] calldata resourcePrices,\n        UpgradeComputePeerV2[] calldata peers,\n        bytes32 datacenterId\n    ) external;\n\n    function addComputePeersV2(bytes32 offerId, RegisterComputePeerV2[] calldata peers) external;\n\n    function addComputeUnitsV2(bytes32 peerId, bytes32[] calldata unitIds, IOfferV2.RegisterPeerResource calldata resource) external;\n\n    function removeOfferV2(bytes32 offerId) external;\n\n    function removeComputePeerV2(bytes32 peerId) external;\n\n    function removeComputeUnitV2(bytes32 unitId, bytes32 associatedResourceId) external;\n\n    function changeResourcePriceV2(bytes32 offerId, bytes32 resourceId, uint256 newPrice) external;\n\n    function changeResourceMaxSupplyV2(bytes32 peerId, bytes32 resourceId, uint256 newMaxSupply) external;\n\n    function changeResourceDetails(bytes32 peerId, bytes32 resourceId, string calldata details) external;\n\n    function removePeerResource(bytes32 peerId, bytes32 resourceId) external;\n\n    function registerPeerResource(bytes32 peerId, RegisterPeerResource calldata resource) external;\n\n    function registerResources(ResourceDescription[] calldata resources) external returns(bytes32[] memory);\n\n    function updateResourceMetadata(bytes32 resourceId, string calldata metadata) external;\n\n    function ramPerVcpu() external pure returns(uint256);\n\n    function vcpuPerCu() external pure returns(uint256);\n\n    function bytesPerRam() external pure returns(uint256);\n\n    function bytesPerStorage() external pure returns(uint256);\n\n    function createDatacenter(RegisterDatacenter calldata datacenter) external returns(bytes32);\n\n    function createDatacenters(RegisterDatacenter[] calldata datacenters) external returns(bytes32[] memory);\n\n    function updateDatacenter(bytes32 id, uint256 tier, string[] calldata certifications) external;\n\n    function setOfferDatacenter(bytes32 offerId, bytes32 datacenterId) external;\n\n    function getOfferDatacenter(bytes32 offerId) external view returns(bytes32);\n}\n"},"src/deal/interfaces/IConfig.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\nimport {IOfferV2} from \"src/core/interfaces/IOfferV2.sol\";\n\n/// @title Config contract interface\n/// @dev Config contract is responsible for managing the configuration of the deal\ninterface IConfigV2 {\n    // ------------------ Types ------------------\n    enum AccessTypeV2 {\n        NONE,\n        WHITELIST,\n        BLACKLIST\n    }\n\n    // ------------------ Events ------------------\n    /// @dev Emitted when the app CID is changed\n    /// @param newAppCID The new app CID\n    event AppCIDChanged(CIDV1 newAppCID);\n\n    /// @dev Emitted when the providers access type is changed\n    /// @param newAccessType The new access type\n    event ProvidersAccessTypeChanged(AccessTypeV2 newAccessType);\n\n    /// @dev Emitted when a provider is added to the access list\n    /// @param provider The provider address\n    event ProviderAddedToAccessList(address provider);\n\n    /// @dev Emitted when a provider is removed from the access list\n    /// @param provider The provider address\n    event ProviderRemovedFromAccessList(address provider);\n\n    // ------------------ View Functions ---------------------\n    /// @dev Returns the payment token address\n    function paymentToken() external view returns (IERC20);\n\n    /// @dev Returns the creation block of the deal\n    function creationBlock() external view returns (uint256);\n\n    /// @dev Returns the price per epoch\n    function pricePerEpoch() external view returns (uint256);\n\n    /// @dev Returns the price per epoch\n    function requiredResources() external view returns (IOfferV2.ResourceRequirement[] memory);\n\n    /// @dev Returns the max number of workers\n    function targetWorkers() external view returns (uint256);\n\n    /// @dev Returns the app CID\n    function appCID() external view returns (CIDV1 memory);\n\n    /// @dev Returns the max number of workers per provider\n    function maxWorkersPerProvider() external view returns (uint256);\n\n    /// @dev Returns the providers access type\n    function providersAccessType() external view returns (AccessTypeV2);\n\n    /// @dev Returns the boolean indicating whether the provider is allowed or not\n    function isProviderAllowed(address account) external view returns (bool);\n\n    // ------------------ Mutable Functions ------------------\n    /// @dev Sets the app CID\n    function setAppCID(CIDV1 calldata appCID_) external;\n\n    /// @dev Change the providers access type\n    function changeProvidersAccessType(AccessTypeV2 accessType) external;\n\n    /// @dev Adds a provider to the access list\n    function addProviderToAccessList(address provider) external;\n\n    /// @dev Removes a provider from the access list\n    function removeProviderFromAccessList(address provider) external;\n}\n"},"src/deal/interfaces/IDeal.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IWorkerManagerV2} from \"src/deal/interfaces/IWorkerManager.sol\";\nimport {ICore} from \"src/core/interfaces/ICore.sol\";\nimport {IDiamond} from \"src/interfaces/IDiamond.sol\";\nimport {IBalanceKeeper} from \"src/balance-keeper/IBalanceKeeper.sol\";\nimport {IOfferV2} from \"src/core/interfaces/IOfferV2.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\n\ninterface IDealV2 is IWorkerManagerV2 {\n    // ------------------ Types ------------------\n    enum Status {\n        // the deal does have enough funds to pay for the workers\n        INSUFFICIENT_FUNDS,\n        ACTIVE,\n        // the deal is stopped\n        ENDED,\n        // the deal has a balance and waiting for workers\n        NOT_ENOUGH_WORKERS,\n        // the deal has balance less than the minimal balance. Min balance: 2 * targetWorkers * pricePerCuPerEpoch * cuCountPerWorker\n        SMALL_BALANCE\n    }\n\n    struct WorkerPaymentInfo {\n        uint256 snapshotEpoch;\n        uint256 gapsDelta;\n    }\n\n    struct DealStorage {\n        uint256 totalBalance;\n        uint256 lockedBalance;\n        uint256 gapsEpochCount;\n        uint256 maxPaidEpoch;\n        uint256 lastCommitedEpoch;\n        mapping(bytes32 => WorkerPaymentInfo) workerPaymentInfo;\n        uint256 endedEpoch;\n        uint256 protocolVersion;\n        uint256 migratedToBalanceKeeper; // default 0, will be set to 1 after migration\n    }\n\n    struct DealRewards {\n        uint256 providerReward;\n        uint256 stakerReward;\n    }\n\n    // ----------------- Events -----------------\n    /// @dev Emitted when a owner deposits payment token to the deal\n    event Deposited(uint256 amount);\n\n    /// @dev Emitted when a owner withdraws payment token from the deal\n    event Withdrawn(uint256 amount);\n\n    /// @dev Emitted when a compute unit withdraws rewards from the deal\n    event RewardWithdrawn(bytes32 onchainWorkerId, uint256 providerReward, uint256 stakerReward);\n\n    /// @dev Emitted when a max paid epoch is updated\n    event MaxPaidEpochUpdated(uint256 maxPaidEpoch);\n\n    /// @dev Emitted when a deal is ended. This event can be emitted in the not-ended epoch. It can be emitted after the ended epoch in any epoch\n    event DealEnded(uint256 endedEpoch);\n\n    // ------------------ Init ------------------\n    function initialize(\n        IDiamond diamond_,\n        CIDV1 calldata appCID_,\n        IERC20 paymentToken_,\n        uint256 targetWorkers_,\n        IOfferV2.ResourceRequirement[] calldata resources_,\n        uint256 pricePerEpoch_,\n        uint256 maxWorkersPerProvider_,\n        AccessTypeV2 providersAccessType_,\n        address[] calldata providersAccessList_,\n        uint256 protocolVersion_,\n        address owner_\n    ) external;\n\n    /// @dev Returns the status of the deal\n    function getStatus() external view returns (Status);\n\n    /// @dev Returns the free balance of the deal\n    function getFreeBalance() external view returns (uint256);\n\n    /// @dev Returns the reward amount by compute unit ID\n    function getRewardAmount(bytes32 onchainWorkerId) external view returns (DealRewards memory);\n\n    /// @dev Returns the max paid epoch\n    function getMaxPaidEpoch() external view returns (uint256);\n\n    /// @dev Returns the protocol version\n    function getProtocolVersion() external view returns (uint256);\n\n    /// @dev Deposits payment token to the deal\n    function depositFromOwner(uint256 amount, IBalanceKeeper.DealDepositReason reason) external;\n\n    /// @dev Withdraws payment token from the deal\n    function withdraw(uint256 amount) external;\n\n    // ------------------ Public Mutable Functions ------------------\n    /// @dev Adds a compute unit to the deal\n    /// @param computeProvider The compute provider address\n    /// @param workerData The worker with data\n    /// @param peerId The peer ID\n    function addWorker(address computeProvider, WorkerDataV2 memory workerData, bytes32 peerId) external;\n\n    /// @dev Removes a worker from the deal\n    function removeWorker(bytes32 onchainWorkerId) external;\n\n    /// @dev Allows oracle to remove worker from a deal that is not paying workers.\n    function removeStaleWorkers(bytes32[] calldata onchainWorkerIds) external;\n\n    /// @dev Withdraws rewards from the deal by compute unit ID\n    function withdrawRewards(bytes32 onchainWorkerId) external;\n\n    /// @dev Set offchain worker ID for a corresponding onchain worker for a deal\n    function activateWorker(bytes32 onchainWorkerId, bytes32 offchainWorkerId) external;\n\n    /// @dev Stop the deal\n    function stop() external;\n}\n"},"src/deal/interfaces/IWorkerManager.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IConfigV2} from \"src/deal/interfaces/IConfig.sol\";\n\n/// @title Worker manager contract interface\n/// @dev Worker manager contract is responsible for managing the workers in the deal\ninterface IWorkerManagerV2 is IConfigV2 {\n    // ------------------ Types ------------------\n    struct WorkerDataV2 {\n        bytes32 onchainId;\n    }\n\n    struct Worker {\n        bytes32 offchainId;\n        bytes32 onchainId;\n        bytes32 peerId;\n        address provider;\n        uint256 joinedEpoch;\n    }\n\n    // ------------------ Events ------------------\n\n    /// @dev Emitted when a new worker is added\n    /// @param peerId The id of compute peer\n    /// @param onchainId The worker ID\n    event WorkerJoined(bytes32 indexed peerId, bytes32 onchainId);\n\n    /// @dev Emitted when a worker is removed\n    /// @param peerId The id of compute peer\n    /// @param onchainId The worker onchain ID\n    event WorkerRemoved(bytes32 indexed peerId, bytes32 onchainId);\n\n    /// @dev Emitted when a worker ID is updated\n    /// @param onchainWorkerId The worker\n    /// @param offchainWorkerId The new worker ID\n    event WorkerIdUpdated(bytes32 onchainWorkerId, bytes32 offchainWorkerId);\n\n    /// @dev Returns total number of workers\n    function getWorkerCount() external view returns (uint256);\n\n    /// @dev Returns number of workers in provider\n    function getWorkerCount(address provider) external view returns (uint256);\n\n    /// @dev Returns workers registered in this deal\n    function getWorkerIds() external view returns (bytes32[] memory);\n\n    /// @dev Returns the worker count. Worker is a compute unit that has a worker ID\n    function getActivatedWorkerCount() external view returns (uint256);\n\n    /// @dev Returns the boolean flag indicating whether the peer exists in the deal\n    function computePeerUsed(bytes32 peerId) external view returns (bool);\n}\n"},"src/deal/v1/interfaces/IConfig.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\n\n/// @title Config contract interface\n/// @dev Config contract is responsible for managing the configuration of the deal\ninterface IConfig {\n    // ------------------ Types ------------------\n    enum AccessType {\n        NONE,\n        WHITELIST,\n        BLACKLIST\n    }\n\n    // ------------------ Events ------------------\n    /// @dev Emitted when the app CID is changed\n    /// @param newAppCID The new app CID\n    event AppCIDChanged(CIDV1 newAppCID);\n\n    /// @dev Emitted when the providers access type is changed\n    /// @param newAccessType The new access type\n    event ProvidersAccessTypeChanged(AccessType newAccessType);\n\n    /// @dev Emitted when a provider is added to the access list\n    /// @param provider The provider address\n    event ProviderAddedToAccessList(address provider);\n\n    /// @dev Emitted when a provider is removed from the access list\n    /// @param provider The provider address\n    event ProviderRemovedFromAccessList(address provider);\n\n    // ------------------ View Functions ---------------------\n    /// @dev Returns the payment token address\n    function paymentToken() external view returns (IERC20);\n\n    /// @dev Returns the creation block of the deal\n    function creationBlock() external view returns (uint256);\n\n    /// @dev Returns the price per CU per epoch\n    function pricePerCuPerEpoch() external view returns (uint256);\n\n    /// @dev Returns the max number of workers\n    function targetWorkers() external view returns (uint256);\n\n    /// @dev Returns number of CUs in a worker\n    function cuCountPerWorker() external view returns (uint256);\n\n    /// @dev Returns the min number of workers\n    function minWorkers() external view returns (uint256);\n\n    /// @dev Returns the effector CIDs\n    function effectors() external view returns (CIDV1[] memory);\n\n    /// @dev Returns the app CID\n    function appCID() external view returns (CIDV1 memory);\n\n    /// @dev Returns the max number of workers per provider\n    function maxWorkersPerProvider() external view returns (uint256);\n\n    /// @dev Returns the providers access type\n    function providersAccessType() external view returns (AccessType);\n\n    /// @dev Returns the boolean indicating whether the provider is allowed or not\n    function isProviderAllowed(address account) external view returns (bool);\n\n    // ------------------ Mutable Functions ------------------\n    /// @dev Sets the app CID\n    function setAppCID(CIDV1 calldata appCID_) external;\n\n    /// @dev Change the providers access type\n    function changeProvidersAccessType(AccessType accessType) external;\n\n    /// @dev Adds a provider to the access list\n    function addProviderToAccessList(address provider) external;\n\n    /// @dev Removes a provider from the access list\n    function removeProviderFromAccessList(address provider) external;\n}\n"},"src/deal/v1/interfaces/IDeal.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IWorkerManager} from \"src/deal/v1/interfaces/IWorkerManager.sol\";\nimport {ICore} from \"src/core/interfaces/ICore.sol\";\nimport {IBalanceKeeper} from \"src/balance-keeper/IBalanceKeeper.sol\";\nimport {IDiamond} from \"src/interfaces/IDiamond.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\n\ninterface IDeal is IWorkerManager {\n    // ------------------ Types ------------------\n    enum Status {\n        // the deal does have enough funds to pay for the workers\n        INSUFFICIENT_FUNDS,\n        ACTIVE,\n        // the deal is stopped\n        ENDED,\n        // the deal has a balance and waiting for workers\n        NOT_ENOUGH_WORKERS,\n        // the deal has balance less than the minimal balance. Min balance: 2 * targetWorkers * pricePerCuPerEpoch * cuCountPerWorker\n        SMALL_BALANCE\n    }\n\n    struct WorkerPaymentInfo {\n        uint256 snapshotEpoch;\n        uint256 gapsDelta;\n    }\n\n    struct DealStorage {\n        uint256 totalBalance;\n        uint256 lockedBalance;\n        uint256 gapsEpochCount;\n        uint256 maxPaidEpoch;\n        uint256 lastCommitedEpoch;\n        mapping(bytes32 => WorkerPaymentInfo) workerPaymentInfo;\n        uint256 endedEpoch;\n        uint256 protocolVersion;\n        uint256 migratedToBalanceKeeper; // default 0, will be set to 1 after migration\n    }\n\n    struct DealRewards {\n        uint256 providerReward;\n        uint256 stakerReward;\n    }\n\n    // ----------------- Events -----------------\n    /// @dev Emitted when a owner deposits payment token to the deal\n    event Deposited(uint256 amount);\n\n    /// @dev Emitted when a owner withdraws payment token from the deal\n    event Withdrawn(uint256 amount);\n\n    /// @dev Emitted when a compute unit withdraws rewards from the deal\n    event RewardWithdrawn(bytes32 onchainWorkerId, uint256 providerReward, uint256 stakerReward);\n\n    /// @dev Emitted when a max paid epoch is updated\n    event MaxPaidEpochUpdated(uint256 maxPaidEpoch);\n\n    /// @dev Emitted when a deal is ended. This event can be emitted in the not-ended epoch. It can be emitted after the ended epoch in any epoch\n    event DealEnded(uint256 endedEpoch);\n\n    // ------------------ Init ------------------\n    function initialize(\n        IDiamond diamond_,\n        CIDV1 calldata appCID_,\n        IERC20 paymentToken_,\n        uint256 minWorkers_,\n        uint256 targetWorkers_,\n        uint256 cuCountPerWorker_,\n        uint256 maxWorkersPerProvider_,\n        uint256 pricePerCuPerEpoch_,\n        CIDV1[] calldata effectors_,\n        AccessType providersAccessType_,\n        address[] calldata providersAccessList_,\n        uint256 protocolVersion_,\n        address owner_\n    ) external;\n\n    /// @dev Returns the status of the deal\n    function getStatus() external view returns (Status);\n\n    /// @dev Returns the free balance of the deal\n    function getFreeBalance() external view returns (uint256);\n\n    /// @dev Returns the reward amount by compute unit ID\n    function getRewardAmount(bytes32 onchainWorkerId) external view returns (DealRewards memory);\n\n    /// @dev Returns the max paid epoch\n    function getMaxPaidEpoch() external view returns (uint256);\n\n    /// @dev Returns the protocol version\n    function getProtocolVersion() external view returns (uint256);\n\n    /// @dev Deposits payment token to the deal\n    function depositFromOwner(uint256 amount, IBalanceKeeper.DealDepositReason reason) external;\n\n    /// @dev Withdraws payment token from the deal\n    function withdraw(uint256 amount) external;\n\n    // ------------------ Public Mutable Functions ------------------\n    /// @dev Adds a compute unit to the deal\n    /// @param computeProvider The compute provider address\n    /// @param workerData The worker with data\n    /// @param peerId The peer ID\n    function addWorker(address computeProvider, WorkerData memory workerData, bytes32 peerId) external;\n\n    /// @dev Removes a worker from the deal\n    function removeWorker(bytes32 onchainWorkerId) external;\n\n    /// @dev Allows oracle to remove worker from a deal that is not paying workers.\n    function removeStaleWorkers(bytes32[] calldata onchainWorkerIds) external;\n\n    /// @dev Withdraws rewards from the deal by compute unit ID\n    function withdrawRewards(bytes32 onchainWorkerId) external;\n\n    /// @dev Set offchain worker ID for a corresponding onchain worker for a deal\n    function activateWorker(bytes32 onchainWorkerId, bytes32 offchainWorkerId) external;\n\n    /// @dev Stop the deal\n    function stop() external;\n}\n"},"src/deal/v1/interfaces/IWorkerManager.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {IConfig} from \"src/deal/v1/interfaces/IConfig.sol\";\n\n/// @title Worker manager contract interface\n/// @dev Worker manager contract is responsible for managing the workers in the deal\ninterface IWorkerManager is IConfig {\n    // ------------------ Types ------------------\n    struct WorkerData {\n        bytes32 onchainId;\n        bytes32[] computeUnitIds;\n    }\n\n    struct Worker {\n        bytes32 offchainId;\n        bytes32 onchainId;\n        bytes32 peerId;\n        address provider;\n        uint256 joinedEpoch;\n        bytes32[] computeUnitIds;\n    }\n\n    // ------------------ Events ------------------\n\n    /// @dev Emitted when a new worker is added\n    /// @param peerId The id of compute peer\n    /// @param onchainId The worker ID\n    event WorkerJoined(bytes32 indexed peerId, bytes32 onchainId);\n\n    /// @dev Emitted when a worker is removed\n    /// @param peerId The id of compute peer\n    /// @param onchainId The worker onchain ID\n    event WorkerRemoved(bytes32 indexed peerId, bytes32 onchainId);\n\n    /// @dev Emitted when a worker ID is updated\n    /// @param onchainWorkerId The worker\n    /// @param offchainWorkerId The new worker ID\n    event WorkerIdUpdated(bytes32 onchainWorkerId, bytes32 offchainWorkerId);\n\n    // ------------------ Public View Functions ---------------------\n    /// @dev Returns worker by ID\n    function getWorker(bytes32 onchainWorkerId) external view returns (Worker memory);\n\n    /// @dev Returns total number of workers\n    function getWorkerCount() external view returns (uint256);\n\n    /// @dev Returns number of workers in provider\n    function getWorkerCount(address provider) external view returns (uint256);\n\n    /// @dev Returns workers registered in this deal\n    function getWorkers() external view returns (Worker[] memory);\n\n    /// @dev Returns the worker count. Worker is a compute unit that has a worker ID\n    function getActivatedWorkerCount() external view returns (uint256);\n\n    /// @dev Returns the boolean flag indicating whether the peer exists in the deal\n    function computePeerUsed(bytes32 peerId) external view returns (bool);\n}\n"},"src/interfaces/IDiamond.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {IDeal} from \"src/deal/v1/interfaces/IDeal.sol\";\nimport {IDealV2} from \"src/deal/interfaces/IDeal.sol\";\nimport {ICapacityConst} from \"src/core/interfaces/ICapacityConst.sol\";\n\ninterface IDiamond {\n    event Initialized();\n\n    struct CoreParams {\n        uint256 epochDuration;\n        IDeal dealImpl;\n        IDealV2 dealV2Impl;\n        bool isWhitelistEnabled;\n        ICapacityConst.CapacityConstInitArgs capacityConstInitArgs;\n    }\n\n    struct CapacityParams {\n        bytes32 initGlobalNonce;\n    }\n\n    struct GlobalConstParams {\n        uint256 minDealDepositedEpochs;\n        uint256 minDealRematchingEpochs;\n        uint256 minProtocolVersion;\n        uint256 maxProtocolVersion;\n        uint256 maxUnitCountPerProvider;\n    }\n\n    fallback() external payable;\n}\n"},"src/interfaces/IDiamondCut.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"},"src/interfaces/IDiamondLoupe.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"},"src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"src/interfaces/IERC173.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"},"src/interfaces/IMulticall.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\ninterface IMulticall {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\n}\n"},"src/interfaces/IViewer.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {ICapacity} from \"src/core/interfaces/ICapacity.sol\";\nimport {IOfferV2} from \"src/core/interfaces/IOfferV2.sol\";\n\ninterface IViewer {\n    function getCommitmentStatuses(bytes32[] calldata commitmentIds) external view returns (ICapacity.CCStatus[] memory statuses);\n\n    function getResources() external view returns(IOfferV2.ResourceDescriptionView[] memory);\n\n    function getResource(bytes32 resourceId) external view returns(IOfferV2.ResourceDescription memory);\n\n    function getDatacenter(bytes32 id) external view returns(IOfferV2.Datacenter memory);\n\n    function getDatacenters() external view returns(IOfferV2.Datacenter[] memory);\n\n    function getOffersV2() external view returns(IOfferV2.OfferV2View[] memory);\n\n    function getOfferV2(bytes32 offerId) external view returns(IOfferV2.OfferV2View memory);\n\n    function getPeersV2(bytes32 offerId) external view returns(IOfferV2.PeerV2View[] memory);\n\n    function getPeerV2(bytes32 peerId) external view returns(IOfferV2.PeerV2View memory);\n}\n"},"src/interfaces/IWhitelist.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\n\ninterface IWhitelist {\n    event WhitelistAccessGranted(address account);\n    event WhitelistAccessRevoked(address account);\n\n\n    function isApproved(address account) external view returns (bool);\n    function grantAccess(address account) external;\n    function revokeAccess(address account) external;\n}\n"},"src/lib/LibBaseOffer.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {IBaseOffer} from \"src/core/interfaces/IBaseOffer.sol\";\nimport {IOffer} from \"src/core/interfaces/IOffer.sol\";\nimport {LibCapacity} from \"src/lib/LibCapacity.sol\";\nimport {LibGlobalConst} from \"src/lib/LibGlobalConst.sol\";\nimport {IDeal} from \"src/deal/v1/interfaces/IDeal.sol\";\nimport {IWorkerManager} from \"src/deal/v1/interfaces/IWorkerManager.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {OwnableUpgradableDiamond} from \"src/utils/OwnableUpgradableDiamond.sol\";\n\nstruct Effectors {\n    mapping(bytes32 => bool) hasEffector;\n}\n\nstruct OfferStorage {\n    mapping(address => IBaseOffer.ProviderInfo) providers;               // BaseOffer\n    mapping(bytes32 => IOffer.Offer) offers;                             // OfferV1 + BaseOffer (see struct)\n    mapping(bytes32 => IBaseOffer.ComputePeer) peers;                    // LibBaseOffer\n    mapping(bytes32 => IBaseOffer.ComputeUnit) computeUnits;             // LibBaseOffer\n    mapping(bytes32 => Effectors) effectorsByOfferId;                    // OfferV1\n    mapping(bytes32 => EnumerableSet.Bytes32Set) computeUnitIdsByPeerId; // LibBaseOffer\n    mapping(bytes32 => IOffer.EffectorInfo) effectorInfoById;            // OfferV1\n}\n\nlibrary LibBaseOffer {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    bytes32 internal constant _OFFER_ID_PREFIX = bytes32(uint256(keccak256(\"fluence.market.offer\")) - 1);\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.market.storage.v1\")) - 1);\n    uint256 public constant PROTOCOL_V1 = 1;\n    uint256 public constant PROTOCOL_V2 = 2;\n\n    function store() internal pure returns (OfferStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    function getProviderInfo(address provider) internal view returns (IBaseOffer.ProviderInfo memory) {\n        return store().providers[provider];\n    }\n\n    function getBaseOffer(bytes32 offerId) internal view returns (IBaseOffer.BaseOffer memory) {\n        IOffer.Offer storage offer = store().offers[offerId];\n        require(offer.provider != address(0x00), \"Offer: offer doesn't exist\");\n\n        return IBaseOffer.BaseOffer({\n            provider: offer.provider,\n            paymentToken: offer.paymentToken,\n            peerCount: offer.peerCount,\n            minProtocolVersion: offer.minProtocolVersion,\n            maxProtocolVersion: offer.maxProtocolVersion\n        });\n    }\n\n    function getComputePeer(bytes32 peerId) internal view returns (IBaseOffer.ComputePeer memory) {\n        IBaseOffer.ComputePeer storage computePeer = store().peers[peerId];\n        require(computePeer.offerId != bytes32(0x00), \"Peer doesn't exist\");\n\n        return store().peers[peerId];\n    }\n\n    function getComputeUnit(bytes32 unitId) internal view returns (IBaseOffer.ComputeUnit memory) {\n        IBaseOffer.ComputeUnit storage computeUnit = store().computeUnits[unitId];\n        require(computeUnit.peerId != bytes32(0x00), \"getComputeUnit: Compute unit doesn't exist\");\n\n        return store().computeUnits[unitId];\n    }\n\n    function getComputeUnits(bytes32 peerId) internal view returns (IBaseOffer.ComputeUnitView[] memory) {\n        OfferStorage storage offerStorage = store();\n\n        bytes32[] memory unitIds = offerStorage.computeUnitIdsByPeerId[peerId].values();\n        IBaseOffer.ComputeUnitView[] memory units = new IBaseOffer.ComputeUnitView[](unitIds.length);\n\n        IBaseOffer.ComputePeer storage computePeer = offerStorage.peers[peerId];\n        bytes32 commitmentId = computePeer.commitmentId;\n\n        uint256 capacityStartEpoch;\n        if (commitmentId != bytes32(0x00)) {\n            capacityStartEpoch = LibCapacity.getCommitment(commitmentId).startEpoch;\n        }\n\n        for (uint256 i = 0; i < unitIds.length; i++) {\n            bytes32 unitId = unitIds[i];\n            IBaseOffer.ComputeUnit storage computeUnit = offerStorage.computeUnits[unitId];\n            uint256 startEpoch = computeUnit.startEpoch;\n\n            if (startEpoch == 0) {\n                startEpoch = capacityStartEpoch;\n            }\n\n            units[i] = IBaseOffer.ComputeUnitView({id: unitId, deal: computeUnit.deal, startEpoch: startEpoch, onchainWorkerId: computeUnit.onchainWorkerId});\n        }\n\n        return units;\n    }\n\n    function getComputeUnitIds(bytes32 peerId) internal view returns (bytes32[] memory) {\n        return store().computeUnitIdsByPeerId[peerId].values();\n    }\n\n    function setCommitmentId(bytes32 peerId, bytes32 commitmentId) internal {\n        OfferStorage storage offerStorage = store();\n        IBaseOffer.ComputePeer storage computePeer = offerStorage.peers[peerId];\n\n        computePeer.commitmentId = commitmentId;\n    }\n\n    function setStartEpoch(bytes32 unitId, uint256 startEpoch) internal {\n        OfferStorage storage offerStorage = store();\n        IBaseOffer.ComputeUnit storage computeUnit = offerStorage.computeUnits[unitId];\n\n        computeUnit.startEpoch = startEpoch;\n    }\n\n    function setProviderInfo(string calldata name, CIDV1 calldata metadata) internal {\n        require(bytes(name).length > 0, \"Name should be not empty\");\n        IBaseOffer.ProviderInfo storage provider = store().providers[msg.sender];\n        provider.name = name;\n        provider.metadata = metadata;\n\n        emit IBaseOffer.ProviderInfoUpdated(msg.sender, name, metadata);\n    }\n\n    function registerBaseOffer(\n        address paymentToken,\n        uint256 minProtocolVersion,\n        uint256 maxProtocolVersion\n    ) internal returns (bytes32) {\n        OfferStorage storage offerStorage = LibBaseOffer.store();\n\n        address provider = msg.sender;\n        bytes32 offerId = keccak256(abi.encodePacked(_OFFER_ID_PREFIX, provider, block.number, msg.data));\n\n        require(bytes(offerStorage.providers[provider].name).length > 0, \"Provider doesn't exist\");\n        require(offerStorage.offers[offerId].paymentToken == address(0x00), \"Offer already exists\");\n        require(address(paymentToken) != address(0x00), \"Payment token should be not zero address\");\n        require(minProtocolVersion >= LibGlobalConst.minProtocolVersion(), \"Min protocol version too small\");\n        require(maxProtocolVersion <= LibGlobalConst.maxProtocolVersion(), \"Max protocol version too big\");\n        require(minProtocolVersion <= maxProtocolVersion, \"Wrong protocol versions\");\n        require(LibGlobalConst.isPaymentTokenAllowed(paymentToken), \"Payment token is not allowed\");\n\n        // create market offer\n        offerStorage.offers[offerId] = IOffer.Offer({\n            provider: provider,\n            minPricePerCuPerEpoch: 0,\n            paymentToken: paymentToken,\n            peerCount: 0,\n            minProtocolVersion: minProtocolVersion,\n            maxProtocolVersion: maxProtocolVersion\n        });\n\n        emit IBaseOffer.MarketOfferRegistered(\n            provider, offerId, 0, paymentToken, new CIDV1[](0), minProtocolVersion, maxProtocolVersion\n        );\n\n        return offerId;\n    }\n\n    function removeBaseOffer(bytes32 offerId) internal {\n        OfferStorage storage offerStorage = store();\n        IOffer.Offer storage offer = offerStorage.offers[offerId];\n\n        require(offer.provider != address(0), \"Offer: offer doesn't exist\");\n        require(offer.provider == msg.sender, \"Offer: only provider can call this method\");\n        require(offer.peerCount == 0, \"Offer has compute peers\");\n\n        delete offerStorage.offers[offerId];\n\n        emit IBaseOffer.MarketOfferRemoved(offerId);\n    }\n\n    function registerBaseComputePeer(\n        bytes32 offerId,\n        bytes32 peerId,\n        address owner,\n        bytes32[] calldata unitIds\n    ) internal {\n        OfferStorage storage offerStorage = store();\n\n        IBaseOffer.ComputePeer storage computePeer = offerStorage.peers[peerId];\n        IOffer.Offer storage offer = offerStorage.offers[offerId];\n\n        require(computePeer.offerId == bytes32(0x00), \"LibBaseOffer: Peer already exists in another offer\");\n        require(peerId != bytes32(0x00), \"LibBaseOffer: Peer id should be not empty\");\n        require(owner != address(0x00), \"LibBaseOffer: Owner address should be not empty\");\n\n        computePeer.offerId = offerId;\n        computePeer.owner = owner;\n\n        offer.peerCount++;\n\n        emit IBaseOffer.PeerCreated(offerId, peerId, computePeer.owner);\n        registerBaseComputeUnits(peerId, unitIds);\n    }\n\n    function removeBaseComputePeer(bytes32 peerId) internal {\n        OfferStorage storage offerStorage = LibBaseOffer.store();\n        IBaseOffer.ComputePeer storage computePeer = offerStorage.peers[peerId];\n        bytes32 offerId = computePeer.offerId;\n        IOffer.Offer storage offer = offerStorage.offers[offerId];\n\n        require(offerId != bytes32(0x00), \"Peer doesn't exist\");\n        require(offer.provider == msg.sender, \"Offer: only provider can call this method\");\n\n        require(computePeer.unitCount == 0, \"Peer has compute units\");\n\n        require(offer.peerCount > 0, \"LibBaseOffer: attempt to remove a peer from an offer without peers\");\n        offer.peerCount--;\n        delete offerStorage.peers[peerId];\n\n        emit IBaseOffer.PeerRemoved(offerId, peerId);\n    }\n\n    function registerBaseComputeUnits(\n        bytes32 peerId,\n        bytes32[] calldata unitIds\n    ) internal {\n        OfferStorage storage offerStorage = store();\n        IBaseOffer.ComputePeer storage computePeer = offerStorage.peers[peerId];\n        IOffer.Offer storage offer = offerStorage.offers[computePeer.offerId];\n        IBaseOffer.ProviderInfo storage provider = offerStorage.providers[offer.provider];\n\n        uint256 unitCount = unitIds.length;\n\n        require(unitCount > 0, \"LibBaseOffer: units length should be greater than 0\");\n        require(provider.unitCount + unitCount <= LibGlobalConst.maxUnitCountPerProvider(), \"LibBaseOffer: Exceeded max CU number per Provider\");\n\n        for (uint256 i = 0; i < unitCount; i++) {\n            bytes32 unitId = unitIds[i];\n\n            require(unitId != bytes32(0x00), \"LibBaseOffer: Unit id should be not empty\");\n            require(offerStorage.computeUnits[unitId].peerId == bytes32(0x00), \"LibBaseOffer: Compute unit already exists\");\n\n            // create compute unit\n            offerStorage.computeUnits[unitId] = IBaseOffer.ComputeUnit({deal: address(0x00), peerId: peerId, startEpoch: 0, onchainWorkerId: 0});\n            require(offerStorage.computeUnitIdsByPeerId[peerId].add(unitId), \"LibBaseOffer: Invalid add to enumerable set\");\n\n            emit IBaseOffer.ComputeUnitCreated(peerId, unitId);\n        }\n\n        provider.unitCount += unitCount;\n        computePeer.unitCount += unitCount;\n    }\n\n    function removeBaseComputeUnit(bytes32 unitId) internal {\n        OfferStorage storage offerStorage = store();\n        IBaseOffer.ComputeUnit storage computeUnit = offerStorage.computeUnits[unitId];\n\n        bytes32 peerId = computeUnit.peerId;\n        require(peerId != bytes32(0x00), \"removeBaseComputeUnit: Compute unit doesn't exist\");\n\n        IBaseOffer.ComputePeer storage computePeer = offerStorage.peers[peerId];\n        IOffer.Offer storage offer = offerStorage.offers[computePeer.offerId];\n        IBaseOffer.ProviderInfo storage provider = offerStorage.providers[offer.provider];\n\n        require(offer.provider == msg.sender, \"Offer: protocol version mismatch, required v1\");\n        require(computePeer.commitmentId == bytes32(0x00), \"Peer has commitment\");\n        require(computeUnit.deal == address(0x00), \"Compute unit is in deal\");\n\n        require(computePeer.unitCount > 0, \"LibBaseOffer: cannot remove compute unit because peer has zero units\");\n        require(provider.unitCount > 0, \"LibBaseOffer: cannot remove compute unit because provider has zero units\");\n        computePeer.unitCount--;\n        provider.unitCount--;\n\n        require(offerStorage.computeUnitIdsByPeerId[peerId].remove(unitId), \"Invalid remove from enumerable set\");\n\n        delete offerStorage.computeUnits[unitId];\n\n        emit IBaseOffer.ComputeUnitRemoved(peerId, unitId);\n    }\n\n    function changePaymentToken(bytes32 offerId, address newPaymentToken) internal {\n        OfferStorage storage offerStorage = store();\n        IOffer.Offer storage offer = offerStorage.offers[offerId];\n\n        require(offer.provider == msg.sender, \"Offer: only provider can call this method\");\n        require(newPaymentToken != address(0x00), \"Payment token should be not zero address\");\n        require(LibGlobalConst.isPaymentTokenAllowed(newPaymentToken), \"Payment token is not allowed\");\n\n        offer.paymentToken = newPaymentToken;\n\n        emit IBaseOffer.PaymentTokenUpdated(offerId, newPaymentToken);\n    }\n\n    function upgradeProtocolVersion(bytes32 offerId, uint256 minProtocolVersion, uint256 maxProtocolVersion) internal {\n        IOffer.Offer storage offer = store().offers[offerId];\n        require(offer.provider != address (0), \"LibBaseOffer: offer does not exist\");\n        require(minProtocolVersion <= maxProtocolVersion, \"LibBaseOffer: min protocol version is larger than max protocol version\");\n        require(offer.minProtocolVersion <= minProtocolVersion, \"LibBaseOffer: attempt to downgrade minProtocolVersion during version upgrade\");\n        require(offer.maxProtocolVersion <= maxProtocolVersion, \"LibBaseOffer: attempt to downgrade manProtocolVersion during version upgrade\");\n\n        offer.minProtocolVersion = minProtocolVersion;\n        offer.maxProtocolVersion = maxProtocolVersion;\n\n        emit IBaseOffer.ProtocolVersionUpgraded(offerId, minProtocolVersion, maxProtocolVersion);\n    }\n}\n"},"src/lib/LibCapacity.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IBaseOffer} from \"src/core/interfaces/IBaseOffer.sol\";\nimport {ICapacity} from \"src/core/interfaces/ICapacity.sol\";\nimport {Snapshot} from \"src/core/Snapshot.sol\";\nimport {LibDiamond} from \"src/lib/LibDiamond.sol\";\nimport {LibBaseOffer} from \"src/lib/LibBaseOffer.sol\";\nimport {LibEpochController} from \"src/lib/LibEpochController.sol\";\nimport {LibCapacityConst} from \"src/lib/LibCapacityConst.sol\";\nimport {LibSendValue} from \"src/lib/LibSendValue.sol\";\nimport {PRECISION} from \"src/utils/Common.sol\";\nimport {Vesting} from \"src/core/Vesting.sol\";\nimport {DealStakerRewards} from \"src/core/DealStakerRewards.sol\";\n\nstruct CommitmentStorage {\n    mapping(bytes32 => ICapacity.Commitment) commitments;\n    mapping(uint256 => ICapacity.RewardInfo) rewardInfoByEpoch;\n    mapping(bytes32 => mapping(bytes32 => bool)) isProofSubmittedByUnit;\n    bytes32 globalNonce;\n    bytes32 nextGlobalNonce;\n    uint256 changedNonceEpoch;\n    uint256 rewardBalance;\n}\n\nlibrary LibCapacity {\n    using Snapshot for Snapshot.Cache;\n    using Vesting for Vesting.Info;\n    using DealStakerRewards for DealStakerRewards.Info;\n    using LibSendValue for address payable;\n\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.capacity.storage.v1\")) - 1);\n\n    function store() internal pure returns (CommitmentStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    function _expiredEpoch(ICapacity.Commitment storage cc) internal view returns (uint256) {\n        return cc.info.startEpoch + cc.info.duration;\n    }\n\n    function getStatus(bytes32 commitmentId) internal view returns (ICapacity.CCStatus) {\n        CommitmentStorage storage s = store();\n        ICapacity.Commitment storage cc = s.commitments[commitmentId];\n\n        bytes32 peerId = cc.info.peerId;\n        require(peerId != bytes32(0x00), \"Capacity commitment doesn't exist\");\n\n        IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(peerId);\n\n        Snapshot.Cache memory snapshotCache = Snapshot.init(cc);\n        ICapacity.CCStatus status = _preCommitCommitmentSnapshot(cc, snapshotCache, peer, LibEpochController.currentEpoch(), _expiredEpoch(cc));\n\n        return status;\n    }\n\n    // IMPORTANT: This function affects the off-chain indexer. If you change it, make sure to update the indexer accordingly.\n    function _preCommitCommitmentSnapshot(\n        ICapacity.Commitment storage cc,\n        Snapshot.Cache memory snapshotCache,\n        IBaseOffer.ComputePeer memory peer,\n        uint256 currentEpoch_,\n        uint256 expiredEpoch\n    ) internal view returns (ICapacity.CCStatus) {\n        ICapacity.CCStatus storageStatus = snapshotCache.current.status;\n        uint256 lastSnapshotEpoch = snapshotCache.current.snapshotEpoch;\n        uint256 snapshotEpoch = currentEpoch_ - 1;\n\n        if (cc.info.startEpoch == 0) {\n            return ICapacity.CCStatus.WaitDelegation;\n        } else if (cc.info.startEpoch > currentEpoch_) {\n            return ICapacity.CCStatus.WaitStart;\n        }\n\n        // only active status can have a snapshot and be changed because with other statuses CC can't work\n        // also if snapshotEpoch is less or equal to lastSnapshotEpoch, then we have snapshot for this epoch\n        if (storageStatus != ICapacity.CCStatus.Active || snapshotEpoch <= lastSnapshotEpoch) {\n            return storageStatus;\n        }\n\n        ICapacity.CCStatus newStatus = ICapacity.CCStatus.Active;\n        // if the snapshotEpoch is greater than expiredEpoch, then you need to take a snapshot only up to expiredEpoch\n        uint256 lastWorkingEpoch = expiredEpoch - 1;\n        if (snapshotEpoch >= lastWorkingEpoch) {\n            snapshotEpoch = lastWorkingEpoch;\n            newStatus = ICapacity.CCStatus.Inactive;\n        }\n\n        // #region init variables\n        uint256 maxFailedRatio_ = LibCapacityConst.maxFailedRatio();\n        uint256 activeUnitCount_ = snapshotCache.current.activeUnitCount;\n        uint256 nextAdditionalActiveUnitCount_ = snapshotCache.current.nextAdditionalActiveUnitCount;\n        uint256 totalFailCount = snapshotCache.current.totalFailCount;\n        uint256 prevFailCount = totalFailCount;\n        // All successes (CU/epoch) happened during snapshot period.\n        // In fact, all of them happened on the first epoch of the period\n        uint256 successesInTargetPeriod = snapshotCache.current.currentSuccessCount;\n\n        uint256 failsInFirstTargetedEpoch = 0;\n        if (activeUnitCount_ > successesInTargetPeriod) {\n            failsInFirstTargetedEpoch = activeUnitCount_ - successesInTargetPeriod;\n        }\n        // maxFailCount is a number of Epochs when units not send proofs\n        // if on unit not send proof per one epoch, it's mean that it's one fail\n        // maxFailedRatio is the ratio of failed attempts for all units\n        uint256 maxFailCount = maxFailedRatio_ * peer.unitCount;\n        uint256 snapshotEpochCount = snapshotEpoch - lastSnapshotEpoch;\n        // nextAdditionalActiveUnitCount_ excludes CUs from proof sending only for one epoch, so for all subsequent epochs we require them to succeed\n        uint256 requiredSuccessCount = (activeUnitCount_ + nextAdditionalActiveUnitCount_) * snapshotEpochCount - nextAdditionalActiveUnitCount_;\n        // #endregion\n\n        // #region calculate fail count\n\n        // When unit send min proof per one epoch, it's a one success. successCount is a number of success for all units in the snapshot period\n        // if successCount is less than requiredSuccessCount, then some units didn't send min proof per few Epochs\n        uint256 snapshotTotalFailCount = 0;\n        if (successesInTargetPeriod < requiredSuccessCount) {\n            // snapshotTotalFailCount is a number of fails for all units in the snapshot period\n            snapshotTotalFailCount = requiredSuccessCount - successesInTargetPeriod;\n            totalFailCount += snapshotTotalFailCount;\n        }\n\n        // if totalFailCount_ is more than maxFailCount, then CC is failed\n        if (totalFailCount >= maxFailCount) {\n            totalFailCount = maxFailCount;\n            uint256 restFailCount = maxFailCount - prevFailCount;\n            newStatus = ICapacity.CCStatus.Failed;\n\n            if (failsInFirstTargetedEpoch >= restFailCount) {\n                snapshotCache.current.failedEpoch = lastSnapshotEpoch + 1;\n            } else {\n                uint256 newActiveUnitCount = activeUnitCount_ + nextAdditionalActiveUnitCount_;\n\n                // numberOfFillFailedEpoch is a number of epochs when units not send proofs\n                uint256 numberOfFillFailedEpoch = 1;\n                restFailCount -= failsInFirstTargetedEpoch;\n\n                // TOOD: add currentSuccessCount to calculation\n                numberOfFillFailedEpoch += restFailCount / newActiveUnitCount;\n                uint256 remainingFailedUnitsInLastEpoch = restFailCount % newActiveUnitCount;\n\n                // Math.ceil(numberOfFillFailedEpoch)\n                // if remainingFailedUnitsInLastEpoch is not zero, then we should add one to numberOfFillFailedEpoch becouse the last epoch is not full\n                if (remainingFailedUnitsInLastEpoch != 0) {\n                    numberOfFillFailedEpoch += 1;\n                }\n\n                snapshotCache.current.failedEpoch = lastSnapshotEpoch + numberOfFillFailedEpoch;\n            }\n        }\n\n        snapshotCache.current.totalFailCount = totalFailCount;\n        // #endregion\n\n        // #region update activeUnitCount\n        // when unit return from deal, unit need to wait one epoch before it will be active\n        // nextAdditionalActiveUnitCount is a number of units that will be active in the next epoch\n        uint256 nextAdditionalActiveUnitCount = snapshotCache.current.nextAdditionalActiveUnitCount;\n\n        // update activeUnitCount if it's needed\n        if (nextAdditionalActiveUnitCount > 0) {\n            snapshotCache.current.activeUnitCount += nextAdditionalActiveUnitCount;\n            snapshotCache.current.nextAdditionalActiveUnitCount = 0;\n        }\n\n        // #endregion\n\n        // #region update status\n        if (newStatus != ICapacity.CCStatus.Active) {\n            snapshotCache.current.activeUnitCount = 0;\n            snapshotCache.current.status = newStatus;\n        }\n        // #endregion\n\n        // #region update progress\n        snapshotCache.current.snapshotEpoch = snapshotEpoch;\n        snapshotCache.current.currentSuccessCount = 0;\n        // #endregion\n\n        return newStatus;\n    }\n\n    function _postCommitCommitmentSnapshot(\n        bytes32 commitmentId,\n        ICapacity.Commitment storage cc,\n        Snapshot.Cache memory snapshotCache\n    ) internal {\n        if (snapshotCache.initial.status != snapshotCache.current.status) {\n            uint256 initialActiveUnitCount_ =\n                snapshotCache.initial.activeUnitCount + snapshotCache.initial.nextAdditionalActiveUnitCount;\n\n            if (snapshotCache.current.status == ICapacity.CCStatus.Failed) {\n                emit ICapacity.CommitmentFailed(commitmentId, snapshotCache.current.failedEpoch);\n\n                LibCapacityConst.setActiveUnitCount(LibCapacityConst.activeUnitCount() - initialActiveUnitCount_);\n            } else if (snapshotCache.current.status == ICapacity.CCStatus.Inactive) {\n                LibCapacityConst.setActiveUnitCount(LibCapacityConst.activeUnitCount() - initialActiveUnitCount_);\n            }\n        }\n\n        snapshotCache.save(cc);\n    }\n\n    function _commitUnitSnapshot(\n        ICapacity.UnitInfo storage unitInfo,\n        bytes32 commitmentId,\n        uint256 currentEpoch,\n        uint256 expiredEpoch,\n        uint256 failedEpoch\n    ) internal {\n        CommitmentStorage storage s = store();\n        ICapacity.Commitment storage cc = s.commitments[commitmentId];\n        uint256 snapshotEpoch = currentEpoch - 1;\n\n        // #region verify args\n        // if unit is inactive, then no need to do anything because it's means that unit is in deal\n        if (unitInfo.isInactive) {\n            return;\n        }\n\n        // if snapshotEpoch is more than expiredEpoch, then we should use expiredEpoch because it means that the commitment is expired before we start making a snapshot\n        uint256 lastWorkingEpoch = expiredEpoch - 1;\n        if (snapshotEpoch > lastWorkingEpoch) {\n            snapshotEpoch = lastWorkingEpoch;\n        }\n\n        // if failedEpoch is more than 0 and snapshotEpoch is more than failedEpoch, then we should use failedEpoch because it means that the commitment is failed before we start making a snapshot\n        if (failedEpoch != 0 && snapshotEpoch > failedEpoch) {\n            snapshotEpoch = failedEpoch;\n        }\n\n        // if lastMinProofsEpoch is zero then we should use startEpoch - 1 because (startEpoch - 1) is the first epoch snapshot\n        uint256 lastSnapshotEpoch = unitInfo.lastSnapshotEpoch;\n        if (lastSnapshotEpoch == 0) {\n            lastSnapshotEpoch = cc.info.startEpoch - 1;\n        }\n\n        // if snapshotEpoch is less or equal to lastSnapshotEpoch, then we should return false because it means that we already made a snapshot for this epoch\n        if (snapshotEpoch <= lastSnapshotEpoch) {\n            return;\n        }\n        // #endregion\n\n        unitInfo.lastSnapshotEpoch = snapshotEpoch;\n\n        ICapacity.RewardInfo storage rewardInfo = s.rewardInfoByEpoch[snapshotEpoch];\n\n        // #region calculate reward for the last epoch snapshot\n        uint256 nextEpochAfterLastSnapshot = lastSnapshotEpoch + 1;\n        uint256 lastProofCount = unitInfo.proofCountByEpoch[nextEpochAfterLastSnapshot];\n        rewardInfo = s.rewardInfoByEpoch[nextEpochAfterLastSnapshot];\n        if (lastProofCount < rewardInfo.minProofsPerEpoch) {\n            return;\n        }\n\n        uint256 totalSuccessProofs = rewardInfo.totalSuccessProofs;\n        if (totalSuccessProofs == 0) {\n            return;\n        }\n\n        uint256 reward =\n            (LibCapacityConst.getRewardPool(nextEpochAfterLastSnapshot) * lastProofCount) / rewardInfo.totalSuccessProofs;\n\n        if (reward > 0) {\n            cc.vesting.add(commitmentId, reward, snapshotEpoch, LibCapacityConst.vestingPeriodDuration(), LibCapacityConst.vestingPeriodCount());\n        }\n\n        delete unitInfo.proofCountByEpoch[nextEpochAfterLastSnapshot];\n        // #endregion\n    }\n\n    function _getOrSaveRewardPool(uint256 epoch) internal returns (ICapacity.RewardInfo storage rewardInfo) {\n        CommitmentStorage storage s = store();\n        rewardInfo = s.rewardInfoByEpoch[epoch];\n\n        if (rewardInfo.minProofsPerEpoch != 0) {\n            return rewardInfo;\n        }\n\n        rewardInfo.minProofsPerEpoch = LibCapacityConst.minProofsPerEpoch();\n        rewardInfo.maxProofsPerEpoch = LibCapacityConst.maxProofsPerEpoch();\n        rewardInfo.totalSuccessProofs = 0;\n    }\n\n    function onUnitMovedToDeal(bytes32 commitmentId, bytes32 unitId, uint256 pricePerCuPerEpoch) internal {\n        CommitmentStorage storage s = store();\n\n        uint256 currentEpoch_ = LibEpochController.currentEpoch();\n\n        ICapacity.Commitment storage cc = s.commitments[commitmentId];\n        IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(cc.info.peerId);\n        ICapacity.UnitInfo storage unitInfo = cc.unitInfoById[unitId];\n\n        uint256 expiredEpoch = _expiredEpoch(cc);\n\n        // #region commit snapshot for unit and commitment\n        Snapshot.Cache memory snapshotCache = Snapshot.init(cc);\n        ICapacity.CCStatus status = _preCommitCommitmentSnapshot(cc, snapshotCache, peer, currentEpoch_, expiredEpoch);\n        _postCommitCommitmentSnapshot(commitmentId, cc, snapshotCache);\n        if (status != ICapacity.CCStatus.Active) {\n            revert ICapacity.CapacityCommitmentIsNotActive(status);\n        }\n\n        _commitUnitSnapshot(unitInfo, commitmentId, currentEpoch_, expiredEpoch, snapshotCache.current.failedEpoch);\n        // #endregion\n\n\n        unitInfo.isInactive = true;\n\n        // lastSnapshotEpoch can be equal to currentEpoch only if the unit exited a deal during this epoch\n        if (unitInfo.lastSnapshotEpoch == currentEpoch_) {\n            // compute unit just exited a deal in this epoch, it is not counted as active until next epoch\n            cc.progress.nextAdditionalActiveUnitCount--;\n        } else {\n            // compute unit is fully active\n            cc.progress.activeUnitCount--;\n            LibCapacityConst.setActiveUnitCount(LibCapacityConst.activeUnitCount() - 1);\n        }\n\n        uint256 defaultBaseReward = LibCapacityConst.usdTargetRevenuePerEpoch();\n        uint256 actualBaseReward = pricePerCuPerEpoch;\n        uint256 dealStakerReward = Math.min(defaultBaseReward, actualBaseReward) * cc.info.rewardDelegatorRate / PRECISION;\n\n        cc.dealRewards.addEntity(unitId, dealStakerReward, currentEpoch_);\n        emit ICapacity.CommitmentStatsUpdated(\n            commitmentId,\n            cc.progress.totalFailCount,\n            cc.finish.exitedUnitCount,\n            cc.progress.activeUnitCount,\n            cc.progress.nextAdditionalActiveUnitCount,\n            currentEpoch_ - 1\n        );\n        emit ICapacity.UnitDeactivated(commitmentId, unitId);\n    }\n\n    function onUnitReturnedFromDeal(bytes32 commitmentId, bytes32 unitId) internal {\n        CommitmentStorage storage s = store();\n\n        // #region init and verify variables\n        uint256 currentEpoch = LibEpochController.currentEpoch();\n        uint256 startEpoch = currentEpoch + 1;\n        uint256 prevEpoch = currentEpoch - 1;\n\n        ICapacity.Commitment storage cc = s.commitments[commitmentId];\n        IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(cc.info.peerId);\n        ICapacity.UnitInfo storage unitInfo = cc.unitInfoById[unitId];\n\n        uint256 expiredEpoch = _expiredEpoch(cc);\n        // #endregion\n\n        // #region commit snapshot for commitment\n        Snapshot.Cache memory snapshotCache = Snapshot.init(cc);\n        ICapacity.CCStatus status = _preCommitCommitmentSnapshot(cc, snapshotCache, peer, currentEpoch, expiredEpoch);\n        _postCommitCommitmentSnapshot(commitmentId, cc, snapshotCache);\n        // #endregion\n\n        // #region activate unit\n        unitInfo.isInactive = false;\n        unitInfo.lastSnapshotEpoch = currentEpoch;\n\n        emit ICapacity.UnitActivated(commitmentId, unitId, startEpoch);\n        // #endregion\n\n        // if status is not active, then we don't need to update activeUnitCount\n        if (status == ICapacity.CCStatus.Inactive || status == ICapacity.CCStatus.Failed) {\n            return;\n        }\n\n        // add one active unit to global activeUnitCount and commitment activeUnitCount\n        cc.progress.nextAdditionalActiveUnitCount += 1;\n        LibCapacityConst.setActiveUnitCount(LibCapacityConst.activeUnitCount() + 1);\n        cc.dealRewards.removeEntity(unitId, currentEpoch);\n\n        LibBaseOffer.setStartEpoch(unitId, startEpoch);\n\n        // we put here prevEpoch because commit snapshot was made for the previous epoch\n        emit ICapacity.CommitmentStatsUpdated(\n            commitmentId,\n            cc.progress.totalFailCount,\n            cc.finish.exitedUnitCount,\n            cc.progress.activeUnitCount,\n            cc.progress.nextAdditionalActiveUnitCount,\n            prevEpoch\n        );\n    }\n\n    function getCommitment(bytes32 commitmentId) internal view returns (ICapacity.CommitmentView memory) {\n        CommitmentStorage storage s = store();\n        ICapacity.Commitment storage cc = s.commitments[commitmentId];\n\n        require(cc.info.peerId != bytes32(0x00), \"Capacity commitment doesn't exist\");\n\n        uint256 currentEpoch_ = LibEpochController.currentEpoch();\n        uint256 expiredEpoch = _expiredEpoch(cc);\n        bytes32 peerId = cc.info.peerId;\n\n        IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(peerId);\n\n        Snapshot.Cache memory snapshotCache = Snapshot.init(cc);\n        ICapacity.CCStatus status = _preCommitCommitmentSnapshot(cc, snapshotCache, peer, currentEpoch_, expiredEpoch);\n\n        return ICapacity.CommitmentView({\n            status: status,\n            peerId: cc.info.peerId,\n            collateralPerUnit: cc.info.collateralPerUnit,\n            unitCount: peer.unitCount,\n            startEpoch: cc.info.startEpoch,\n            endEpoch: cc.info.startEpoch + cc.info.duration,\n            rewardDelegatorRate: cc.info.rewardDelegatorRate,\n            delegator: cc.info.delegator,\n            totalFailCount: snapshotCache.current.totalFailCount,\n            failedEpoch: snapshotCache.current.failedEpoch,\n            exitedUnitCount: cc.finish.exitedUnitCount\n        });\n    }\n\n    function _withdrawCollateral(ICapacity.Commitment storage cc, uint256 unitCount, bytes32 commitmentId) internal {\n        if (cc.finish.collateralWithdrawn) {\n            return;\n        }\n\n        cc.finish.collateralWithdrawn = true;\n\n        address payable delegator = payable(cc.info.delegator);\n        uint256 collateralPerUnit_ = cc.info.collateralPerUnit;\n        uint256 totalCollateral = collateralPerUnit_ * unitCount;\n\n        uint256 totalSlashedCollateral = cc.progress.totalFailCount * collateralPerUnit_ * LibCapacityConst.slashingRate() / PRECISION;\n\n        uint256 collateralToReturn = 0;\n        uint256 collateralToSlash = 0;\n\n        if (totalCollateral < totalSlashedCollateral) {\n            collateralToReturn = 0;\n            collateralToSlash = totalCollateral;\n        } else {\n            collateralToReturn = totalCollateral - totalSlashedCollateral;\n            collateralToSlash = totalSlashedCollateral;\n        }\n\n        delegator.sendNativeOrWrapped(collateralToReturn);\n        payable(LibDiamond.contractOwner()).sendNativeOrWrapped(collateralToSlash);\n\n        emit ICapacity.CollateralWithdrawn(\n            commitmentId,\n            collateralToReturn,\n            collateralToSlash\n        );\n    }\n}\n"},"src/lib/LibCapacityConst.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {PRECISION} from \"src/utils/Common.sol\";\nimport {LibEpochController} from \"src/lib/LibEpochController.sol\";\nimport {LibOraclePrice} from \"src/lib/LibOraclePrice.sol\";\n\nstruct CommitmentConst {\n    uint256 minDuration;\n    uint256 maxDuration;\n    uint256 minCUPerCommitment;\n    uint256 maxCUPerCommitment;\n    uint256 usdCollateralPerUnit;\n    uint256 fltCollateralPerUnit;\n    uint256 slashingRate;\n    uint256 withdrawEpochsAfterFailed;\n    uint256 maxFailedRatio;\n}\n\nstruct ProofConst {\n    uint256 minProofsPerEpoch;\n    uint256 maxProofsPerEpoch;\n    bytes32 difficulty;\n    bytes32 nextDifficulty;\n    uint256 difficultyChangeEpoch;\n}\n\nstruct RewardConst {\n    uint256 usdTargetRevenuePerEpoch;\n    uint256 minRewardPerEpoch;\n    uint256 maxRewardPerEpoch;\n    uint256 vestingPeriodDuration;\n    uint256 vestingPeriodCount;\n    RewardPoolPerEpoch[] rewardPoolPerEpochs;\n}\n\nstruct CapacityConstStorage {\n    address randomXProxy;\n    uint256 activeUnitCount;\n    CommitmentConst commitment;\n    ProofConst proof;\n    RewardConst reward;\n    address oracle;\n}\n\nstruct RewardPoolPerEpoch {\n    uint256 epoch;\n    uint256 value;\n}\n\n\nlibrary LibCapacityConst {\n    uint256 internal constant _REWARD_POOL_SHRINK_RATE = PRECISION / 10 * 9; // 0.9 = 90%\n    uint256 internal constant _REWARD_POOL_GROWTH_RATE = PRECISION + PRECISION / 10; // 1.1 = 110%\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.capacity.storage.v1.const\")) - 1);\n\n    function store() internal pure returns (CapacityConstStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    // fltPrice in usd/flt units\n    function _convertUsdToFlt(uint256 usdAmount, uint256 _fltPrice) internal pure returns (uint256) {\n        return usdAmount * PRECISION / _fltPrice * 1e18 / PRECISION;\n    }\n\n    // usd/flt units\n    function fltPrice() internal view returns (uint256) {\n        return LibOraclePrice.lastSetPrice();\n    }\n\n    // usd/flt units\n    function fltPriceAtEpoch(uint256 epoch) internal view returns (uint256) {\n        // get last timestamp still IN epoch\n        uint256 epochTimestamp = LibEpochController.epochTimestamp(epoch + 1) - 1;\n        return LibOraclePrice.getPriceAtTimestamp(epochTimestamp);\n    }\n\n    // flt/usd units\n    function meanRevFltPrice(uint256 fromEpoch, uint256 toEpoch) internal view returns (uint256) {\n        // start of the fromEpoch\n        uint256 fromTimestamp = 0;\n        uint256 fromEpochTimestamp = LibEpochController.epochTimestamp(fromEpoch);\n        uint256 priceInterval = LibOraclePrice.priceInterval();\n\n        if (fromEpochTimestamp > priceInterval) {\n            fromTimestamp = fromEpochTimestamp - priceInterval;\n        }\n        if (fromTimestamp < LibOraclePrice.store().firstTimestamp) {\n            fromTimestamp = LibOraclePrice.store().firstTimestamp;\n        }\n        // end of the toEpoch\n        uint256 toTimestamp = LibEpochController.epochTimestamp(toEpoch + 1) - priceInterval;\n        return LibOraclePrice.getMeanRevPriceBetweenTimestamps(fromTimestamp, toTimestamp);\n    }\n\n    function fltCollateralPerUnit() internal view returns (uint256) {\n        return store().commitment.fltCollateralPerUnit;\n    }\n\n    function usdCollateralPerUnit() internal view returns (uint256) {\n        return store().commitment.usdCollateralPerUnit;\n    }\n\n    function usdTargetRevenuePerEpoch() internal view returns (uint256) {\n        return store().reward.usdTargetRevenuePerEpoch;\n    }\n\n    function minDuration() internal view returns (uint256) {\n        return store().commitment.minDuration;\n    }\n\n    function maxDuration() internal view returns (uint256) {\n        return store().commitment.maxDuration;\n    }\n\n    function minCUPerCommitment() internal view returns (uint256) {\n        return store().commitment.minCUPerCommitment;\n    }\n\n    function maxCUPerCommitment() internal view returns (uint256) {\n        return store().commitment.maxCUPerCommitment;\n    }\n\n    function minRewardPerEpoch() internal view returns (uint256) {\n        return store().reward.minRewardPerEpoch;\n    }\n\n    function maxRewardPerEpoch() internal view returns (uint256) {\n        return store().reward.maxRewardPerEpoch;\n    }\n\n    function vestingPeriodDuration() internal view returns (uint256) {\n        return store().reward.vestingPeriodDuration;\n    }\n\n    function vestingPeriodCount() internal view returns (uint256) {\n        return store().reward.vestingPeriodCount;\n    }\n\n    function slashingRate() internal view returns (uint256) {\n        return store().commitment.slashingRate;\n    }\n\n    function minProofsPerEpoch() internal view returns (uint256) {\n        return store().proof.minProofsPerEpoch;\n    }\n\n    function maxProofsPerEpoch() internal view returns (uint256) {\n        return store().proof.maxProofsPerEpoch;\n    }\n\n    function withdrawEpochsAfterFailed() internal view returns (uint256) {\n        return store().commitment.withdrawEpochsAfterFailed;\n    }\n\n    function maxFailedRatio() internal view returns (uint256) {\n        return store().commitment.maxFailedRatio;\n    }\n\n    function activeUnitCount() internal view returns (uint256) {\n        return store().activeUnitCount;\n    }\n\n    function difficulty() internal view returns (bytes32) {\n        CapacityConstStorage storage constantsStorage = store();\n        if (LibEpochController.currentEpoch() >= constantsStorage.proof.difficultyChangeEpoch) {\n            return constantsStorage.proof.nextDifficulty;\n        }\n\n        return store().proof.difficulty;\n    }\n\n    function randomXProxy() internal view returns (address) {\n        return store().randomXProxy;\n    }\n\n    function oracle() internal view returns (address) {\n        return store().oracle;\n    }\n\n    function getRewardPool(uint256 epoch) internal view returns (uint256) {\n        CapacityConstStorage storage constantsStorage = store();\n\n        uint256 length = constantsStorage.reward.rewardPoolPerEpochs.length;\n        uint256 low = 0;\n        uint256 high = length - 1;\n\n        uint256 value = 0;\n        while (low <= high) {\n            uint256 mid = (low + high) / 2;\n            RewardPoolPerEpoch storage rewardPool = constantsStorage.reward.rewardPoolPerEpochs[mid];\n            uint256 rewardPoolEpoch = rewardPool.epoch;\n            if (epoch > rewardPoolEpoch) {\n                value = rewardPool.value;\n                low = mid + 1;\n            } else if (epoch < rewardPoolEpoch) {\n                high = mid - 1;\n            } else {\n                return rewardPool.value;\n            }\n        }\n\n        return value;\n    }\n\n    function setActiveUnitCount(uint256 activeUnitCount_) internal {\n        CapacityConstStorage storage constantsStorage = store();\n\n        constantsStorage.activeUnitCount = activeUnitCount_;\n        _setRewardPool(LibCapacityConst.fltPrice(), activeUnitCount_);\n    }\n\n    function _setRewardPool(uint256 fltPrice_, uint256 activeUnitCount_) internal {\n        CapacityConstStorage storage constantsStorage = store();\n        uint256 currentEpoch_ = LibEpochController.currentEpoch();\n\n        // load last reward pool\n        uint256 length = constantsStorage.reward.rewardPoolPerEpochs.length;\n\n        if (activeUnitCount_ <= 0) {\n            return;\n        }\n\n        uint256 lastRewardPoolValue;\n        uint256 lastRewardPoolEpoch;\n\n        RewardPoolPerEpoch storage lastRewardPool = constantsStorage.reward.rewardPoolPerEpochs[length - 1];\n        lastRewardPoolEpoch = lastRewardPool.epoch;\n\n        if (currentEpoch_ == lastRewardPool.epoch) {\n            if (length < 2) {\n                return;\n            }\n\n            lastRewardPoolValue = constantsStorage.reward.rewardPoolPerEpochs[length - 2].value;\n        } else {\n            lastRewardPoolValue = lastRewardPool.value;\n        }\n\n        /* [ usd * 1e7 / cu ] = [ flt * 1e18 ] * [ usd * 1e7 / flt ] / [ cu ] / [ 1e18 ] */\n        uint256 currentTarget = lastRewardPoolValue * fltPrice_ / activeUnitCount_ / 1 ether;\n\n        // calculate new reward pool\n        uint256 newRewardPool;\n        if (currentTarget > constantsStorage.reward.usdTargetRevenuePerEpoch) {\n            newRewardPool = lastRewardPoolValue * _REWARD_POOL_SHRINK_RATE / PRECISION;\n        } else {\n            newRewardPool = lastRewardPoolValue * _REWARD_POOL_GROWTH_RATE / PRECISION;\n        }\n\n        uint256 minRewardPerEpoch_ = constantsStorage.reward.minRewardPerEpoch;\n        uint256 maxRewardPerEpoch_ = constantsStorage.reward.maxRewardPerEpoch;\n        if (newRewardPool < minRewardPerEpoch_) {\n            newRewardPool = minRewardPerEpoch_;\n        }\n        if (newRewardPool > maxRewardPerEpoch_) {\n            newRewardPool = maxRewardPerEpoch_;\n        }\n\n        // save new reward pool\n        if (currentEpoch_ == lastRewardPoolEpoch) {\n            constantsStorage.reward.rewardPoolPerEpochs[length - 1].value = newRewardPool;\n        } else {\n            constantsStorage.reward.rewardPoolPerEpochs.push(\n                RewardPoolPerEpoch({epoch: currentEpoch_, value: newRewardPool})\n            );\n        }\n    }\n}\n"},"src/lib/LibDiamond.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport {IDiamondCut} from \"src/interfaces/IDiamondCut.sol\";\nimport {IERC173} from \"src/interfaces/IERC173.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    // 32 bytes keccak hash of a string to use as a diamond storage location.\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // assigns struct storage slot to the storage position\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit IERC173.OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"},"src/lib/LibEpochController.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nstruct EpochControllerStorage {\n    uint256 initTimestamp;\n    uint256 epochDuration;\n}\n\nlibrary LibEpochController {\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.core.storage.v1.epochController\")) - 1);\n\n    function store() internal pure returns (EpochControllerStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    function currentEpoch() internal view returns (uint256) {\n        EpochControllerStorage storage epochControllerStorage = store();\n        return 1 + (block.timestamp - epochControllerStorage.initTimestamp) / epochControllerStorage.epochDuration;\n    }\n\n    function epochTimestamp(uint256 epoch) internal view returns (uint256) {\n        EpochControllerStorage storage s = LibEpochController.store();\n        return s.initTimestamp + s.epochDuration * (epoch - 1);\n    }\n}\n"},"src/lib/LibGlobalConst.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nstruct GlobalConstStorage {\n    uint256 minDealDepositedEpochs;\n    uint256 minDealRematchingEpochs;\n    uint256 minProtocolVersion;\n    uint256 maxProtocolVersion;\n    uint256 maxUnitCountPerProvider;\n\n    mapping(address => bool) paymentTokenWhitelist;\n}\n\nlibrary LibGlobalConst {\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.core.storage.v1.globalConst\")) - 1);\n\n    function store() internal pure returns (GlobalConstStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    function minDealDepositedEpochs() internal view returns (uint256) {\n        return store().minDealDepositedEpochs;\n    }\n\n    function minDealRematchingEpochs() internal view returns (uint256) {\n        return store().minDealRematchingEpochs;\n    }\n\n    function minProtocolVersion() internal view returns (uint256) {\n        return store().minProtocolVersion;\n    }\n\n    function maxProtocolVersion() internal view returns (uint256) {\n        return store().maxProtocolVersion;\n    }\n\n    function maxUnitCountPerProvider() internal view returns (uint256) {\n        return store().maxUnitCountPerProvider;\n    }\n\n    function addPaymentTokenToWhitelist(address paymentToken) internal {\n        require(paymentToken != address(0), \"Zero token address is not allowed\");\n        store().paymentTokenWhitelist[paymentToken] = true;\n    }\n\n    function removePaymentTokenFromWhitelist(address paymentToken) internal {\n        delete store().paymentTokenWhitelist[paymentToken];\n    }\n\n    function isPaymentTokenAllowed(address paymentToken) internal view returns (bool) {\n        return store().paymentTokenWhitelist[paymentToken];\n    }\n}\n"},"src/lib/LibOffer.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {IBaseOffer} from \"src/core/interfaces/IBaseOffer.sol\";\nimport {IOffer} from \"src/core/interfaces/IOffer.sol\";\nimport {LibBaseOffer, OfferStorage} from \"src/lib/LibBaseOffer.sol\";\nimport {LibCapacity} from \"src/lib/LibCapacity.sol\";\nimport {LibDiamond} from \"src/lib/LibDiamond.sol\";\nimport {LibGlobalConst} from \"src/lib/LibGlobalConst.sol\";\nimport {IDeal} from \"src/deal/v1/interfaces/IDeal.sol\";\nimport {IWorkerManager} from \"src/deal/v1/interfaces/IWorkerManager.sol\";\nimport {CIDV1} from \"src/utils/Common.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {OwnableUpgradableDiamond} from \"src/utils/OwnableUpgradableDiamond.sol\";\n\nlibrary LibOffer {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    function store() internal pure returns (OfferStorage storage s) {\n        return LibBaseOffer.store();\n    }\n\n    // mainly for IOffer impl\n    function registerMarketOffer(\n        uint256 minPricePerCuPerEpoch,\n        address paymentToken,\n        CIDV1[] calldata effectors,\n        IOffer.RegisterComputePeer[] calldata peers,\n        uint256 minProtocolVersion,\n        uint256 maxProtocolVersion\n    ) internal returns (bytes32) {\n        require(minProtocolVersion == LibBaseOffer.PROTOCOL_V1 && maxProtocolVersion == LibBaseOffer.PROTOCOL_V1, \"Offer: protocol version mismatch, required v1\");\n\n        bytes32 offerId = LibBaseOffer.registerBaseOffer(paymentToken, LibBaseOffer.PROTOCOL_V1, LibBaseOffer.PROTOCOL_V1);\n\n        // set V1 - only data\n        addEffector(offerId, effectors);\n        changeMinPricePerCuPerEpoch(offerId, minPricePerCuPerEpoch);\n\n        addComputePeers(offerId, peers);\n\n        return offerId;\n    }\n\n    // can be common\n    function removeOffer(bytes32 offerId) internal {\n        // effectors data is automatically cleaned\n        LibBaseOffer.removeBaseOffer(offerId);\n    }\n\n    // v1 only\n    function addComputePeers(bytes32 offerId, IOffer.RegisterComputePeer[] calldata peers) internal {\n        for (uint256 peerIndex = 0; peerIndex < peers.length; ++peerIndex) {\n            IOffer.RegisterComputePeer calldata peer = peers[peerIndex];\n            LibBaseOffer.registerBaseComputePeer(offerId, peer.peerId, peer.owner, peer.unitIds);\n        }\n    }\n\n    // can be common\n    function removeComputePeer(bytes32 peerId) internal {\n        LibBaseOffer.removeBaseComputePeer(peerId);\n    }\n\n    // can be common\n    function addComputeUnits(bytes32 peerId, bytes32[] calldata unitIds) internal {\n        LibBaseOffer.registerBaseComputeUnits(peerId, unitIds);\n    }\n\n    // can be common\n    function removeComputeUnit(bytes32 unitId) internal {\n        LibBaseOffer.removeBaseComputeUnit(unitId);\n    }\n\n    // Change offer\n    // v1 only\n    function changeMinPricePerCuPerEpoch(bytes32 offerId, uint256 newMinPricePerCuPerEpoch) internal {\n        OfferStorage storage offerStorage = store();\n        IOffer.Offer storage offer = offerStorage.offers[offerId];\n\n        require(offer.provider == msg.sender, \"Offer: only provider can call this method\");\n        require(newMinPricePerCuPerEpoch > 0, \"Min price per CU per epoch should be greater than 0\");\n\n        offer.minPricePerCuPerEpoch = newMinPricePerCuPerEpoch;\n\n        emit IOffer.MinPricePerCuPerEpochUpdated(offerId, newMinPricePerCuPerEpoch);\n    }\n\n    // v1 only\n    function addEffector(bytes32 offerId, CIDV1[] calldata newEffectors) internal {\n        OfferStorage storage offerStorage = store();\n        IOffer.Offer storage offer = offerStorage.offers[offerId];\n\n        require(offer.provider == msg.sender, \"Offer: only provider can call this method\");\n\n        for (uint256 i = 0; i < newEffectors.length; i++) {\n            CIDV1 calldata effectorCID = newEffectors[i];\n            bytes32 effectorHash = _hashEffectorCID(effectorCID);\n\n            require(!offerStorage.effectorsByOfferId[offerId].hasEffector[effectorHash], \"Effector already exists\");\n\n            offerStorage.effectorsByOfferId[offerId].hasEffector[effectorHash] = true;\n\n            emit IOffer.EffectorAdded(offerId, effectorCID);\n        }\n    }\n\n    // v1 only\n    function removeEffector(bytes32 offerId, CIDV1[] calldata effectors) internal {\n        OfferStorage storage offerStorage = store();\n        IOffer.Offer storage offer = offerStorage.offers[offerId];\n\n        require(offer.provider == msg.sender, \"Offer: only provider can call this method\");\n\n        for (uint256 i = 0; i < effectors.length; i++) {\n            CIDV1 calldata effectorCID = effectors[i];\n            bytes32 effectorHash = _hashEffectorCID(effectorCID);\n\n            require(offerStorage.effectorsByOfferId[offerId].hasEffector[effectorHash], \"Effector doesn't exist\");\n\n            offerStorage.effectorsByOfferId[offerId].hasEffector[effectorHash] = false;\n\n            emit IOffer.EffectorRemoved(offerId, effectorCID);\n        }\n    }\n\n    // Effector info\n    // v1 only\n    function setEffectorInfo(CIDV1 calldata id, string calldata description, CIDV1 calldata metadata)\n    internal\n    {\n        LibDiamond.enforceIsContractOwner();\n        OfferStorage storage offerStorage = store();\n        require(bytes(description).length > 0, \"Description should be not empty\");\n\n        bytes32 effectorHash = _hashEffectorCID(id);\n        IOffer.EffectorInfo storage effectorInfo = offerStorage.effectorInfoById[effectorHash];\n\n        effectorInfo.description = description;\n        effectorInfo.metadata = metadata;\n\n        emit IOffer.EffectorInfoSet(id, description, metadata);\n    }\n\n    function getEffectorInfo(CIDV1 calldata id) internal view returns (IOffer.EffectorInfo memory) {\n        return store().effectorInfoById[_hashEffectorCID(id)];\n    }\n\n    // v1 only\n    function removeEffectorInfo(CIDV1 calldata id) internal {\n        LibDiamond.enforceIsContractOwner();\n        OfferStorage storage offerStorage = store();\n\n        bytes32 effectorHash = _hashEffectorCID(id);\n        IOffer.EffectorInfo storage effectorInfo = offerStorage.effectorInfoById[effectorHash];\n\n        require(bytes(effectorInfo.description).length > 0, \"Effector info doesn't exist\");\n\n        delete offerStorage.effectorInfoById[effectorHash];\n\n        emit IOffer.EffectorInfoRemoved(id);\n    }\n\n    function getOffer(bytes32 offerId) internal view returns (IOffer.Offer memory) {\n        IOffer.Offer storage offer = store().offers[offerId];\n        require(offer.provider != address(0x00), \"Offer: offer doesn't exist\");\n\n        return offer;\n    }\n\n    function _getOffer(bytes32 offerId) internal view returns (IOffer.Offer storage) {\n        return store().offers[offerId];\n    }\n\n    function _hasOfferEffectors(bytes32 offerId, CIDV1[] memory effectors) internal view returns (bool) {\n        OfferStorage storage offerStorage = store();\n\n        for (uint256 i = 0; i < effectors.length; i++) {\n            bytes32 effectorHash = _hashEffectorCID(effectors[i]);\n\n            if (!offerStorage.effectorsByOfferId[offerId].hasEffector[effectorHash]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _hashEffectorCID(CIDV1 memory effectorCID) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(effectorCID.prefixes, effectorCID.hash));\n    }\n\n    function cleanupV1Storage(bytes32 offerId) internal {\n        store().offers[offerId].minPricePerCuPerEpoch = 0;\n        delete store().effectorsByOfferId[offerId];\n    }\n}\n"},"src/lib/LibOfferV2.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {IBaseOffer} from \"src/core/interfaces/IBaseOffer.sol\";\nimport {IOfferV2} from \"src/core/interfaces/IOfferV2.sol\";\nimport {LibBaseOffer} from \"src/lib/LibBaseOffer.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts//utils/structs/EnumerableSet.sol\";\nimport {LibOffer} from \"src/lib/LibOffer.sol\";\n\nstruct OfferStorageV2 {\n    mapping(bytes32 offerId => IOfferV2.OfferResourcesParams) offerParamsById;\n    mapping(bytes32 peerId => IOfferV2.PeerResourceParams) peerResourcesById;\n    mapping(bytes32 resourceId => IOfferV2.ResourceDescription) resources;\n    EnumerableSet.Bytes32Set resourceIds;\n\n    EnumerableSet.Bytes32Set offers;\n    mapping(bytes32 offerId => EnumerableSet.Bytes32Set) peers;\n\n    // for future methods to register datacenters and attach them to offers\n    mapping(bytes32 => IOfferV2.Datacenter) datacenters;\n    mapping(bytes32 offerId => bytes32 datacenterId) offerDatacenterByID;\n    EnumerableSet.Bytes32Set datacenterIds;\n}\n\nlibrary LibOfferV2 {\n    uint256 constant RAM_PER_VCPU = 2 * GiB / BYTES_PER_RAM;\n    uint256 constant VCPU_PER_CU = 2;\n    uint256 constant BYTES_PER_RAM = 1 * MiB;\n    uint256 constant BYTES_PER_STORAGE = 1 * MiB;\n    uint256 constant MiB = 1024 * 1024;\n    uint256 constant GiB = 1024 * MiB;\n\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.market.storage.v2\")) - 1);\n\n    function storeV2() internal pure returns (OfferStorageV2 storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    function getResourcePrice(bytes32 offerId, bytes32 resourceId) internal view returns(uint256) {\n        IOfferV2.OfferResourcesParams storage offerResourceParams = storeV2().offerParamsById[offerId];\n\n        require(offerResourceParams.resourceIds.contains(resourceId), \"LibOfferV2: offer does not have this resource\");\n        return offerResourceParams.resourcePrices[resourceId];\n    }\n\n    function _getPeerResource(bytes32 peerId, bytes32 resourceId) internal view returns(IOfferV2.PeerResource storage) {\n        IOfferV2.PeerResourceParams storage peerResourceParams = storeV2().peerResourcesById[peerId];\n        require(peerResourceParams.resourceIds.contains(resourceId), \"LibOfferV2: peer does not have this resource\");\n\n        return peerResourceParams.resources[resourceId];\n    }\n\n    function upgradeMarketOfferToV2(\n        bytes32 offerId,\n        IOfferV2.RegisterResourcePrice[] calldata resourcePrices,\n        IOfferV2.UpgradeComputePeerV2[] calldata peers,\n        bytes32 datacenterId\n    ) internal {\n        LibOffer.cleanupV1Storage(offerId);\n        LibBaseOffer.upgradeProtocolVersion(offerId, LibBaseOffer.PROTOCOL_V2, LibBaseOffer.PROTOCOL_V2);\n        IBaseOffer.BaseOffer memory offer = LibBaseOffer.getBaseOffer(offerId);\n        require(offer.peerCount == peers.length, \"LibOfferV2: cannot upgrade offer without traversing through all peers\");\n        _registerOfferPrices(offerId, resourcePrices);\n        storeV2().offers.add(offerId);\n\n        for (uint256 peerIndex = 0; peerIndex < peers.length; peerIndex++) {\n            IOfferV2.UpgradeComputePeerV2 calldata peerToRegister = peers[peerIndex];\n            IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(peerToRegister.peerId);\n            require(peer.offerId == offerId, \"LibOfferV2: peer does not belong to the given offer\");\n            storeV2().peers[offerId].add(peerToRegister.peerId);\n\n            _registerPeerResources(peerToRegister.peerId, peerToRegister.resources);\n        }\n\n        setOfferDatacenter(offerId, datacenterId);\n    }\n\n    function registerMarketOfferV2(\n        address paymentToken,\n        IOfferV2.RegisterResourcePrice[] calldata resourcePrices,\n        IOfferV2.RegisterComputePeerV2[] calldata peers,\n        bytes32 datacenterId\n    ) internal returns (bytes32) {\n        OfferStorageV2 storage offerStorageV2 = storeV2();\n        bytes32 offerId = LibBaseOffer.registerBaseOffer(paymentToken, LibBaseOffer.PROTOCOL_V2, LibBaseOffer.PROTOCOL_V2);\n\n        offerStorageV2.offers.add(offerId);\n        emit IOfferV2.OfferV2Created(offerId, paymentToken, msg.sender, datacenterId);\n\n        _registerOfferPrices(offerId, resourcePrices);\n        registerComputePeersV2(offerId, peers);\n        setOfferDatacenter(offerId, datacenterId);\n\n        return offerId;\n    }\n\n    function registerComputePeersV2(bytes32 offerId, IOfferV2.RegisterComputePeerV2[] calldata peers) internal {\n        for (uint256 peerIndex = 0; peerIndex < peers.length; ++peerIndex) {\n            registerComputePeerV2(offerId, peers[peerIndex]);\n        }\n    }\n\n    function registerComputePeerV2(bytes32 offerId, IOfferV2.RegisterComputePeerV2 calldata peerData) internal {\n        // Peer and computeUnits are registered here\n        OfferStorageV2 storage offerStorageV2 = storeV2();\n        LibBaseOffer.registerBaseComputePeer(offerId, peerData.peerId, peerData.owner, peerData.unitIds);\n\n        offerStorageV2.peers[offerId].add(peerData.peerId);\n\n        _registerPeerResources(peerData.peerId, peerData.resources);\n    }\n\n    function _registerOfferPrices(bytes32 offerId, IOfferV2.RegisterResourcePrice[] calldata resourcePrices) internal {\n        OfferStorageV2 storage offerStorageV2 = LibOfferV2.storeV2();\n        IOfferV2.OfferResourcesParams storage offerResources = offerStorageV2.offerParamsById[offerId];\n\n        for (uint256 priceIndex = 0; priceIndex < resourcePrices.length; ++priceIndex) {\n            IOfferV2.RegisterResourcePrice calldata priceData = resourcePrices[priceIndex];\n            require(priceData.price > 0, \"LibOfferV2: cannot register 0 as price for a resource\"); // TODO we can remove this check if it is not needed\n            require(offerStorageV2.resourceIds.contains(priceData.resourceId), \"LibOfferV2: Attempt to register a resource not known to the network\");\n            offerResources.resourcePrices[priceData.resourceId] = priceData.price;\n            bool addedNewEntry = offerResources.resourceIds.add(priceData.resourceId);\n            require(addedNewEntry, \"LibOfferV2: resource was already registered in offer\");\n\n            emit IOfferV2.ResourcePriceUpdated(offerId, priceData.resourceId, priceData.price);\n        }\n    }\n\n    function _registerPeerResources(bytes32 peerId, IOfferV2.RegisterPeerResource[] calldata resources) internal {\n        OfferStorageV2 storage offerStorageV2 = LibOfferV2.storeV2();\n        IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(peerId);\n\n        IOfferV2.OfferResourcesParams storage offerResources = offerStorageV2.offerParamsById[peer.offerId];\n        IOfferV2.PeerResourceParams storage peerResources = offerStorageV2.peerResourcesById[peerId];\n\n        for (uint256 resourceIndex = 0; resourceIndex < resources.length; ++resourceIndex) {\n            IOfferV2.RegisterPeerResource calldata resource = resources[resourceIndex];\n\n            // todo check existence differently\n            require(offerResources.resourcePrices[resource.resourceId] > 0, \"LibOfferV2: attempt to register a resource to peer without a price\");\n\n            _registerPeerResource(peerId, peerResources, resource);\n        }\n\n        enforceResourceInvariants(peerId);\n    }\n\n    function changeResourcePrice(bytes32 offerId, bytes32 resourceId, uint256 newPrice) internal {\n        IOfferV2.OfferResourcesParams storage offerParams = storeV2().offerParamsById[offerId];\n\n        require(newPrice != 0, \"LibOfferV2: cannot change resource price to zero\");\n\n        // this function automatically adds new resource to offer, if it wasn't there\n        offerParams.resourceIds.add(resourceId);\n        offerParams.resourcePrices[resourceId] = newPrice;\n\n        emit IOfferV2.ResourcePriceUpdated(offerId, resourceId, newPrice);\n    }\n\n    function changeResourceMaxSupply(bytes32 peerId, bytes32 resourceId, uint256 newMaxSupply) internal {\n        IOfferV2.PeerResourceParams storage peerResourceParams = storeV2().peerResourcesById[peerId];\n        IOfferV2.PeerResource storage peerResource = peerResourceParams.resources[resourceId];\n\n        // todo check existence differently\n        require(peerResourceParams.resourceIds.contains(resourceId), \"LibOfferV2: peer resource is not registered\");\n\n        if (peerResource.maxSupply > newMaxSupply) {\n            uint256 maxSupplyDecrease = peerResource.maxSupply - newMaxSupply;\n            require(peerResource.availableSupply >= maxSupplyDecrease, \"LibOfferV2: cannot decrease peer resource supply because it is used in Deals\");\n\n            peerResource.availableSupply -= maxSupplyDecrease;\n            peerResource.maxSupply -= maxSupplyDecrease;\n        } else {\n            uint256 maxSupplyIncrease = newMaxSupply - peerResource.maxSupply;\n            peerResource.availableSupply += maxSupplyIncrease;\n            peerResource.maxSupply += maxSupplyIncrease;\n        }\n\n        enforceResourceInvariants(peerId);\n        emit IOfferV2.PeerResourceSupplyUpdated(peerId, resourceId, peerResource.availableSupply, peerResource.maxSupply);\n    }\n\n    function enforceResourceInvariants(bytes32 peerId) internal view {\n        uint256 vcpuAvailableSupply = 0;\n        uint256 vcpuMaxSupply = 0;\n        uint256 ramAvailableSupply = 0;\n        uint256 ramMaxSupply = 0;\n\n        IBaseOffer.ComputePeer storage peer = LibBaseOffer.store().peers[peerId];\n        IOfferV2.PeerResourceParams storage peerResources = storeV2().peerResourcesById[peerId];\n        uint256 peerResourcesLength = peerResources.resourceIds.length();\n        for (uint256 resourceIndex = 0; resourceIndex < peerResourcesLength; ++resourceIndex) {\n            bytes32 resourceId = peerResources.resourceIds.at(resourceIndex);\n            IOfferV2.ResourceDescription storage resourceData = storeV2().resources[resourceId];\n            IOfferV2.PeerResource storage peerResource = peerResources.resources[resourceId];\n            if (resourceData.ty == IOfferV2.ResourceType.VCPU) {\n                vcpuAvailableSupply += peerResource.availableSupply;\n                vcpuMaxSupply += peerResource.maxSupply;\n            } else if (resourceData.ty == IOfferV2.ResourceType.RAM) {\n                ramAvailableSupply += peerResource.availableSupply;\n                ramMaxSupply += peerResource.maxSupply;\n            } else {\n                continue;\n            }\n        }\n\n\n        require(vcpuAvailableSupply * RAM_PER_VCPU <= ramAvailableSupply, \"LibOfferV2: broken invariant, not enough RAM to support VCPU (available)\");\n        require(vcpuMaxSupply * RAM_PER_VCPU <= ramMaxSupply, \"LibOfferV2: broken invariant, not enough RAM to support VCPU (max)\");\n        require(vcpuMaxSupply == peer.unitCount * VCPU_PER_CU, \"LibOfferV2: broken invariant, VCPU number does not match CU count\");\n    }\n\n    function addComputeUnitsV2(bytes32 peerId, bytes32[] calldata unitIds, IOfferV2.RegisterPeerResource calldata resource) internal {\n        LibBaseOffer.registerBaseComputeUnits(peerId, unitIds);\n\n        IOfferV2.ResourceDescription storage resourceData = storeV2().resources[resource.resourceId];\n        IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(peerId);\n        IOfferV2.OfferResourcesParams storage offerResources = storeV2().offerParamsById[peer.offerId];\n\n        require(resourceData.ty == IOfferV2.ResourceType.VCPU, \"LibOfferV2: registering compute units requires adding new VCPU resources\");\n        require(resource.supply == unitIds.length * VCPU_PER_CU, \"LibOfferV2: compute units count and resource supply mismatch\");\n\n        require(offerResources.resourceIds.contains(resource.resourceId), \"LibOfferV2: attempt to register a resource to peer without a price\");\n\n        IOfferV2.PeerResourceParams storage peerResources = storeV2().peerResourcesById[peerId];\n\n        if (peerResources.resourceIds.contains(resource.resourceId)) {\n            uint256 oldSupply = _getPeerResource(peerId, resource.resourceId).maxSupply;\n            changeResourceMaxSupply(peerId, resource.resourceId, oldSupply + resource.supply);\n        } else {\n            _registerPeerResource(peerId, peerResources, resource);\n        }\n\n        enforceResourceInvariants(peerId);\n    }\n\n    function removeOfferV2(bytes32 offerId) internal {\n        OfferStorageV2 storage offerStorageV2 = storeV2();\n        LibBaseOffer.removeBaseOffer(offerId);\n\n        // no need to throw event because indexers can cleanup themselves\n        offerStorageV2.offers.remove(offerId);\n        delete offerStorageV2.peers[offerId];\n        delete offerStorageV2.offerParamsById[offerId];\n        delete offerStorageV2.offerDatacenterByID[offerId];\n    }\n\n    function removeComputePeer(bytes32 peerId) internal {\n        OfferStorageV2 storage offerStorageV2 = storeV2();\n        bytes32 offerId = LibBaseOffer.getComputePeer(peerId).offerId;\n\n        LibBaseOffer.removeBaseComputePeer(peerId);\n\n        offerStorageV2.peers[offerId].remove(peerId);\n\n        // no need to throw event because indexers can cleanup themselves\n        delete offerStorageV2.peerResourcesById[peerId];\n    }\n\n    function removeComputeUnit(bytes32 unitId, bytes32 resourceId) internal {\n        IBaseOffer.ComputeUnit memory unit = LibBaseOffer.getComputeUnit(unitId);\n        LibBaseOffer.removeBaseComputeUnit(unitId);\n        uint256 peerResourceSupply = storeV2().peerResourcesById[unit.peerId].resources[resourceId].maxSupply;\n        IOfferV2.ResourceDescription storage resourceDescription = storeV2().resources[resourceId];\n        require(peerResourceSupply >= VCPU_PER_CU, \"LibOfferV2: not enough resource in peer\");\n        require(resourceDescription.ty == IOfferV2.ResourceType.VCPU, \"LibOfferV2: required to remove a VCPU resource along with compute unit\");\n\n        changeResourceMaxSupply(unit.peerId, resourceId, peerResourceSupply - VCPU_PER_CU);\n    }\n\n    function registerResource(IOfferV2.ResourceType ty, string calldata metadata) internal returns(bytes32) {\n        OfferStorageV2 storage offerStorageV2 = storeV2();\n        bytes32 resourceId = bytes32(offerStorageV2.resourceIds.length() + 1);\n        offerStorageV2.resourceIds.add(resourceId);\n        offerStorageV2.resources[resourceId] = IOfferV2.ResourceDescription(\n            ty,\n            metadata\n        );\n\n        emit IOfferV2.ResourceCreated(resourceId, ty, metadata);\n\n        return resourceId;\n    }\n\n    function updateResourceMetadata(bytes32 resourceId, string calldata metadata) internal {\n        require(storeV2().resourceIds.contains(resourceId), \"LibOfferV2: resource does not exist in the network\");\n        storeV2().resources[resourceId].metadata = metadata;\n        emit IOfferV2.ResourceMetadataUpdated(resourceId, metadata);\n    }\n\n    // Does not check invariant VCPU/RAM\n    function _registerPeerResource(bytes32 peerId, IOfferV2.PeerResourceParams storage peerResources, IOfferV2.RegisterPeerResource calldata resource) internal {\n        peerResources.resources[resource.resourceId] = IOfferV2.PeerResource({\n            availableSupply: resource.supply,\n            maxSupply: resource.supply,\n            details: resource.details\n        });\n\n        bool addedNewEntry = peerResources.resourceIds.add(resource.resourceId);\n        require(addedNewEntry, \"LibOfferV2: peer resource was already registered\");\n        emit IOfferV2.PeerResourceRegistered(peerId, resource.resourceId, resource.supply, resource.details);\n    }\n\n    function removePeerResource(bytes32 peerId, bytes32 resourceId) internal {\n        IOfferV2.PeerResourceParams storage peerResourceParams = storeV2().peerResourcesById[peerId];\n\n        require(storeV2().resourceIds.contains(resourceId), \"LibOfferV2: resource does not exist in the network\");\n        require(peerResourceParams.resourceIds.contains(resourceId), \"LibOfferV2: peer does not have this resource\");\n\n        delete peerResourceParams.resources[resourceId];\n        peerResourceParams.resourceIds.remove(resourceId);\n\n        LibOfferV2.enforceResourceInvariants(peerId);\n        emit IOfferV2.PeerResourceRemoved(peerId, resourceId);\n    }\n\n    function registerPeerResource(bytes32 peerId, IOfferV2.RegisterPeerResource calldata resource) internal {\n        bytes32 offerId = LibBaseOffer.getComputePeer(peerId).offerId;\n        require(storeV2().offerParamsById[offerId].resourceIds.contains(resource.resourceId), \"LibOfferV2: resource is not registered in offer\");\n\n        IOfferV2.PeerResourceParams storage peerResourceParams = storeV2().peerResourcesById[peerId];\n        _registerPeerResource(peerId, peerResourceParams, resource);\n        LibOfferV2.enforceResourceInvariants(peerId);\n    }\n\n    function changeResourceDetails(bytes32 peerId, bytes32 resourceId, string calldata details) internal {\n        IOfferV2.PeerResourceParams storage peerResourceParams = storeV2().peerResourcesById[peerId];\n\n        require(storeV2().resourceIds.contains(resourceId), \"LibOfferV2: resource does not exist in the network\");\n        require(peerResourceParams.resourceIds.contains(resourceId), \"LibOfferV2: peer does not have this resource\");\n        peerResourceParams.resources[resourceId].details = details;\n        emit IOfferV2.PeerResourceDetailsUpdated(peerId, resourceId, details);\n    }\n\n    function enforceDealResourceInvariants(IOfferV2.ResourceRequirement[] calldata resources) internal view {\n        uint256 vcpuRequired = 0;\n        uint256 ramRequired = 0;\n\n        for (uint256 resourceIndex = 0; resourceIndex < resources.length; ++resourceIndex) {\n            IOfferV2.ResourceRequirement calldata resource = resources[resourceIndex];\n            IOfferV2.ResourceDescription storage resourceData = storeV2().resources[resource.resourceId];\n            if (resourceData.ty == IOfferV2.ResourceType.VCPU) {\n                vcpuRequired += resource.quantity;\n            } else if (resourceData.ty == IOfferV2.ResourceType.RAM) {\n                ramRequired += resource.quantity;\n            } else {\n                continue;\n            }\n        }\n\n        require(vcpuRequired > 0, \"LibOfferV2: deal with broken invariant: zero VCPUs requested\");\n        require(vcpuRequired % VCPU_PER_CU == 0, \"LibOfferV2: deal with broken invariant: number of VCPUs requested corresponds to a fractional number of CUs\");\n        require(vcpuRequired * RAM_PER_VCPU <= ramRequired, \"LibOfferV2: deal with broken invariant: not enough RAM requested to support requested number of VCPUs\");\n    }\n\n    function createDatacenter(IOfferV2.RegisterDatacenter calldata datacenter) internal returns(bytes32) {\n        bytes32 id = bytes32(storeV2().datacenterIds.length() + 1);\n        storeV2().datacenters[id] = IOfferV2.Datacenter(\n            id,\n            datacenter.countryCode,\n            datacenter.cityCode,\n            datacenter.index,\n            datacenter.tier,\n            datacenter.certifications\n        );\n        storeV2().datacenterIds.add(id);\n\n        emit IOfferV2.DatacenterCreated(id, datacenter.countryCode,datacenter.cityCode, datacenter.index,datacenter.tier, datacenter.certifications);\n        return id;\n    }\n\n    function updateDatacenter(bytes32 id, uint256 tier, string[] calldata certifications) internal {\n        require(storeV2().datacenterIds.contains(id), \"LibOfferV2: datacenter does not exist in the network\");\n        IOfferV2.Datacenter storage datacenter = storeV2().datacenters[id];\n        datacenter.tier = tier;\n        datacenter.certifications = certifications;\n        emit IOfferV2.DatacenterUpdated(id, tier, certifications);\n    }\n\n    function setOfferDatacenter(bytes32 offerId, bytes32 datacenterId) internal {\n        require(storeV2().datacenterIds.contains(datacenterId), \"LibOfferV2: datacenter does not exist\");\n        storeV2().offerDatacenterByID[offerId] = datacenterId;\n        // TODO: maybe do not send event if DC ID is zero?\n        emit IOfferV2.OfferDatacenterUpdated(offerId, datacenterId);\n    }\n\n    function getOfferDatacenter(bytes32 offerId) internal view returns(bytes32) {\n        return storeV2().offerDatacenterByID[offerId];\n    }\n}\n\nlibrary LibOfferV2View {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    function storeV2() internal pure returns (OfferStorageV2 storage s) {\n        s = LibOfferV2.storeV2();\n    }\n\n    function getResources() internal view returns(IOfferV2.ResourceDescriptionView[] memory) {\n        uint256 resourcesLength = storeV2().resourceIds.length();\n        IOfferV2.ResourceDescriptionView[] memory resources = new IOfferV2.ResourceDescriptionView[](resourcesLength);\n        for (uint256 resourceIndex = 0; resourceIndex < resourcesLength; resourceIndex++) {\n            bytes32 resourceId = storeV2().resourceIds.at(resourceIndex);\n            IOfferV2.ResourceDescription storage desc = storeV2().resources[resourceId];\n            resources[resourceIndex] = IOfferV2.ResourceDescriptionView({\n                id: resourceId,\n                ty: desc.ty,\n                metadata: desc.metadata\n            });\n        }\n\n        return resources;\n    }\n\n    function getResourceDescription(bytes32 resourceId) internal view returns (IOfferV2.ResourceDescription storage) {\n        OfferStorageV2 storage offerStorageV2 = storeV2();\n        require(offerStorageV2.resourceIds.contains(resourceId), \"LibOfferV2: resourceId does not exist\");\n\n        return offerStorageV2.resources[resourceId];\n    }\n\n\n    function getOffers() internal view returns(IOfferV2.OfferV2View[] memory) {\n        OfferStorageV2 storage offerV2Storage = storeV2();\n        bytes32[] memory offerIds = offerV2Storage.offers.values();\n        IOfferV2.OfferV2View[] memory offerViews = new IOfferV2.OfferV2View[](offerIds.length);\n\n        for (uint256 offerIndex; offerIndex < offerIds.length; offerIndex++) {\n            bytes32 offerId = offerIds[offerIndex];\n            offerViews[offerIndex] = getOffer(offerId);\n        }\n\n        return offerViews;\n    }\n\n    function getOffer(bytes32 offerId) internal view returns(IOfferV2.OfferV2View memory) {\n        IBaseOffer.BaseOffer memory baseOffer = LibBaseOffer.getBaseOffer(offerId);\n        return IOfferV2.OfferV2View({\n            offerId: offerId,\n            provider: baseOffer.provider,\n            paymentToken: baseOffer.paymentToken,\n        //datacenterId: storeV2().offerDatacenterByID[offerId], //todo unlock when breaking api\n            prices: getOfferPrices(offerId)\n        });\n    }\n\n    function getOfferPrices(bytes32 offerId) internal view returns(IOfferV2.OfferV2PriceView[] memory) {\n        OfferStorageV2 storage offerV2Storage = storeV2();\n        IOfferV2.OfferResourcesParams storage offerResourceParams = offerV2Storage.offerParamsById[offerId];\n        bytes32[] memory resourceIds = offerResourceParams.resourceIds.values();\n        IOfferV2.OfferV2PriceView[] memory offerPriceViews = new IOfferV2.OfferV2PriceView[](resourceIds.length);\n\n        for (uint256 resourceIndex; resourceIndex < resourceIds.length; resourceIndex++) {\n            bytes32 resourceId = resourceIds[resourceIndex];\n            uint256 price = offerResourceParams.resourcePrices[resourceId];\n            IOfferV2.ResourceDescription storage resourceData = offerV2Storage.resources[resourceId];\n\n            offerPriceViews[resourceIndex] = IOfferV2.OfferV2PriceView({\n                resourceId: resourceId,\n                ty: resourceData.ty,\n                metadata: resourceData.metadata,\n                price: price\n            });\n        }\n\n        return offerPriceViews;\n    }\n\n    function getPeers(bytes32 offerId) internal view returns(IOfferV2.PeerV2View[] memory) {\n        OfferStorageV2 storage offerV2Storage = storeV2();\n        bytes32[] memory peerIds = offerV2Storage.peers[offerId].values();\n        IOfferV2.PeerV2View[] memory peerViews = new IOfferV2.PeerV2View[](peerIds.length);\n\n        for (uint256 peerIndex = 0; peerIndex < peerIds.length; peerIndex++) {\n            bytes32 peerId = peerIds[peerIndex];\n            peerViews[peerIndex] = getPeer(peerId);\n        }\n\n        return peerViews;\n    }\n\n    function getPeer(bytes32 peerId) internal view returns(IOfferV2.PeerV2View memory) {\n        IBaseOffer.ComputePeer memory peer = LibBaseOffer.getComputePeer(peerId);\n\n        return IOfferV2.PeerV2View({\n            offerId: peer.offerId,\n            commitmentId: peer.commitmentId,\n            peerId: peerId,\n            unitIds: LibBaseOffer.getComputeUnits(peerId),\n            resources: getPeerResourcesFull(peerId)\n        });\n    }\n\n    function getPeerResourcesFull(bytes32 peerId) internal view returns(IOfferV2.PeerV2ResourceView[] memory) {\n        OfferStorageV2 storage offerV2Storage = storeV2();\n        IOfferV2.PeerResourceParams storage peerResources = offerV2Storage.peerResourcesById[peerId];\n        bytes32[] memory resourceIds = peerResources.resourceIds.values();\n        IOfferV2.PeerV2ResourceView[] memory resourceViews = new IOfferV2.PeerV2ResourceView[](resourceIds.length);\n\n        for (uint256 resourceIndex; resourceIndex < resourceIds.length; resourceIndex++) {\n            bytes32 resourceId = resourceIds[resourceIndex];\n            IOfferV2.PeerResource storage peerResource = peerResources.resources[resourceId];\n            IOfferV2.ResourceDescription storage resourceData = offerV2Storage.resources[resourceId];\n\n            resourceViews[resourceIndex] = IOfferV2.PeerV2ResourceView({\n                resourceId: resourceId,\n                ty: resourceData.ty,\n                metadata: resourceData.metadata,\n                details: peerResource.details,\n                availableSupply: peerResource.availableSupply,\n                maxSupply: peerResource.maxSupply\n            });\n        }\n\n        return resourceViews;\n    }\n\n    function getDatacenter(bytes32 id) internal view returns(IOfferV2.Datacenter memory) {\n        require(storeV2().datacenterIds.contains(id), \"LibOfferV2: datacenter does not exist\");\n        return storeV2().datacenters[id];\n    }\n\n    function getDatacenters() internal view returns(IOfferV2.Datacenter[] memory) {\n        uint256 datacentersLength = storeV2().datacenterIds.length();\n        IOfferV2.Datacenter[] memory datacenters = new IOfferV2.Datacenter[](datacentersLength);\n\n        for (uint256 datacenterIndex = 0; datacenterIndex < datacentersLength; datacenterIndex++) {\n            bytes32 id = storeV2().datacenterIds.at(datacenterIndex);\n            datacenters[datacenterIndex] = storeV2().datacenters[id];\n        }\n\n        return datacenters;\n    }\n}\n"},"src/lib/LibOraclePrice.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {PRECISION} from \"src/utils/Common.sol\";\n\nstruct OraclePriceStorage {\n    uint256 firstTimestamp;\n    uint256 priceInterval;\n    uint256[] pricesCumulative; // A/B units\n    uint256[] revPricesCumulative; // B/A units\n    uint256 lastStoredPrice; // A/B units\n}\n\nlibrary LibOraclePrice {\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.oracle.price.storage.v1\")) - 1);\n\n    function store() internal pure returns (OraclePriceStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    function normalizeTimestamp(uint256 timestamp) internal view returns (uint256) {\n        OraclePriceStorage storage s = store();\n        return timestamp / s.priceInterval * s.priceInterval;\n    }\n\n    // price in A/B units\n    function init(uint256 initialPrice, uint256 _priceInterval) internal { // shall be executed at diamond constructor\n        OraclePriceStorage storage s = store();\n        s.priceInterval = _priceInterval;\n        s.firstTimestamp = normalizeTimestamp(block.timestamp);\n        s.lastStoredPrice = initialPrice;\n        s.pricesCumulative.push(initialPrice);\n        s.revPricesCumulative.push(revPrice(initialPrice));\n    }\n\n    function update(uint256 newPrice) internal {\n        OraclePriceStorage storage s = store();\n        uint256 pricesLength = s.pricesCumulative.length;\n        uint256 lastStoredPrice = s.lastStoredPrice;\n        uint256 lastStoredRevPrice = revPrice(s.lastStoredPrice);\n        uint256 newRevPrice = revPrice(newPrice);\n        assert(pricesLength > 0); // should have been set in init()\n        uint256 lastStoredTimestamp = s.firstTimestamp + s.priceInterval * (pricesLength - 1);\n        uint256 currentTimestamp = normalizeTimestamp(block.timestamp);\n        uint256 addedIntervals = (currentTimestamp - lastStoredTimestamp) / s.priceInterval;\n        if (addedIntervals == 0) {\n            s.pricesCumulative[pricesLength - 1] = s.pricesCumulative[pricesLength - 1] + newPrice - lastStoredPrice;\n            s.revPricesCumulative[pricesLength - 1] = s.revPricesCumulative[pricesLength - 1] + newRevPrice - lastStoredRevPrice;\n            s.lastStoredPrice = newPrice;\n            return;\n        }\n        if (addedIntervals > 1) {\n            uint256 lastCumulativePrice = s.pricesCumulative[pricesLength - 1];\n            uint256 lastCumulativeRevPrice = s.revPricesCumulative[pricesLength - 1];\n            for (uint256 i = 0; i < addedIntervals - 1; i++) {\n                s.pricesCumulative.push(lastCumulativePrice + lastStoredPrice * (i + 1));\n                s.revPricesCumulative.push(lastCumulativeRevPrice + lastStoredRevPrice * (i + 1));\n            }\n        }\n        s.lastStoredPrice = newPrice;\n        s.pricesCumulative.push(s.pricesCumulative[s.pricesCumulative.length - 1] + newPrice);\n        s.revPricesCumulative.push(s.revPricesCumulative[s.revPricesCumulative.length - 1] + newRevPrice);\n\n    }\n\n    /**\n     * @dev Private function to get index and price at timestamp\n     * @param timestamp Timestamp to get index and price for\n     */\n    function getIndexAndRevPriceAtTimestamp(uint256 timestamp) private view returns (uint256 index, uint256 price) {\n        OraclePriceStorage storage s = store();\n\n        index = (timestamp - s.firstTimestamp) / s.priceInterval;\n\n        if (index < s.pricesCumulative.length) { // same length for revPricesCumulative and pricesCumulative\n            price = s.revPricesCumulative[index];\n        } else {\n            // does this trigger at all?\n            uint256 intervalsMissed = (timestamp - s.firstTimestamp) / s.priceInterval - s.pricesCumulative.length + 1;\n            uint256 lastStoredPrice = revPrice(s.lastStoredPrice);\n            price = s.revPricesCumulative[s.revPricesCumulative.length - 1];\n            price += lastStoredPrice * intervalsMissed;\n        }\n    }\n\n    // mean for B/A units\n    // (1/x_1 + ... + 1/x_n) / n\n    function getMeanRevPriceBetweenTimestamps(uint256 fromTimestamp, uint256 toTimestamp) internal view returns (uint256) {\n        OraclePriceStorage storage s = store();\n        require(toTimestamp < normalizeTimestamp(block.timestamp), \"Mean price can change in suggested interval\");\n        require(s.firstTimestamp <= fromTimestamp, \"LibOraclePrice.getMeanRevPriceBetweenTimestamps: fromTimestamp is lower than first recorded timestamp\");\n        require(fromTimestamp <= toTimestamp, \"LibOraclePrice.getMeanRevPriceBetweenTimestamps: fromTimestamp is greater than toTimestamp\");\n\n        (uint256 fromIndex, uint256 leftCumulativePrice) = getIndexAndRevPriceAtTimestamp(fromTimestamp);\n        (uint256 toIndex, uint256 rightCumulativePrice) = getIndexAndRevPriceAtTimestamp(toTimestamp);\n\n        if (fromIndex == toIndex) {\n            return getRevPriceAtTimestamp(fromTimestamp);\n        } else {\n            return (rightCumulativePrice - leftCumulativePrice) / (toIndex - fromIndex);\n        }\n    }\n\n    function getPriceAtTimestamp(uint256 timestamp) internal view returns (uint256) {\n        OraclePriceStorage storage s = store();\n        require(s.firstTimestamp <= timestamp, \"LibOraclePrice.getPriceAtTimestamp: timestamp is lower than first recorded timestamp\");\n\n        uint256 index = (timestamp - s.firstTimestamp) / s.priceInterval;\n\n        if (index >= s.pricesCumulative.length) {\n           return s.lastStoredPrice;\n        }\n\n        if (index == 0) {\n            return s.pricesCumulative[0];\n        }\n\n        return s.pricesCumulative[index] - s.pricesCumulative[index - 1];\n    }\n\n    function getRevPriceAtTimestamp(uint256 timestamp) internal view returns (uint256) {\n        OraclePriceStorage storage s = store();\n        require(s.firstTimestamp <= timestamp, \"LibOraclePrice.getRevPriceAtTimestamp: timestamp is lower than first recorded timestamp\");\n\n        uint256 index = (timestamp - s.firstTimestamp) / s.priceInterval;\n\n        if (index >= s.revPricesCumulative.length) {\n            return revPrice(s.lastStoredPrice);\n        }\n\n        if (index == 0) {\n            return s.revPricesCumulative[0];\n        }\n\n        return s.revPricesCumulative[index] - s.revPricesCumulative[index - 1];\n    }\n\n    function lastSetPrice() internal view returns (uint256) {\n        OraclePriceStorage storage s = store();\n        return s.lastStoredPrice;\n    }\n\n    function lastSetRevPrice() internal view returns (uint256) {\n        OraclePriceStorage storage s = store();\n        return revPrice(s.lastStoredPrice);\n    }\n\n    function revPrice(uint256 price) internal pure returns (uint256) {\n        return PRECISION * PRECISION / price;\n    }\n\n    function priceInterval() internal view returns (uint256) {\n        return store().priceInterval;\n    }\n\n    function lastPriceSetting() internal view returns (uint256 timestamp, uint256 price) {\n        OraclePriceStorage storage s = store();\n        timestamp = s.firstTimestamp + s.priceInterval * (s.pricesCumulative.length - 1);\n        price = s.lastStoredPrice;\n    }\n}\n"},"src/lib/LibSendValue.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nstruct SendValueStorage {\n    address payable WFLT; // WETH9 FLT <-> WFLT wrapper contract\n}\n\nuint256 constant MAX_GAS_FOR_CALL = 34_300; // send value to a cold empty address\n\nlibrary LibSendValue {\n    using SafeERC20 for IERC20;\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.send_value.storage.v1\")) - 1);\n\n    function store() internal pure returns (SendValueStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    function sendNativeOrWrapped(address payable recipient, uint256 amount) internal {\n        SendValueStorage storage s = store();\n        (bool success, ) = recipient.call{value: amount, gas: MAX_GAS_FOR_CALL}(\"\");\n        if (!success) {\n            (bool successWFLT, ) = s.WFLT.call{value: amount}(\"\");\n            require(successWFLT, \"LibSendValue: failed wrap FLT to WFLT\");\n            IERC20(s.WFLT).safeTransfer(recipient, amount);\n        }\n    }\n}\n"},"src/utils/Common.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nuint256 constant PRECISION = 1e7; // min: 0.0000001\n\nstruct CIDV1 {\n    bytes4 prefixes;\n    bytes32 hash;\n}\n"},"src/utils/OwnableUpgradableDiamond.sol":{"content":"/*\n * Fluence Compute Marketplace\n *\n * Copyright (C) 2024 Fluence DAO\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation version 3 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity ^0.8.19;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/*\n * @dev Similar (not fully) to the OZ OwnableUpgradable(Initializable, ContextUpgradeable).\n * @dev The main difference is in Diamond part,\n * @dev  e.g. from: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2964.\n */\ncontract OwnableUpgradableDiamond is Initializable {\n    // ------------------ Storage ------------------\n    bytes32 private constant _STORAGE_SLOT = bytes32(uint256(keccak256(\"fluence.ownable.storage.v1\")) - 1);\n\n    struct OwnableStorage {\n        address owner;\n    }\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage s) {\n        bytes32 storageSlot = _STORAGE_SLOT;\n        assembly {\n            s.slot := storageSlot\n        }\n    }\n\n    // ------------------ Other ------------------\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _getOwnableStorage().owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != msg.sender) {\n            revert OwnableUnauthorizedAccount(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage ownableStorage = _getOwnableStorage();\n\n        address oldOwner = ownableStorage.owner;\n        ownableStorage.owner = newOwner;\n\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}},"settings":{"remappings":["@ensdomains/buffer/=lib/filecoin-solidity/lib/buffer/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","filecoin-solidity/=lib/filecoin-solidity/contracts/","forge-std/=lib/forge-std/src/","solidity-cborutils/=lib/solidity-cborutils/contracts/","buffer/=lib/filecoin-solidity/lib/buffer/contracts/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/filecoin-solidity/lib/openzeppelin-contracts-upgradeable/contracts/","solidity-BigNumber/=lib/filecoin-solidity/contracts/vendor/solidity-BigNumber/src/","solidity-cborutils/contracts/=lib/filecoin-solidity/lib/solidity-cborutils/contracts/"],"optimizer":{"enabled":true,"runs":0},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"lib/forge-std/src/Base.sol":{"*":[]},"lib/forge-std/src/Script.sol":{"*":[]},"lib/forge-std/src/StdChains.sol":{"*":[]},"lib/forge-std/src/StdCheats.sol":{"*":[]},"lib/forge-std/src/StdJson.sol":{"*":[]},"lib/forge-std/src/StdMath.sol":{"*":[]},"lib/forge-std/src/StdStorage.sol":{"*":[]},"lib/forge-std/src/StdStyle.sol":{"*":[]},"lib/forge-std/src/StdUtils.sol":{"*":[]},"lib/forge-std/src/Vm.sol":{"*":[]},"lib/forge-std/src/console.sol":{"*":[]},"lib/forge-std/src/console2.sol":{"*":[]},"lib/forge-std/src/interfaces/IERC165.sol":{"*":[]},"lib/forge-std/src/interfaces/IERC20.sol":{"*":[]},"lib/forge-std/src/interfaces/IERC721.sol":{"*":[]},"lib/forge-std/src/interfaces/IMulticall3.sol":{"*":[]},"lib/forge-std/src/mocks/MockERC20.sol":{"*":[]},"lib/forge-std/src/mocks/MockERC721.sol":{"*":[]},"lib/forge-std/src/safeconsole.sol":{"*":[]},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/Errors.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/Strings.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol":{"*":[]},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"*":[]},"script/UpdateDiamondViewsMultisig.sol":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata","storageLayout","devdoc"]},"script/utils/Deployment.sol":{"*":[]},"script/utils/SelectorsHelper.sol":{"*":[]},"src/balance-keeper/IBalanceKeeper.sol":{"*":[]},"src/core/DealStakerRewards.sol":{"*":[]},"src/core/Snapshot.sol":{"*":[]},"src/core/Vesting.sol":{"*":[]},"src/core/interfaces/IBaseOffer.sol":{"*":[]},"src/core/interfaces/ICapacity.sol":{"*":[]},"src/core/interfaces/ICapacityConst.sol":{"*":[]},"src/core/interfaces/ICore.sol":{"*":[]},"src/core/interfaces/IDealFactory.sol":{"*":[]},"src/core/interfaces/IEpochController.sol":{"*":[]},"src/core/interfaces/IGlobalConst.sol":{"*":[]},"src/core/interfaces/IMarket.sol":{"*":[]},"src/core/interfaces/IMarketV2.sol":{"*":[]},"src/core/interfaces/IOffer.sol":{"*":[]},"src/core/interfaces/IOfferV2.sol":{"*":[]},"src/deal/interfaces/IConfig.sol":{"*":[]},"src/deal/interfaces/IDeal.sol":{"*":[]},"src/deal/interfaces/IWorkerManager.sol":{"*":[]},"src/deal/v1/interfaces/IConfig.sol":{"*":[]},"src/deal/v1/interfaces/IDeal.sol":{"*":[]},"src/deal/v1/interfaces/IWorkerManager.sol":{"*":[]},"src/interfaces/IDiamond.sol":{"*":[]},"src/interfaces/IDiamondCut.sol":{"*":[]},"src/interfaces/IDiamondLoupe.sol":{"*":[]},"src/interfaces/IERC165.sol":{"*":[]},"src/interfaces/IERC173.sol":{"*":[]},"src/interfaces/IMulticall.sol":{"*":[]},"src/interfaces/IViewer.sol":{"*":[]},"src/interfaces/IWhitelist.sol":{"*":[]},"src/lib/LibBaseOffer.sol":{"*":[]},"src/lib/LibCapacity.sol":{"*":[]},"src/lib/LibCapacityConst.sol":{"*":[]},"src/lib/LibDiamond.sol":{"*":[]},"src/lib/LibEpochController.sol":{"*":[]},"src/lib/LibGlobalConst.sol":{"*":[]},"src/lib/LibOffer.sol":{"*":[]},"src/lib/LibOfferV2.sol":{"*":[]},"src/lib/LibOraclePrice.sol":{"*":[]},"src/lib/LibSendValue.sol":{"*":[]},"src/utils/Common.sol":{"*":[]},"src/utils/OwnableUpgradableDiamond.sol":{"*":[]}},"evmVersion":"cancun","viaIR":true,"libraries":{}},"allowPaths":["/Users/dmitrii/FLUENCE/compute-marketplace","/Users/dmitrii/FLUENCE/compute-marketplace/lib"],"basePath":"/Users/dmitrii/FLUENCE/compute-marketplace","includePaths":["/Users/dmitrii/FLUENCE/compute-marketplace"]},"output":{"errors":[{"sourceLocation":{"file":"script/UpdateDiamondViewsMultisig.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> script/UpdateDiamondViewsMultisig.sol\n\n"},{"sourceLocation":{"file":"script/utils/Deployment.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> script/utils/Deployment.sol\n\n"},{"sourceLocation":{"file":"script/utils/SelectorsHelper.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> script/utils/SelectorsHelper.sol\n\n"},{"sourceLocation":{"file":"src/balance-keeper/IBalanceKeeper.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/balance-keeper/IBalanceKeeper.sol\n\n"},{"sourceLocation":{"file":"src/core/DealStakerRewards.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/DealStakerRewards.sol\n\n"},{"sourceLocation":{"file":"src/core/Snapshot.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/Snapshot.sol\n\n"},{"sourceLocation":{"file":"src/core/Vesting.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/Vesting.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IBaseOffer.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IBaseOffer.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/ICapacity.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/ICapacity.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/ICapacityConst.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/ICapacityConst.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/ICore.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/ICore.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IDealFactory.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IDealFactory.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IEpochController.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IEpochController.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IGlobalConst.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IGlobalConst.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IMarket.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IMarket.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IMarketV2.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IMarketV2.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IOffer.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IOffer.sol\n\n"},{"sourceLocation":{"file":"src/core/interfaces/IOfferV2.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/core/interfaces/IOfferV2.sol\n\n"},{"sourceLocation":{"file":"src/deal/interfaces/IConfig.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/deal/interfaces/IConfig.sol\n\n"},{"sourceLocation":{"file":"src/deal/interfaces/IDeal.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/deal/interfaces/IDeal.sol\n\n"},{"sourceLocation":{"file":"src/deal/interfaces/IWorkerManager.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/deal/interfaces/IWorkerManager.sol\n\n"},{"sourceLocation":{"file":"src/deal/v1/interfaces/IConfig.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/deal/v1/interfaces/IConfig.sol\n\n"},{"sourceLocation":{"file":"src/deal/v1/interfaces/IDeal.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/deal/v1/interfaces/IDeal.sol\n\n"},{"sourceLocation":{"file":"src/deal/v1/interfaces/IWorkerManager.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/deal/v1/interfaces/IWorkerManager.sol\n\n"},{"sourceLocation":{"file":"src/interfaces/IDiamond.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/interfaces/IDiamond.sol\n\n"},{"sourceLocation":{"file":"src/interfaces/IMulticall.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/interfaces/IMulticall.sol\n\n"},{"sourceLocation":{"file":"src/interfaces/IViewer.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/interfaces/IViewer.sol\n\n"},{"sourceLocation":{"file":"src/interfaces/IWhitelist.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/interfaces/IWhitelist.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibBaseOffer.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibBaseOffer.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibCapacity.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibCapacity.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibCapacityConst.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibCapacityConst.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibEpochController.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibEpochController.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibGlobalConst.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibGlobalConst.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibOffer.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibOffer.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibOfferV2.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibOfferV2.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibOraclePrice.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibOraclePrice.sol\n\n"},{"sourceLocation":{"file":"src/lib/LibSendValue.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/lib/LibSendValue.sol\n\n"},{"sourceLocation":{"file":"src/utils/Common.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/utils/Common.sol\n\n"},{"sourceLocation":{"file":"src/utils/OwnableUpgradableDiamond.sol","start":-1,"end":-1},"type":"Warning","component":"general","severity":"warning","errorCode":"1878","message":"SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.","formattedMessage":"Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> src/utils/OwnableUpgradableDiamond.sol\n\n"}],"contracts":{"script/UpdateDiamondViewsMultisig.sol":{"UpdateDiamondViewsMultisig":{"abi":[{"type":"function","name":"IS_SCRIPT","inputs":[],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"run","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setUp","inputs":[],"outputs":[],"stateMutability":"nonpayable"}],"metadata":"{\"compiler\":{\"version\":\"0.8.26+commit.8a97fa7a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IS_SCRIPT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"run\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"script/UpdateDiamondViewsMultisig.sol\":\"UpdateDiamondViewsMultisig\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":0},\"remappings\":[\":@ensdomains/buffer/=lib/filecoin-solidity/lib/buffer/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":buffer/=lib/filecoin-solidity/lib/buffer/contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\":filecoin-solidity/=lib/filecoin-solidity/contracts/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/filecoin-solidity/lib/openzeppelin-contracts-upgradeable/contracts/\",\":solidity-BigNumber/=lib/filecoin-solidity/contracts/vendor/solidity-BigNumber/src/\",\":solidity-cborutils/=lib/solidity-cborutils/contracts/\",\":solidity-cborutils/contracts/=lib/filecoin-solidity/lib/solidity-cborutils/contracts/\"],\"viaIR\":true},\"sources\":{\"lib/forge-std/src/Base.sol\":{\"keccak256\":\"0x4ff1a785311017d1eedb1b4737956fa383067ad34eb439abfec1d989754dde1c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f553622969b9fdb930246704a4c10dfaee6b1a4468c142fa7eb9dc292a438224\",\"dweb:/ipfs/QmcxqHnqdQsMVtgsfH9VNLmZ3g7GhgNagfq7yvNCDcCHFK\"]},\"lib/forge-std/src/Script.sol\":{\"keccak256\":\"0x2315be74cc2826f9da401bea3da46a10ad6a6efdf73176d79160b453286d0ed2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://af0d4dc826911d6cb4d6272ed5cbdb6950e1476141cca328e178b808d848789c\",\"dweb:/ipfs/QmV2ytjUEkV84VtdMs1nZqQTBoVE987cHboQMpiha5yo3e\"]},\"lib/forge-std/src/StdChains.sol\":{\"keccak256\":\"0x1e2c73d51d6b0d1101f3a4cf0e6def9818a891d6aa8d306f2b127943a69dca2d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ab436d74b405f890e2634c6077df15cc196b4032ec1bdabaaf021ef209e68db\",\"dweb:/ipfs/Qmbb1Qgtdn6S4aqrnpg3y9TDX7erFFcRir9GN62Y7QazaY\"]},\"lib/forge-std/src/StdCheats.sol\":{\"keccak256\":\"0xb72f3519e0bf7d31df5d68557525f4fc55d861c3fb3b0f7793144ef7c94cbeb7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f3456d0f78e6f61203fa7871ba2df0d35925f10db3baee14be623ce2a35b84e2\",\"dweb:/ipfs/QmWE6QQSBvJifHMraisBTrf1x4WCwrDoTPLX8UKajTiApc\"]},\"lib/forge-std/src/StdJson.sol\":{\"keccak256\":\"0x62bed173cb126f6d5006706cf249bac8a2d51bfa18f773f314784ff18adc622d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5acc33dddbf2492e37dc32e89cd56ce917272d303a6874805f3a5768a6bfbf54\",\"dweb:/ipfs/QmTsgFhcpUf16gAVazUXU3WspgX8nHke2hzVCvoqS25WEp\"]},\"lib/forge-std/src/StdMath.sol\":{\"keccak256\":\"0xd90ad4fd8aeaeb8929964e686e769fdedd5eded3fc3815df194a0ab9f91a3fb2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7919b70f636c7b805223992f28ad1ad0145d6c1385b5931a3589aface5fe6c92\",\"dweb:/ipfs/QmY7FRaULwoGgFteF8GawjQJRfasNgpWnU2aiMsFrYpuTC\"]},\"lib/forge-std/src/StdStorage.sol\":{\"keccak256\":\"0xb91ab24383a5872b894fc93325eef1add6cbbf981628f18e860068bf88bb7dcc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2651e33b9ac8fc5803ed0a43078c1bf4fa90a0b0347aafd95776b02daccdcc57\",\"dweb:/ipfs/QmbdRyPuGJdZgnCuMnp7c1WsBo1Spf7j1KMmws1Z5rd4BQ\"]},\"lib/forge-std/src/StdStyle.sol\":{\"keccak256\":\"0x43e2a8a9b9c2574dabe74f11adf6f782df218f463540e3b5b563609fe108597d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://51363ca97404cf4128e1141428949768c31929e75e014b02c85e887fbbb4f1b8\",\"dweb:/ipfs/QmVhtbQc2fU4rRmbcfBtz34mAgG4BAZBsbna1Ca4SkoPsK\"]},\"lib/forge-std/src/StdUtils.sol\":{\"keccak256\":\"0x4a5853bb9688c4e1c65626036cddd8ea2af84ef1046b704ddc3782d84a892410\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://09c1024e6aac9657312fcfcf5c3dee62c22edf9f74a1065e6924c4ec710ecafa\",\"dweb:/ipfs/QmRNURoTUkd6DiZnf8yY8o3stJpVQBifopdSpQgP9RhvRr\"]},\"lib/forge-std/src/Vm.sol\":{\"keccak256\":\"0x18e223717d9fd7c71e60c3fc3209ff49ee774365b6294039e2f6c17b8250c7a6\",\"license\":\"MIT OR Apache-2.0\",\"urls\":[\"bzz-raw://c4a8457a84ddb1e753c8634876065f5d12691fac78675dcc7a405f511827015b\",\"dweb:/ipfs/QmRagGCM8bZXGjCwxt8tmNf79yb1SuCqNfiDr8WvakEPxo\"]},\"lib/forge-std/src/console.sol\":{\"keccak256\":\"0xf61cb43a94d8318049d0a7f567af8c0aa952b5762a43851b130b90b3fcde0c6a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://53a52c6c3aeb22f7a18f53fca16af590308a8e3e5507e74df9b8e2561c932194\",\"dweb:/ipfs/QmaaXuY8mC66YoE2xyZdWuLHXqAxLjbnNxiofx8BTP1MRn\"]},\"lib/forge-std/src/console2.sol\":{\"keccak256\":\"0x3b8fe79f48f065a4e4d35362171304a33784c3a90febae5f2787805a438de12f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://61de63af08803549299e68b6e6e88d40f3c5afac450e4ee0a228c66a61ba003d\",\"dweb:/ipfs/QmWVoQ5rrVxnczD4ZZoPbD4PC9Z3uExJtzjD4awTqd14MZ\"]},\"lib/forge-std/src/interfaces/IERC165.sol\":{\"keccak256\":\"0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://698352fb240868ea8f1d1fe389993035eeab930f10d06934f80ccfb2b6ccbfbc\",\"dweb:/ipfs/QmT6WLHAgXxFhh12kWym895oTzXid1326iZiwT3pyfggoT\"]},\"lib/forge-std/src/interfaces/IERC20.sol\":{\"keccak256\":\"0x4cab887298790f908c27de107e4e2907ca5413aee482ef776f8d2f353c5ef947\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bb715e0c4a2bdbe432bb624501506041f06e878e0b72675aebba30ad2c2b72e7\",\"dweb:/ipfs/QmWhhLSvkxS2NrukJJHqFY8gDVE5r9rD4PfHvR24pwdKv9\"]},\"lib/forge-std/src/interfaces/IERC721.sol\":{\"keccak256\":\"0xf069262a264fdb69f8f37a10d2df7374649e9ba73f8414c9c8a3b51184625f15\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://924a41ca82a68ffbd503a5faf2f76d13e9938f10501a71094716f12bb64b4b7f\",\"dweb:/ipfs/QmdWnqfKc5ZGhmxNPTde4zrFchnv9Yk9MpCMb2rdhXE5gm\"]},\"lib/forge-std/src/interfaces/IMulticall3.sol\":{\"keccak256\":\"0x7aac1389150499a922d1f9ef5749c908cef127cb2075b92fa17e9cb611263d0a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d95ebb7c7c463e08ebc12dab639945752fb2480acfc6e86da32f72732a7fd0c0\",\"dweb:/ipfs/QmNXK8P8oPWwajsQHvAHw3JPyQidPLCGQN3hWu1Lk6PBL2\"]},\"lib/forge-std/src/mocks/MockERC20.sol\":{\"keccak256\":\"0xadbdfc6639edec00ba94bb1133a0fd8de31ccafe45c2ef5df9b3ca61b60b559b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bc766f01bccf669abac8cc7b2096cc1352a66471ca3772ae61b1801dedc4ed4f\",\"dweb:/ipfs/QmNigaPj1LYkP7Z5xr4ijkUxr2K66fDGeoifG3WoM9ruyw\"]},\"lib/forge-std/src/mocks/MockERC721.sol\":{\"keccak256\":\"0xbfbb755bb379f58b97699f7cda0e9a2b9113daaa072e41b280a5ce6a3bff44c9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5ae0c31d29db14d6a0e9b62d33d550feb307f48a6f45068901a013321f337f87\",\"dweb:/ipfs/QmX25DVXW6XZDvRm6SNBGCWrZQ6oNhdq5CmgtVocvsUdwv\"]},\"lib/forge-std/src/safeconsole.sol\":{\"keccak256\":\"0xbaf41fdc6c54297e7cd8250e48b0f20eaac918e342a1028cef3f9a52ac086381\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a500ad81dea226f9910e6b50f99a9ff930105e393a692cbfb2185e4cdb4424ae\",\"dweb:/ipfs/QmVbUQpXNMmMWRiy4FvBNczzq46BMGfUoBikvSHNiCxVTq\"]},\"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\":{\"keccak256\":\"0x631188737069917d2f909d29ce62c4d48611d326686ba6683e26b72a23bfac0b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a61054ae84cd6c4d04c0c4450ba1d6de41e27e0a2c4f1bcdf58f796b401c609\",\"dweb:/ipfs/QmUvtdp7X1mRVyC3CsHrtPbgoqWaXHp3S1ZR24tpAQYJWM\"]},\"lib/openzeppelin-contracts/contracts//utils/structs/EnumerableSet.sol\":{\"keccak256\":\"0x86c1470cbfd878491e5de030072b647352d36bd27122cffb928970b1945282aa\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ad85dd393ee0a1917c57046abc5155f51f77844b2c6a42c05c1b8dd26d6ff3c1\",\"dweb:/ipfs/QmNqYc8To2NdnpP6E1tGz7t6A7beuENde5yovwov5pW1fA\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol\":{\"keccak256\":\"0x9f21f1bcc51daf7fe3998608d7eeb96b16a9c3816898a0cf6a9407bd105c9253\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71cd1acb2370851314e9e2fc84123228e468037435eea0ed1c459346a214ce73\",\"dweb:/ipfs/QmXw5XVVnrjX3m224Zs9jdQVY3abwiCEVBjk9w24DXsFSi\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\":{\"keccak256\":\"0xde7e9fd9aee8d4f40772f96bb3b58836cbc6dfc0227014a061947f8821ea9724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://11fea9f8bc98949ac6709f0c1699db7430d2948137aa94d5a9e95a91f61a710a\",\"dweb:/ipfs/QmQdfRXxQjwP6yn3DVo1GHPpriKNcFghSPi94Z1oKEFUNS\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\":{\"keccak256\":\"0xce41876e78d1badc0512229b4d14e4daf83bc1003d7f83978d18e0e56f965b9c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a2608291cb038b388d80b79a06b6118a42f7894ff67b7da10ec0dbbf5b2973ba\",\"dweb:/ipfs/QmWohqcBLbcxmA4eGPhZDXe5RYMMEEpFq22nfkaUMvTfw1\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009\",\"dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\":{\"keccak256\":\"0x18436638da96539b6a9f971f8ce332c6fcad32d15c988af689b174f753d9936b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0351b5b167c9f0f6eb670bc6db5e9579aadb9a42edc62256c182695c3e9bf47e\",\"dweb:/ipfs/QmSQPNXU4NYhYojvyqHRzQx2duRx5njv6AHssoJMQb8Tq1\"]},\"lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"keccak256\":\"0x80b4189de089dc632b752b365a16c5063b58cc24da0dd38b82f2c25f56d25c84\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://81e2717e78844156a86733f1cada84dba906ffe03e4957de12ca219c65e9191b\",\"dweb:/ipfs/QmW8vg3AafPJRo7EC75RQJTtjiaYmfPa4U4sqmEuBXXzaP\"]},\"lib/openzeppelin-contracts/contracts/utils/Errors.sol\":{\"keccak256\":\"0xc452b8c0ab5a57e6ca49c4fbe6aead2460c2f8d60d58bc60af68e559b7ca1179\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0980b3b9e8cd9d9a0f2ae848f0f36a85158887e6fd961142a13b11299ae7f30a\",\"dweb:/ipfs/QmUrmDji3NR2V3YezV8xHSS3wjeBKq16FL7cHdBCnwLjKd\"]},\"lib/openzeppelin-contracts/contracts/utils/Panic.sol\":{\"keccak256\":\"0x29074fe5a74bb024c57b3570abf6c74d8bceed3438694d470fd0166a3ecd196a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f4f8435ccbc56e384f4cc9ac9ff491cf30a82f2beac00e33ccc2cf8af3f77cc3\",\"dweb:/ipfs/QmUKJXxTe6nn1qfgnX8xbnboNNAPUuEmJyGqMZCKNiFBgn\"]},\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\":{\"keccak256\":\"0x686a21b9be2594ccfda3a855270dd8ebc4288b8a9ed84ecd4ef1bca2ea3fc46b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7c0bbc37f4d1aaae086d73f13f41b8043a9ad5b07f30a2fd7b8a74ead99b1ef6\",\"dweb:/ipfs/QmZpFyfCCFpbrkNtfHTn18qV7VvptPdoLN82Qu5XtMCci6\"]},\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"keccak256\":\"0xc859863e3bda7ec3cddf6dafe2ffe91bcbe648d1395b856b839c32ee9617c44c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a9d5417888b873cf2225ed5d50b2a67be97c1504134a2a580512168d587ad82e\",\"dweb:/ipfs/QmNr5fTb2heFW658NZn7dDnofZgFvQTnNxKRJ3wdnR1skX\"]},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"keccak256\":\"0x0883afe0b965062c94cb0a6640a334d9e7611aed38bfe7344489dda0fb064226\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://53912d908082914f6c8e6e32b9cb850a379f1ea86ac56a8a69304204e6cb8bc7\",\"dweb:/ipfs/QmeSqtEAx3nWYmY93idobmhTywXsWAkX9J1zpP61UwXHR7\"]},\"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\":{\"keccak256\":\"0x8cd59334ed58b8884cd1f775afc9400db702e674e5d6a7a438c655b9de788d7e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://99e62c7de7318f413b6352e3f2704ca23e7725ff144e43c8bd574d12dbf29047\",\"dweb:/ipfs/QmSEXG2rBx1VxU2uFTWdiChjDvA4osEY2mesjmoVeVhHko\"]},\"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\":{\"keccak256\":\"0x5c8d4114f077f6803bb89b8b07bfa26dfbf8f2001708e4e7fdf1e8d9ddd42f44\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b66c74efa1f994e3ea467b4165da1575857b29d81bec36e94678fe494ce5c615\",\"dweb:/ipfs/QmeXQFdzSJFmN8UdhxMqQwwUh1U2WEha5NoVLbSg3pCJc5\"]},\"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\":{\"keccak256\":\"0x86c1470cbfd878491e5de030072b647352d36bd27122cffb928970b1945282aa\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ad85dd393ee0a1917c57046abc5155f51f77844b2c6a42c05c1b8dd26d6ff3c1\",\"dweb:/ipfs/QmNqYc8To2NdnpP6E1tGz7t6A7beuENde5yovwov5pW1fA\"]},\"script/UpdateDiamondViewsMultisig.sol\":{\"keccak256\":\"0x03f2e412b602d5e371735215460a95e6eb24c713a2b5039fa03c33f04edffb62\",\"urls\":[\"bzz-raw://f072c6d69436eab3de560e2206194599a538f15b7f66324fdb6a02bdb43f761a\",\"dweb:/ipfs/QmVpuFsZbbdEj93ky6Gn6i2xGPhzmtmyxC35p1bfa3DDjw\"]},\"script/utils/Deployment.sol\":{\"keccak256\":\"0x13673e623f91e3c29bda666450572d8060cfd178b68431633f9978fa8bace8cc\",\"urls\":[\"bzz-raw://23a8b58a034fcd50d1391809eac9e8e53709a5b6231bb3dbc4ffc46b9eabe278\",\"dweb:/ipfs/QmP6QkYXy6imtT86ToCysUbm9YmTz7HyBMGGFyTzoDfJz8\"]},\"script/utils/SelectorsHelper.sol\":{\"keccak256\":\"0xd550e14eb8f8d176df185a98270208ec48157d77be7cc277ed55a8b756aafae5\",\"urls\":[\"bzz-raw://12bc1c2eaff4af2fbe7e257474a02e83370a8036e8380a641f570b8a6ee3d3f6\",\"dweb:/ipfs/QmeQvtHjdwbKB2J39nC6BS7VdNWcP38DS5cEc3d7p7KiZz\"]},\"src/balance-keeper/IBalanceKeeper.sol\":{\"keccak256\":\"0x4e7cfd02f0ac587064dc57b83703b2fb5eb322249a037625ffaae7e08ffb2f07\",\"urls\":[\"bzz-raw://b44f7ee150c56b4540dfa017135e6fff70ad47e8e58c32d66b5cf07b08cdfbe8\",\"dweb:/ipfs/QmNfDHG9LsP6bkfm3TVev3ZXpPCMTw4S6PxmCCQG8pD66h\"]},\"src/core/DealStakerRewards.sol\":{\"keccak256\":\"0x5daaa9277451934b06386210d32614e3510cf60b644782a553f5270fe277387a\",\"urls\":[\"bzz-raw://e8165e4cd31ae15151792415fa649f878c4836ae37a6cdf705cbf4d9b2506cbd\",\"dweb:/ipfs/QmbsEMpJ1agjKApkYUJbvDbGX8ChQLQ1KbsSngfoWfmgVR\"]},\"src/core/Snapshot.sol\":{\"keccak256\":\"0x6814fcdd7decb88354a4d50637de96eb3426da9588389116748f63c62fba3832\",\"urls\":[\"bzz-raw://3a36801dd25e53396e74c8a6240642432a01d0e78159b35ad38b8a7fe3c01b79\",\"dweb:/ipfs/QmdQvgtVfsgrBmjmXJhaQq6uF8tNn2NNTdijg5UyMERWoc\"]},\"src/core/Vesting.sol\":{\"keccak256\":\"0xf25bd278891c8946503bab393f102f7b6327831a291af8084af930bff2000078\",\"urls\":[\"bzz-raw://5174d81e81bcc858e618992f8f35c86289d54ffc099983fd9d770885c569896f\",\"dweb:/ipfs/QmR2exswUCRDKTvXEqLBdue3zZFobjCJj7Az6dQ4gjtnqB\"]},\"src/core/interfaces/IBaseOffer.sol\":{\"keccak256\":\"0xccb18f2f4bc37949db6779dec9b571034cc5df2dcaacb690c32698703c59976d\",\"urls\":[\"bzz-raw://aa92e404dce6e22af08be7f6f14202ae13ef51359c0df6e436b809f0a8c3c2d8\",\"dweb:/ipfs/QmWHE5ZvsZTE5W6C7swhe8QKWwVfV9thXWjiaah1cnVCFT\"]},\"src/core/interfaces/ICapacity.sol\":{\"keccak256\":\"0x952b553638f71cb49d2124439f7286a6091fdf0e485d991343f11451f1b0feb4\",\"urls\":[\"bzz-raw://fe0360066773c55188ac0b160ed0db23a799f98a7e41deebb3bd71c3fc5aeed9\",\"dweb:/ipfs/QmZ5Cifam3AkVS7Xx9FpnrouiVY7Fv42MK8yMLWe1DagKq\"]},\"src/core/interfaces/ICapacityConst.sol\":{\"keccak256\":\"0x60679e12175ef8ec5fe3fd2108fcdf8b7845348452fececc25ada3b7516191d9\",\"urls\":[\"bzz-raw://054ffd2a008a4ba8692dd7f60bef3d9f87c84799f28d1575b9031a4c9715e84f\",\"dweb:/ipfs/QmUqCxKvUCMQ2bGqnEsCUZR2qi8aMAFxrDAQNQdBnYkjPj\"]},\"src/core/interfaces/ICore.sol\":{\"keccak256\":\"0x8f612bef8f693e0f9db073c69be76568558961ff82018382457c54e771baa28a\",\"urls\":[\"bzz-raw://a0250e4a8e7f0b077ec6dc40fd39df85d4b8dca960927efb1d7ec40c08c35cb6\",\"dweb:/ipfs/QmasALo665VKJyFuFj69H6azXM1DEMBHRK5LZ6jngdXTxT\"]},\"src/core/interfaces/IDealFactory.sol\":{\"keccak256\":\"0x9018d741f6bf5af1314d420a0b145fcb49e861f7aa7b3efc05563d779e5668f7\",\"urls\":[\"bzz-raw://8fd482c586ff2376a9e6d829dc79f4a3e2e39a20ebba54277bd5f36e0f687a82\",\"dweb:/ipfs/QmWZSMFmM5yzZHZFiiMnuPu7Z9r37f17putTtjDjKjXPrD\"]},\"src/core/interfaces/IEpochController.sol\":{\"keccak256\":\"0x75d4b147938d93ea391e8e97950fae57dc0d02da5eceba44beafd3fdde152b43\",\"urls\":[\"bzz-raw://6709d7544c7c3ea5ef8b0a10d05ed1a23676a78ee27a23bf61d4eef7731f804b\",\"dweb:/ipfs/QmZFea2bBEZ185jGeRtGcxRYNChFmFwgiRrPUGaoJD4qLx\"]},\"src/core/interfaces/IGlobalConst.sol\":{\"keccak256\":\"0x244f1e7020782274570d1230a5b5df81ab67dc11007eda87acf0bfdb2b5bda2a\",\"urls\":[\"bzz-raw://a7a7a3b6781aa0b1994e79461094776bf4cfb3f6f801a5095f81694bed43bd9a\",\"dweb:/ipfs/QmbTAJDu5K9AaffkoHguoQnMsjPRRDhiwAdu9dafkcs52G\"]},\"src/core/interfaces/IMarket.sol\":{\"keccak256\":\"0x15c1b65dd8df34cceb3e8aa35299a08ff5a330c77551a17768e8c236b782bf9b\",\"urls\":[\"bzz-raw://e904bca4bcc769e9207d96fd05f846e622da9620cb96b93078c9b6b05e727a4a\",\"dweb:/ipfs/QmPCdQiKtaFUKNBC8js119oaYCzCe9aiMETqCGmoveBGgG\"]},\"src/core/interfaces/IMarketV2.sol\":{\"keccak256\":\"0xa11806264689201c1fcc171b82b66b0259faf70b0160c1f35a6f016a2e938272\",\"urls\":[\"bzz-raw://1c175fbf22eab6a898752c33d12ec719d6837ae0ab12a230984b8e675515276f\",\"dweb:/ipfs/QmWYsRz8DKgzMDX8GXHxQS2cvMrBwLhAArkRKNn2TJZqV8\"]},\"src/core/interfaces/IOffer.sol\":{\"keccak256\":\"0x69f1837f5194d3542b8952f083c48f922320925ecb27530835fb84f11c0cdd83\",\"urls\":[\"bzz-raw://4989a76d3687c285f01d0375e35a23d2ea715fca87f14b965cf044956eb7581a\",\"dweb:/ipfs/QmeXEcAGnYxLfSnq9fMcsPSH8HLn18xmE7Tj1Awwr7FCzj\"]},\"src/core/interfaces/IOfferV2.sol\":{\"keccak256\":\"0xd39972985e6761adb6dd7d4bb40e1bcb6960fc74d585a86abe01123fd7fb468c\",\"urls\":[\"bzz-raw://cbe32167d3bda9048c1aa2981aa3744d61d8ca6bc9d3e8a49587c0a2804711c3\",\"dweb:/ipfs/QmZqLNDEp7CfL9czm3j6gC2yYZRMrNE5dCeKNp6yMBPc2q\"]},\"src/deal/interfaces/IConfig.sol\":{\"keccak256\":\"0x4d0243039bc5990fda1c5772f76d38a7ca1e6e814916bdc7b1d8cc651e8fe3b8\",\"urls\":[\"bzz-raw://b77ff1fa6f43446a3dc9eacee05ab91397798a155bdb9682d4236d184ed36458\",\"dweb:/ipfs/QmY1cyRu9cUkRrj5ppeMkqLif3XV28KU96H6TT5ZbLoD79\"]},\"src/deal/interfaces/IDeal.sol\":{\"keccak256\":\"0xbf4ad647183a23f9bad1c8af14ba29bd0026b870d243e3ee1905042ceaf338c7\",\"urls\":[\"bzz-raw://9372514328a1bc89911b49a5034740d8e64f0e5179fbfc1ac9b06ed8a453c31b\",\"dweb:/ipfs/QmdEx8S223XksxpZGZAjRzPAj2TfeKW5GL3CBc6pGB8ocJ\"]},\"src/deal/interfaces/IWorkerManager.sol\":{\"keccak256\":\"0x550c61112a645a9f723ea436092865c9ee664a4c0808e0a557918e64864f799a\",\"urls\":[\"bzz-raw://6697a6db8f14710cacb415e212c9d2eefbd054f0ce3b22eee65cc069e2d47a01\",\"dweb:/ipfs/QmTPtNHLK6PSiLDd8pHVMAqePULjQrMHMY1ti33xVsoqNp\"]},\"src/deal/v1/interfaces/IConfig.sol\":{\"keccak256\":\"0xd2ff604cbf7bd00e8319b8434e0001cb6180b6077dc4a188308a0a9b65ee9524\",\"urls\":[\"bzz-raw://3bf8a3c15d21c7ab8fcb84dbba3e77faf125caf2cf962b272b510818e0e3507e\",\"dweb:/ipfs/QmfXFRMxDSS2HM6smXjzJyB5BZqeDEgL5JPNBgFeo6Bxn3\"]},\"src/deal/v1/interfaces/IDeal.sol\":{\"keccak256\":\"0x37ad8292837a6781215fa7ffe8ea1c6bfc0f62ecc1b4720f79c279d4112c7c62\",\"urls\":[\"bzz-raw://5915f1e2e9199eccbbe356459b0db312bf6f45ab505f0f0490c893aee956db40\",\"dweb:/ipfs/QmZgPopU9HY1wkn7WdtZgwd29U52E9Y3vZ6uAT4pnzFLp1\"]},\"src/deal/v1/interfaces/IWorkerManager.sol\":{\"keccak256\":\"0xdf34ae6acdbeee4aaa5fe9ee174d50d2c737f04d0f7f76afb6fbfaf6b693bbfd\",\"urls\":[\"bzz-raw://60d024d31a6fc40fd67a18427969d7ba44e16ed1e7763a3b093f5eaef4e2fedf\",\"dweb:/ipfs/QmeAqAjx3QXUgk7bZfc4FWXcxjCt5VFNsy95dasLdAjHuo\"]},\"src/interfaces/IDiamond.sol\":{\"keccak256\":\"0x6ac4e3af3f634fe4523ff1c159402d43337d557ab4b4da7fb76be0a9586ea00b\",\"urls\":[\"bzz-raw://c435a28691b25d62d14eb453eb6f57b36613a9bddee4a42d4153d7692245e27d\",\"dweb:/ipfs/QmNZPJTBUwJngm36dDdeboDLMaUxvAJKtG5vQmSbR4CoFh\"]},\"src/interfaces/IDiamondCut.sol\":{\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://119d9a5acd99b9462a8341c9b95ddd468648799eefa47038f81521431743c1ae\",\"dweb:/ipfs/QmTF7WNyPWTUtUzNcpq5rf5v2uw5TwzqsSg9D53pfQufcu\"]},\"src/interfaces/IDiamondLoupe.sol\":{\"keccak256\":\"0x10884024af2c0f7deca0fac4ddf84e76da5dba35b6e02fabeac8ea54c1a5c6f7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://df3404a4aed3bbda2f5e441d7035b354237d8c9d7c27b149ccf66d13a1d81d45\",\"dweb:/ipfs/QmZvHWgRCge8tLJ3x3Lf3JQkbNTgAN6LzwCGBabbgk8tew\"]},\"src/interfaces/IERC165.sol\":{\"keccak256\":\"0x7541f7408d0f74162bc4664d5e012427f2ceaab2abadca0353269ef15ee03d8b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a8e7a34b3ea39f4c0dfa6f5ace5d9415e4d0c90cb3f4264e6946b808f2d4011c\",\"dweb:/ipfs/QmWdcRF4krMMb1ua3hmV8avdHKYa4XXt1iw7sxx1ntsEJa\"]},\"src/interfaces/IERC173.sol\":{\"keccak256\":\"0x001e07b0fbc894300b939d496ffb005abe398b5bc609802d319b8cdeafe5d36b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://8e59f66879ef993892410cbe834b1d2dd34891f47066b7be601ff825b0748361\",\"dweb:/ipfs/QmZedQ668we8ohPPZF5tPP5gKpJ5n22h3FDFkoFT5VXpEu\"]},\"src/interfaces/IMulticall.sol\":{\"keccak256\":\"0xdd33bfc54896e5fa7767fd9da9c01a07998a89ea5dd713d2bb77a2393d1ef7c7\",\"urls\":[\"bzz-raw://e0acfa7038cbf2574978895bc44db10c5a68c87c5fadd9e892626d035bd35f70\",\"dweb:/ipfs/QmV4rQqZH1VmudukrErA4iScERhePUsWEsxFdrWVSXfNRM\"]},\"src/interfaces/IViewer.sol\":{\"keccak256\":\"0x051dad56df3d10218fa88ac926c48ea013a8a6f7acff826a6094bff099e252d0\",\"urls\":[\"bzz-raw://bf8ec99e89de3474c3c9c59be17d9d253e9dce41e66b6de507340eb5de609703\",\"dweb:/ipfs/QmW5bz4sewH9qq7uZ372wX24PcuRf7HUw6t2yQwDTdmiyy\"]},\"src/interfaces/IWhitelist.sol\":{\"keccak256\":\"0x0dd87386e23970aaaa704283f3a0e6d71f782f576280885a1ce6741cf375cfa2\",\"urls\":[\"bzz-raw://ab074c338a4fde07d6d0b1548c0348849e47d720efc88a43fb067128d65c6b6e\",\"dweb:/ipfs/QmPk65Gu1vtxwJA7vucWsuaPfMb7tRPwA1roQZCj3bA4kY\"]},\"src/lib/LibBaseOffer.sol\":{\"keccak256\":\"0x6a1e8d686ed52167bb7f1cc9d5f5928f95c88974b858f263e5ce81aa55012d9a\",\"urls\":[\"bzz-raw://b42c9edad3b041a3acc156d020d38b80bdffb537ab1c3100c4aba28459b94694\",\"dweb:/ipfs/QmfXbg2ypcKk6Z1kZsddFCH1JXmndHLKp7W4YakbozF9Z6\"]},\"src/lib/LibCapacity.sol\":{\"keccak256\":\"0xa6282d41b15a17bfc63b86a292bdf4b1b9f76ed807cb9f120a3dfb45df575e6b\",\"urls\":[\"bzz-raw://f10bf0a906e46c769a7b3bbfa08145e687b1e926b2fd100bb9eeb445e9c01dfe\",\"dweb:/ipfs/QmbfxiX2kvYenv3QEMjMgmQfoV5oNVd84VGb2LA6sxcqZz\"]},\"src/lib/LibCapacityConst.sol\":{\"keccak256\":\"0xb5e8419cf51a6cdfcf4133e1663d9e860be2d2549eb7f70cf44389e4c9131de1\",\"urls\":[\"bzz-raw://258bf6b5f0ac2d7c7e07fc5bca35e3946adf9f88db203abd3a1d12b5e84f301d\",\"dweb:/ipfs/QmVjTKsQP8FgyQzJJUJmjCumC71yDtHbL6zhorsAFotw6e\"]},\"src/lib/LibDiamond.sol\":{\"keccak256\":\"0x2408a5742ee85ceba3764faeb0404945f813616fa2843b9cf8bffebdb5085fd6\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1689678b6df2cc8f41b2195cec791158ff5cfe948b49248f2d0d769fad01d716\",\"dweb:/ipfs/Qmd5nrZ4tWR798jfwc78dudXCy33eDQYYDfydbHJvqv1Hj\"]},\"src/lib/LibEpochController.sol\":{\"keccak256\":\"0x9ec3cc1629fd372eb13414bd72fd5bcbefc5cd750481a36a02a4ac238ec1ac27\",\"urls\":[\"bzz-raw://7853c5d97803412369707e2ce6d6b61dbafdfc1a7484416d7794ede472d3ec04\",\"dweb:/ipfs/QmaUJ9oxDn1YSb3W3UknHS55vJv8LSEE2ZvcRG3aJX3kzz\"]},\"src/lib/LibGlobalConst.sol\":{\"keccak256\":\"0x899ef42e736db9f6ddd94071c860e27f69b336c0e0d1a32dfc18970f48aefc28\",\"urls\":[\"bzz-raw://d5a09dd2351d99163ec681c3915e28dda0ef219a539575e5d7a583dd477a2626\",\"dweb:/ipfs/QmehyZpEVEWT7kAzNXgpvCKd6hdmyP7rAgVibNdDXw7oXh\"]},\"src/lib/LibOffer.sol\":{\"keccak256\":\"0xbb9b76631b08f4423689d6c40d036da8c2420c87e60106ec97f31918e51fd6e0\",\"urls\":[\"bzz-raw://6cd55b3fd614611beb0f0c88772a2ebc0aed303669d41701614a1e1026c6f354\",\"dweb:/ipfs/QmZEpzCXefMY7szjKP5sEYa7tjxkNjxcvDyjAJwTybmH3X\"]},\"src/lib/LibOfferV2.sol\":{\"keccak256\":\"0x4e96ad6d571206c893ddae4047f2d5e30e88e0ea8ed68729d33ce35d6a01f4c5\",\"urls\":[\"bzz-raw://a6ff9907626b310d25dba2476e2c870dcef82ea23463757a96b119c750ff02c0\",\"dweb:/ipfs/QmUdFMtyneei45pM7MYLeTy2gCEpCb3rad4QKApTangVjY\"]},\"src/lib/LibOraclePrice.sol\":{\"keccak256\":\"0x395e410d38bb7320f0777a65f58396f295498c03bc2a300463637d04af46717e\",\"urls\":[\"bzz-raw://823509ec0230f49c7cdedd000a8daa423e57be202da80c277b1de1ef75abbfa1\",\"dweb:/ipfs/QmYbvvcRLAe2vxyKy3SerB2FLEePzEjpFD5i73n4A3ooo9\"]},\"src/lib/LibSendValue.sol\":{\"keccak256\":\"0xe67baddfe971458758212379777a88b24f10ba64909074d8e5e67d9c02ff2bc4\",\"urls\":[\"bzz-raw://24248623a873707b25433758820b844d6d18ee42d86a0011ace915a4fc557aa6\",\"dweb:/ipfs/QmPKvoYAxMTVTEnxn5DjuCweAsAcwQsD3oKGgPK9xjXHS1\"]},\"src/utils/Common.sol\":{\"keccak256\":\"0x825b67051bb6656367c807d479fbcb3acfc05ddd40c2f808f53c56cc7df65241\",\"urls\":[\"bzz-raw://5ee9f171a17bd35b1970b84dc7c964a326694af177bda0531bc7fd2252029ecb\",\"dweb:/ipfs/QmXdMNVRuKhMdn5AT8BE8oZCo3X4QmRtZAE5Cw2CSHsrA9\"]},\"src/utils/OwnableUpgradableDiamond.sol\":{\"keccak256\":\"0xf83ea1de92817acc06f07c1af78884b7efe86a78240b745b026e79936b5b1dcf\",\"urls\":[\"bzz-raw://bae836e95b2c565a93e69e4041240144557f419c68d004fc0c990325689a0e52\",\"dweb:/ipfs/QmdioTWkPjMJRYjymujBEsa4RwRjcewFABEqTHW7Y4fm3S\"]}},\"version\":1}","userdoc":{},"devdoc":{"version":1,"kind":"dev"},"storageLayout":{"storage":[{"astId":61,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"stdstore","offset":0,"slot":"0","type":"t_struct(StdStorage)4565_storage"},{"astId":137,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"stdChainsInitialized","offset":0,"slot":"8","type":"t_bool"},{"astId":158,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"chains","offset":0,"slot":"9","type":"t_mapping(t_string_memory_ptr,t_struct(Chain)153_storage)"},{"astId":162,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"defaultRpcUrls","offset":0,"slot":"10","type":"t_mapping(t_string_memory_ptr,t_string_storage)"},{"astId":166,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"idToAlias","offset":0,"slot":"11","type":"t_mapping(t_uint256,t_string_storage)"},{"astId":169,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"fallbackToDefaultRpcUrls","offset":0,"slot":"12","type":"t_bool"},{"astId":972,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"gasMeteringOff","offset":1,"slot":"12","type":"t_bool"},{"astId":112,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"IS_SCRIPT","offset":2,"slot":"12","type":"t_bool"},{"astId":41428,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"deployment","offset":0,"slot":"13","type":"t_struct(DeploymentInfo)41425_storage"},{"astId":40992,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"fullDeploymentsPath","offset":0,"slot":"15","type":"t_string_storage"},{"astId":40994,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"envName","offset":0,"slot":"16","type":"t_string_storage"}],"types":{"t_address":{"encoding":"inplace","label":"address","numberOfBytes":"20"},"t_array(t_bytes32)dyn_storage":{"encoding":"dynamic_array","label":"bytes32[]","numberOfBytes":"32","base":"t_bytes32"},"t_array(t_string_storage)dyn_storage":{"encoding":"dynamic_array","label":"string[]","numberOfBytes":"32","base":"t_string_storage"},"t_bool":{"encoding":"inplace","label":"bool","numberOfBytes":"1"},"t_bytes32":{"encoding":"inplace","label":"bytes32","numberOfBytes":"32"},"t_bytes4":{"encoding":"inplace","label":"bytes4","numberOfBytes":"4"},"t_bytes_storage":{"encoding":"bytes","label":"bytes","numberOfBytes":"32"},"t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)4540_storage)))":{"encoding":"mapping","key":"t_address","label":"mapping(address => mapping(bytes4 => mapping(bytes32 => struct FindData)))","numberOfBytes":"32","value":"t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)4540_storage))"},"t_mapping(t_bytes32,t_struct(FindData)4540_storage)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => struct FindData)","numberOfBytes":"32","value":"t_struct(FindData)4540_storage"},"t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)4540_storage))":{"encoding":"mapping","key":"t_bytes4","label":"mapping(bytes4 => mapping(bytes32 => struct FindData))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_struct(FindData)4540_storage)"},"t_mapping(t_string_memory_ptr,t_string_storage)":{"encoding":"mapping","key":"t_string_memory_ptr","label":"mapping(string => string)","numberOfBytes":"32","value":"t_string_storage"},"t_mapping(t_string_memory_ptr,t_struct(Chain)153_storage)":{"encoding":"mapping","key":"t_string_memory_ptr","label":"mapping(string => struct StdChains.Chain)","numberOfBytes":"32","value":"t_struct(Chain)153_storage"},"t_mapping(t_string_memory_ptr,t_struct(DeployedContract)41416_storage)":{"encoding":"mapping","key":"t_string_memory_ptr","label":"mapping(string => struct Deployment.DeployedContract)","numberOfBytes":"32","value":"t_struct(DeployedContract)41416_storage"},"t_mapping(t_uint256,t_string_storage)":{"encoding":"mapping","key":"t_uint256","label":"mapping(uint256 => string)","numberOfBytes":"32","value":"t_string_storage"},"t_string_memory_ptr":{"encoding":"bytes","label":"string","numberOfBytes":"32"},"t_string_storage":{"encoding":"bytes","label":"string","numberOfBytes":"32"},"t_struct(Chain)153_storage":{"encoding":"inplace","label":"struct StdChains.Chain","numberOfBytes":"128","members":[{"astId":146,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"name","offset":0,"slot":"0","type":"t_string_storage"},{"astId":148,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"chainId","offset":0,"slot":"1","type":"t_uint256"},{"astId":150,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"chainAlias","offset":0,"slot":"2","type":"t_string_storage"},{"astId":152,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"rpcUrl","offset":0,"slot":"3","type":"t_string_storage"}]},"t_struct(DeployedContract)41416_storage":{"encoding":"inplace","label":"struct Deployment.DeployedContract","numberOfBytes":"128","members":[{"astId":41409,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"addr","offset":0,"slot":"0","type":"t_address"},{"astId":41411,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"codeHash","offset":0,"slot":"1","type":"t_bytes32"},{"astId":41413,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"blockNumber","offset":0,"slot":"2","type":"t_uint256"},{"astId":41415,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"creationCodeHash","offset":0,"slot":"3","type":"t_bytes32"}]},"t_struct(DeploymentInfo)41425_storage":{"encoding":"inplace","label":"struct Deployment.DeploymentInfo","numberOfBytes":"64","members":[{"astId":41419,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"contractNames","offset":0,"slot":"0","type":"t_array(t_string_storage)dyn_storage"},{"astId":41424,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"contracts","offset":0,"slot":"1","type":"t_mapping(t_string_memory_ptr,t_struct(DeployedContract)41416_storage)"}]},"t_struct(FindData)4540_storage":{"encoding":"inplace","label":"struct FindData","numberOfBytes":"128","members":[{"astId":4533,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"slot","offset":0,"slot":"0","type":"t_uint256"},{"astId":4535,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"offsetLeft","offset":0,"slot":"1","type":"t_uint256"},{"astId":4537,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"offsetRight","offset":0,"slot":"2","type":"t_uint256"},{"astId":4539,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"found","offset":0,"slot":"3","type":"t_bool"}]},"t_struct(StdStorage)4565_storage":{"encoding":"inplace","label":"struct StdStorage","numberOfBytes":"256","members":[{"astId":4549,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"finds","offset":0,"slot":"0","type":"t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_struct(FindData)4540_storage)))"},{"astId":4552,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"_keys","offset":0,"slot":"1","type":"t_array(t_bytes32)dyn_storage"},{"astId":4554,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"_sig","offset":0,"slot":"2","type":"t_bytes4"},{"astId":4556,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"_depth","offset":0,"slot":"3","type":"t_uint256"},{"astId":4558,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"_target","offset":0,"slot":"4","type":"t_address"},{"astId":4560,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"_set","offset":0,"slot":"5","type":"t_bytes32"},{"astId":4562,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"_enable_packed_slots","offset":0,"slot":"6","type":"t_bool"},{"astId":4564,"contract":"script/UpdateDiamondViewsMultisig.sol:UpdateDiamondViewsMultisig","label":"_calldata","offset":0,"slot":"7","type":"t_bytes_storage"}]},"t_uint256":{"encoding":"inplace","label":"uint256","numberOfBytes":"32"}}},"evm":{"bytecode":{"object":"608080604052346026576201000162ff00ff19600c541617600c556129db908161002b8239f35b5f80fdfe6080806040526004361015610012575f80fd5b5f905f3560e01c9081630a9254e414610d9957508063c0406226146100675763f8ccbf471461003f575f80fd5b34610064578060031936011261006457602060ff600c5460101c166040519015158152f35b80fd5b503461078c575f36600319011261078c575f805160206129268339815191523b1561078c57604051637fb5297f60e01b81525f81600481835f805160206129268339815191525af18015610d8e57610d7b575b506100cb6100c66113b8565b611a6a565b604061010181516100dc838261118f565b60138152720529ba30b93a103232b83637bcb4b73397171760691b6020820152611a26565b61011a61010c61145c565b61011461157c565b90611682565b61012561010c61145c565b9161013961013161145c565b610114611932565b8151637a0ed62760e01b815290936001600160a01b0316928582600481875afa918215610d71578692610c47575b5085946001600160a01b031691855b8151811015610c3c57836001600160a01b036101928385611a12565b515116146101a257600101610176565b5050909192935060015b15610bac57606093858451936101c2878661118f565b60028552601f198701825b818110610b7e57505060248651809481936356fe50af60e11b835260048301525afa908115610826578691610b39575b5083519061020a82611159565b8682526002602083015284820152610221836119e1565b5261022b826119e1565b50602093610261845161023e878261118f565b878152601f1987013688830137610253611932565b61025b611932565b9061257c565b5084519290610140610273818661118f565b60098552601f19013688860137631bd8adbb60e31b610291856119e1565b5260029363d60ec19d60e01b6102a682611a02565b526009600363013ba9ef60e21b6102be600285611a12565b526102c881612045565b90630c1cc57b60e41b906102dc9085611a12565b526102e681612045565b90635a6b57c560e11b906102fa9085611a12565b5261030481612045565b90630973a52f60e11b906103189085611a12565b5261032281612045565b9063074a9f0d60e11b906103369085611a12565b5261034081612045565b9063328922d160e11b906103549085611a12565b5261035e81612045565b9063683003df60e11b906103729085611a12565b5203610b11579088929187519161038883611159565b6001600160a01b03168252888201849052878201526103a686611a02565b526103b085611a02565b5085519387808601966307e4c70760e21b885260848701866024890152815180915260a48801908360a48260051b8b010193019187905b828210610a62575050505090610417918560448901528588820391602319830160648b015252808852018661118f565b6104388751610426898261118f565b60018152600560f91b8a820152611a26565b61048c8751610447868261118f565b602f81527f2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d204465706c6f796d656e7473202d2d8a8201526e2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d60881b89820152611a26565b600d5490835b888a87858410610919575050505050506104b26104ad6113b8565b612099565b6104e286516104c1888261118f565b601081526f0291195c1b1bde48199a5b9a5cda195960821b89820152611a26565b5f805160206129268339815191523b1561090b578551633b756e9b60e11b81528281600481835f805160206129268339815191525af1801561090f579083916108f6575b505061055d8651610537888261118f565b60158152740505052ab833b930b23290313cba32b1b7b2329d0560591b89820152611a26565b5f8087516305f3bfab60e11b8a82015289602482015261059281610584604482018a6115a1565b03601f19810183528261118f565b89815191016a636f6e736f6c652e6c6f675afa506105db86516105b5888261118f565b60158152740505051e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e8560591b89820152611a26565b8551630ce5723160e11b81526001600160a01b03821695909488866004818a5afa9586156108ec5784966108b9575b505f805160206129268339815191523b156108ab5787516303223eab60e11b815273eaf9135d113b720259d923c044d621e604e1b53360048201528481602481835f805160206129268339815191525af180156108af57908594939291610892575b50839051925af1903d1561088c57503d610685816111b2565b906106928651928361118f565b815286863d92013e5b15610830578251630ce5723160e11b8152908482600481865afa9182156108265786926107f7575b50036107a157908260049261070583516106dd858261118f565b60178152762234b33334b1bab63a3c903737ba1031b430b733b2b21d60491b84820152611a26565b8251630ce5723160e11b815293849182905afa918215610797578492610764575b50905f92839251916327b7cf8560e01b8284015260248301526024825261074e60448361118f565b815191016a636f6e736f6c652e6c6f675afa5080f35b91508282813d8311610790575b61077b818361118f565b8101031261078c579051905f610726565b5f80fd5b503d610771565b81513d86823e3d90fd5b815162461bcd60e51b815260048101849052602960248201527f5570646174654469616d6f6e644d756c74697369673a20646966666963756c746044820152681e4818da185b99d95960ba1b6064820152608490fd5b9091508481813d831161081f575b61080f818361118f565b8101031261078c5751905f6106c3565b503d610805565b84513d88823e3d90fd5b825162461bcd60e51b815260048101859052602f60248201527f5570646174654469616d6f6e644d756c74697369673a206661696c656420746f60448201526e081d5c19185d1948191a585b5bdb99608a1b6064820152608490fd5b5061069b565b8461089f9195929561118f565b6108ab5783925f61066c565b8380fd5b89513d87823e3d90fd5b89809297508195503d83116108e5575b6108d3818361118f565b8101031261078c57889251945f61060a565b503d6108c9565b88513d86823e3d90fd5b816109009161118f565b61090b57815f610526565b5080fd5b87513d85823e3d90fd5b91610a435f93928493610a2f88610a0560019a9b9c9d61094161093b8c612053565b506114de565b90885195600383519789818187019a808c835e8101600e8152030190208b519661096a88611174565b81546001600160a01b0316885260018201548b8901528101548c88015201549085015288519161099a8a8461118f565b6005835287830196641b5b39326d60d81b8852888b51916109bb8d8461118f565b6004835281830193631b5b306d60e01b85528d519a8b97518091858a015e87019083820190878252519283915e010190838252518092825e0190815203601f19810185528461118f565b898060a01b0390511691855195869463319af33360e01b90860152602485015260648401906115a1565b90604483015203601f19810183528261118f565b8c815191016a636f6e736f6c652e6c6f675afa50019089939291610492565b92959697509290935060a3198982030182528451908881019160018060a01b0381511682528d8101516003811015610afc57828f01528c0151818d018a90528051928390528d92608090920191908301908f905b808210610ad8575050509080600192960192019201928b938d979695936103e7565b82516001600160e01b03191684528f94938401939092019160019190910190610ab6565b50634e487b7160e01b8f52602160045260248ffd5b634e487b7160e01b89526001600452602489fd5b634e487b7160e01b5f52601160045260245ffd5b90503d8087833e610b4a818361118f565b8101602082820312610b7a5781516001600160401b038111610b7657610b709201611972565b5f6101fd565b8780fd5b8680fd5b6020919293508751610b8f81611159565b8a81528a83820152898982015282828901015201908892916101cd565b825162461bcd60e51b815260206004820152605e60248201527f5570646174654469616d6f6e6456696577734d756c74697369673a207669657760448201527f6572206661636574206e6f74206d6174636865642c2070726f6261626c79207960648201527f6f75206861766520756e77616e746564206c6f63616c206368616e6765730000608482015260a490fd5b5050909192936101ac565b9091503d8087833e610c59818361118f565b810190602081830312610b7a578051906001600160401b038211610b76570181601f82011215610b7a57805190610c8f8261195b565b92610c9c8651948561118f565b82845260208085019360051b83010191818311610d6d5760208101935b838510610ccc575050505050905f610167565b84516001600160401b038111610d695782019088601f198386030112610d6957885190818a016001600160401b03811183821017610d55578a5260208301516001600160a01b0381168103610d51578252828a0151916001600160401b038311610d5157610d4286602080969581960101611972565b83820152815201940193610cb9565b8d80fd5b634e487b7160e01b8e52604160045260248efd5b8b80fd5b8980fd5b83513d88823e3d90fd5b610d8791505f9061118f565b5f806100ba565b6040513d5f823e3d90fd5b3461078c575f36600319011261078c5763f877cb1960e01b81525f8180610dc260048201611245565b03815f805160206129268339815191525afa908115610d8e575f9161113f575b5080516001600160401b03811161101057610dfe601054611272565b601f8111611104575b50602091601f82116001146110a457610e29925f9183610f62575b50506112c0565b6010555b60405160208101815f601054610e4281611272565b906001811690811561108a5750600114611048575b50610e79918164173539b7b760d91b6005935203601a1981018552018361118f565b604051636c98507360e11b8152905f826004815f805160206129268339815191525afa908115610d8e57602093610f18935f93611024575b5084604051610ec160408261118f565b600d8152818101906c2f6465706c6f796d656e74732f60981b82526040519786899751918291018589015e860190838201905f8252519283915e0101905f8252518092825e015f815203601f19810183528261118f565b80516001600160401b03811161101057610f33600f54611272565b601f8111610fca575b50602091601f8211600114610f6d57610f5d925f9183610f625750506112c0565b600f55005b015190508380610e22565b601f19821692600f5f52805f20915f5b858110610fb257508360019510610f9a575b505050811b01600f55005b01515f1960f88460031b161c19169055828080610f8f565b91926020600181928685015181550194019201610f7d565b600f5f52611000905f80516020612986833981519152601f840160051c81019160208510611006575b601f0160051c01906112aa565b82610f3c565b9091508190610ff3565b634e487b7160e01b5f52604160045260245ffd5b6110419193503d805f833e611039818361118f565b810190611220565b9185610eb1565b91505060105f528260205f205f905b8382106110705750909182016020019050610e79610e57565b602091925080600191548385890101520191018491611057565b60ff19168552508015150282016020019050610e79610e57565b601f1982169260105f52805f20915f5b8581106110ec575083600195106110d4575b505050811b01601055610e2d565b01515f1960f88460031b161c191690558280806110c6565b919260206001819286850151815501940192016110b4565b60105f52611139905f80516020612966833981519152601f840160051c8101916020851061100657601f0160051c01906112aa565b82610e07565b61115391503d805f833e611039818361118f565b81610de2565b606081019081106001600160401b0382111761101057604052565b608081019081106001600160401b0382111761101057604052565b601f909101601f19168101906001600160401b0382119082101761101057604052565b6001600160401b03811161101057601f01601f191660200190565b9291926111d9826111b2565b916111e7604051938461118f565b82948184528183011161078c578281602093845f96015e010152565b9080601f8301121561078c57815161121d926020016111cd565b90565b9060208282031261078c5781516001600160401b03811161078c5761121d9201611203565b606090602081526012602082015271434f4e5452414354535f454e565f4e414d4560701b60408201520190565b90600182811c921680156112a0575b602083101461128c57565b634e487b7160e01b5f52602260045260245ffd5b91607f1691611281565b8181106112b5575050565b5f81556001016112aa565b8160011b915f199060031b1c19161790565b81519192916001600160401b038111611010576112ef8254611272565b601f8111611388575b506020601f821160011461132a57819061131b9394955f9261131f5750506112c0565b9055565b015190505f80610e22565b601f19821690835f52805f20915f5b81811061137057509583600195969710611358575b505050811b019055565b01515f1960f88460031b161c191690555f808061134e565b9192602060018192868b015181550194019201611339565b6113b290835f5260205f20601f840160051c8101916020851061100657601f0160051c01906112aa565b5f6112f8565b604051905f82600f54916113cb83611272565b808352926001811690811561143d57506001146113f1575b6113ef9250038361118f565b565b50600f5f90815290915f805160206129868339815191525b8183106114215750509060206113ef928201016113e3565b6020919350806001915483858901015201910190918492611409565b602092506113ef94915060ff191682840152151560051b8201016113e3565b604051905f826010549161146f83611272565b808352926001811690811561143d5750600114611492576113ef9250038361118f565b5060105f90815290915f805160206129668339815191525b8183106114c25750509060206113ef928201016113e3565b60209193508060019154838589010152019101909184926114aa565b9060405191825f8254926114f184611272565b808452936001811690811561155a5750600114611516575b506113ef9250038361118f565b90505f9291925260205f20905f915b81831061153e5750509060206113ef928201015f611509565b6020919350806001915483858901015201910190918492611525565b9050602092506113ef94915060ff191682840152151560051b8201015f611509565b6040519061158b60408361118f565b6007825266111a585b5bdb9960ca1b6020830152565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b906113ef60056021602094604051958691601760f91b828401528051918291018484015e8101641730b2323960d91b838201520301601a1981018552018361118f565b60208183031261078c578051906001600160401b03821161078c57019080601f8301121561078c57815161121d926020016111cd565b909161165561121d936040845260408401906115a1565b9160208184039101526115a1565b9081602091031261078c57516001600160a01b038116810361078c5790565b604051636c98507360e11b8152905f826004815f805160206129268339815191525afa918215610d8e576005600d602094611712935f91611918575b50856040519682889351918291018385015e82016c2f6465706c6f796d656e74732f60981b8282015286519081838901602d83015e010164173539b7b760d91b838201520301601a1981018552018361118f565b6117945f60409381808261175e885161172b8a8261118f565b6008815267706174683a20257360c01b60208201526105848a51938492634b5c427760e01b60208501526024840161163e565b6020815191016a636f6e736f6c652e6c6f675afa508451809381926360f9bb1160e01b83526020600484015260248301906115a1565b03815f805160206129268339815191525afa9081156118f4576117df915f9182916118fe575b506117c4866115c5565b85516385940ef160e01b81529384928392906004840161163e565b03815f805160206129268339815191525afa9081156118f4575f936118a68594611894611882956118ba9588916118d2575b5080516001600160a01b039161182f91810160209081019101611663565b169884519461183e818761118f565b6015865274636f6e74726163742025734025732069733a20257360581b602087015251968795631b55cbd160e21b60208801526080602488015260a48701906115a1565b858103602319016044870152906115a1565b838103602319016064850152906115a1565b86608483015203601f19810183528261118f565b6020815191016a636f6e736f6c652e6c6f675afa5090565b6118ee91503d808a833e6118e6818361118f565b810190611608565b5f611811565b83513d5f823e3d90fd5b61191291503d8084833e611039818361118f565b5f6117ba565b61192c91503d805f833e611039818361118f565b5f6116be565b6040519061194160408361118f565b600b82526a159a595dd95c919858d95d60aa1b6020830152565b6001600160401b0381116110105760051b60200190565b9080601f8301121561078c5781519061198a8261195b565b92611998604051948561118f565b82845260208085019360051b82010191821161078c57602001915b8183106119c05750505090565b82516001600160e01b03198116810361078c578152602092830192016119b3565b8051156119ee5760200190565b634e487b7160e01b5f52603260045260245ffd5b8051600110156119ee5760400190565b80518210156119ee5760209160051b010190565b5f610584611a53829360405192839163104c13eb60e21b60208401526020602484015260448301906115a1565b6020815191016a636f6e736f6c652e6c6f675afa50565b60405163130d191f60e11b81526020600482018190528180611a8f60248201866115a1565b03815f5f805160206129268339815191525af1908115610d8e575f9161200a575b501561200757905f611ade92604051809481926360f9bb1160e01b83526020600484015260248301906115a1565b03815f805160206129268339815191525afa918215610d8e575f92611feb575b50604051630427c83360e31b8152604060048201525f816020611b2460448301876115a1565b8383820391600319830160248601525201815f805160206129268339815191525afa908115610d8e575f91611f3a575b508051600160401b811161101057600d5481600d55808210611eb8575b50600d5f9081525f80516020612946833981519152602084015b838310611e9b57505050505f5b8151811015611e955780611baf611bfd9284611a12565b5160405190611bbd82611174565b5f8252602082015f8152604083015f815260608401915f83525f611be0856115c5565b6040516385940ef160e01b81529889918291908e6004840161163e565b03815f805160206129268339815191525afa8015610d8e57611ca5975f91611e7b575b5080516001600160a01b0391611c3e91810160209081019101611663565b168552604051601760f91b60208201525f855191611c88600960218360208b019680888484015e81016805cc6dec8ca90c2e6d60bb1b83820152030160161981018452018261118f565b6040516385940ef160e01b8152998a918291908f6004840161163e565b03815f805160206129268339815191525afa978815610d8e575f98611e5f575b506020885198818082019a8b920101031261078c57611d25975182525f604051601760f91b6020820152611c88600c6021838a5180888484015e81016b17313637b1b5a73ab6b132b960a11b83820152030160131981018452018261118f565b03815f805160206129268339815191525afa978815610d8e575f98611e43575b5060208880518101031261078c576020611da698015183525f604051601760f91b6020820152611c8860116021838a5180888484015e81017005cc6e4cac2e8d2dedc86dec8ca90c2e6d607b1b838201520301600e1981018452018261118f565b03815f805160206129268339815191525afa978815610d8e575f98611e27575b506020885198818082019a8b920101031261078c576020600395600199518652604051928391518091835e8101600e81520301902094878060a01b03905116878060a01b031986541617855551868501555160028401555191015501611b98565b611e3c9198503d805f833e6118e6818361118f565b965f611dc6565b611e589198503d805f833e6118e6818361118f565b965f611d45565b611e749198503d805f833e6118e6818361118f565b965f611cc5565b611e8f91503d805f833e6118e6818361118f565b5f611c20565b50509050565b6001602082611eac839451866112d2565b01920192019190611b8b565b600d5f525f805160206129468339815191529081019082015b818110611ede5750611b71565b80611eeb60019254611272565b80611ef8575b5001611ed1565b601f81118314611f0d57505f81555b5f611ef1565b611f2990825f5283601f60205f20920160051c820191016112aa565b805f525f6020812081835555611f07565b90503d805f833e611f4b818361118f565b81019060208183031261078c578051906001600160401b03821161078c57019080601f8301121561078c578151611f818161195b565b92611f8f604051948561118f565b81845260208085019260051b8201019183831161078c5760208201905b838210611fbe5750505050505f611b54565b81516001600160401b03811161078c57602091611fe087848094880101611203565b815201910190611fac565b6120009192503d805f833e611039818361118f565b905f611afe565b50565b90506020813d60201161203d575b816120256020938361118f565b8101031261078c5751801515810361078c575f611ab0565b3d9150612018565b5f198114610b255760010190565b600d548110156119ee57600d5f5260205f2001905f90565b6040519061207a60408361118f565b601082526f0c6e4cac2e8d2dedc86dec8ca90c2e6d60831b6020830152565b905f90602090604051936120ad838661118f565b5f85526040516120bd848261118f565b5f8152915f946040935b600d5487101561236457506120de61093b87612053565b84518681835180838601835e8101600e81520301902085519061210082611174565b80546001600160a01b031682526001810154888301908152600282015488840190815260039092015460608401908152885163f877cb1960e01b81529093905f818061214e60048201611245565b03815f805160206129268339815191525afa90811561235a579161219d8b5f938e6121e6968692612334575b50641b1bd8d85b60da1b906121918451948561118f565b60058452830152612431565b612325575b518a516001600160a01b03909116906121bb8c8261118f565b600481526330b2323960e11b8d8201528b519384928392634b96303160e11b84528a6004850161245e565b0381835f805160206129268339815191525af1801561231b57906122329291612303575b505188516122188a8261118f565b60088152670c6dec8ca90c2e6d60c31b8b82015285612498565b50515f61229288516122448a8261118f565b600b81526a313637b1b5a73ab6b132b960a91b8b820152895163094f480160e11b8152606060048201529384928392612280606485018a6115a1565b848103600319016024860152906115a1565b9060448301520381835f805160206129268339815191525af180156122f9576122d992600194926122d2926122e1575b50516122cc61206b565b83612498565b908a612504565b9601956120c7565b6122f4903d805f833e611039818361118f565b6122c2565b87513d5f823e3d90fd5b612316903d805f833e611039818361118f565b61220a565b89513d5f823e3d90fd5b600185528184528186526121a2565b641b1bd8d85b60da1b919250612353903d8089833e611039818361118f565b919061217a565b8a513d5f823e3d90fd5b91955092919550612383825161237a868261118f565b5f815282612431565b612429575f805160206129268339815191523b1561078c57815163e23cd19f60e01b8152955f91879182916123bc91906004840161163e565b0381835f805160206129268339815191525af194851561241f576120079495612408575b506123ed9051928361118f565b8152612401816123fb61206b565b81612504565b9080612504565b6124159192505f9061118f565b5f906123ed6123e0565b50513d5f823e3d90fd5b505050509050565b9081518151908181149384612448575b5050505090565b602092939450820120920120145f808080612441565b916124889061247a6040939695966060865260608601906115a1565b9084820360208601526115a1565b6001600160a01b03909416910152565b604051630b604ad160e21b815260606004820152925f9284928392916124c6916122809060648601906115a1565b9060448301520381835f805160206129268339815191525af1908115610d8e575f916124f0575090565b61121d91503d805f833e611039818361118f565b612534906125585f939461254660405196879586956388da6d3560e01b87526060600488015260648701906115a1565b858103600319016024870152906115a1565b838103600319016044850152906115a1565b0381835f805160206129268339815191525af1908115610d8e575f916124f0575090565b929192604051815190602081818501938085835e8101600e81520301902094604051906125a882611174565b60018060a01b038754168252602061260c600482600360018c01549b8288019c8d526002810154604089015201549860608701998a526040519481869251918291018484015e8101630b9cdbdb60e21b838201520301601b1981018452018261118f565b604051638d1cc92560e01b815260206004820152915f838061263160248201866115a1565b03815f805160206129268339815191525afa928315610d8e575f936128d2575b505f6020926126956126b79385604051968792818085019a8051918291018c5e840190828201888152815193849201905e010184815203601f19810186528561118f565b60405180938192630fafdced60e21b83526020600484015260248301906115a1565b03815f805160206129268339815191525afa908115610d8e575f916128b8575b5080516020909101208151832093516001600160a01b0316801599919790918a156128ac575b5089156128a0575b508815612896575b881561285b575051905ff0936001600160a01b03851691821561281a57879360039260409161276489898551612743878261118f565b600f81526e4465706c6f7920257320617420257360881b60208201526128fd565b82519561277087611174565b865260208601918252602083870193438552606088019586525180928a518091835e600e90820190815203019020945185546001600160a01b0319166001600160a01b0391909116178555516001850155516002840155519101556127d457509190565b600d54600160401b811015611010578060016127f39201600d55612053565b91909161280757612803916112d2565b9190565b634e487b7160e01b5f525f60045260245ffd5b60405162461bcd60e51b815260206004820152601960248201527811985a5b1959081d1bc819195c1b1bde4818dbdb9d1c9858dd603a1b6044820152606490fd5b955050505050816128039160405161287460408261118f565b601081526f52657573696e6720257320617420257360801b60208201526128fd565b803f15985061270d565b5184141598505f612705565b5188141599505f6126fd565b6128cc91503d805f833e6118e6818361118f565b5f6126d7565b6126b79193506020926126956128f25f933d8086833e6118e6818361118f565b959350509250612651565b90611a535f939261058485946040519485936395ed019560e01b60208601526024850161245e56fe0000000000000000000000007109709ecfa91a80626ff3989d68f67f5b1dd12dd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb51b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae6728d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802a2646970667358221220f5fe9fb284da202219ac25c91922c4f30ee6d13fd9b7ced7e867f21a10b32d9b64736f6c634300081a0033","opcodes":"PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x26 JUMPI PUSH3 0x10001 PUSH3 0xFF00FF NOT PUSH1 0xC SLOAD AND OR PUSH1 0xC SSTORE PUSH2 0x29DB SWAP1 DUP2 PUSH2 0x2B DUP3 CODECOPY RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT ISZERO PUSH2 0x12 JUMPI PUSH0 DUP1 REVERT JUMPDEST PUSH0 SWAP1 PUSH0 CALLDATALOAD PUSH1 0xE0 SHR SWAP1 DUP2 PUSH4 0xA9254E4 EQ PUSH2 0xD99 JUMPI POP DUP1 PUSH4 0xC0406226 EQ PUSH2 0x67 JUMPI PUSH4 0xF8CCBF47 EQ PUSH2 0x3F JUMPI PUSH0 DUP1 REVERT JUMPDEST CALLVALUE PUSH2 0x64 JUMPI DUP1 PUSH1 0x3 NOT CALLDATASIZE ADD SLT PUSH2 0x64 JUMPI PUSH1 0x20 PUSH1 0xFF PUSH1 0xC SLOAD PUSH1 0x10 SHR AND PUSH1 0x40 MLOAD SWAP1 ISZERO ISZERO DUP2 MSTORE RETURN JUMPDEST DUP1 REVERT JUMPDEST POP CALLVALUE PUSH2 0x78C JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x78C JUMPI PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x78C JUMPI PUSH1 0x40 MLOAD PUSH4 0x7FB5297F PUSH1 0xE0 SHL DUP2 MSTORE PUSH0 DUP2 PUSH1 0x4 DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0xD8E JUMPI PUSH2 0xD7B JUMPI JUMPDEST POP PUSH2 0xCB PUSH2 0xC6 PUSH2 0x13B8 JUMP JUMPDEST PUSH2 0x1A6A JUMP JUMPDEST PUSH1 0x40 PUSH2 0x101 DUP2 MLOAD PUSH2 0xDC DUP4 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x13 DUP2 MSTORE PUSH19 0x529BA30B93A103232B83637BCB4B733971717 PUSH1 0x69 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH2 0x11A PUSH2 0x10C PUSH2 0x145C JUMP JUMPDEST PUSH2 0x114 PUSH2 0x157C JUMP JUMPDEST SWAP1 PUSH2 0x1682 JUMP JUMPDEST PUSH2 0x125 PUSH2 0x10C PUSH2 0x145C JUMP JUMPDEST SWAP2 PUSH2 0x139 PUSH2 0x131 PUSH2 0x145C JUMP JUMPDEST PUSH2 0x114 PUSH2 0x1932 JUMP JUMPDEST DUP2 MLOAD PUSH4 0x7A0ED627 PUSH1 0xE0 SHL DUP2 MSTORE SWAP1 SWAP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP3 DUP6 DUP3 PUSH1 0x4 DUP2 DUP8 GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0xD71 JUMPI DUP7 SWAP3 PUSH2 0xC47 JUMPI JUMPDEST POP DUP6 SWAP5 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP2 DUP6 JUMPDEST DUP2 MLOAD DUP2 LT ISZERO PUSH2 0xC3C JUMPI DUP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB PUSH2 0x192 DUP4 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MLOAD MLOAD AND EQ PUSH2 0x1A2 JUMPI PUSH1 0x1 ADD PUSH2 0x176 JUMP JUMPDEST POP POP SWAP1 SWAP2 SWAP3 SWAP4 POP PUSH1 0x1 JUMPDEST ISZERO PUSH2 0xBAC JUMPI PUSH1 0x60 SWAP4 DUP6 DUP5 MLOAD SWAP4 PUSH2 0x1C2 DUP8 DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x2 DUP6 MSTORE PUSH1 0x1F NOT DUP8 ADD DUP3 JUMPDEST DUP2 DUP2 LT PUSH2 0xB7E JUMPI POP POP PUSH1 0x24 DUP7 MLOAD DUP1 SWAP5 DUP2 SWAP4 PUSH4 0x56FE50AF PUSH1 0xE1 SHL DUP4 MSTORE PUSH1 0x4 DUP4 ADD MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x826 JUMPI DUP7 SWAP2 PUSH2 0xB39 JUMPI JUMPDEST POP DUP4 MLOAD SWAP1 PUSH2 0x20A DUP3 PUSH2 0x1159 JUMP JUMPDEST DUP7 DUP3 MSTORE PUSH1 0x2 PUSH1 0x20 DUP4 ADD MSTORE DUP5 DUP3 ADD MSTORE PUSH2 0x221 DUP4 PUSH2 0x19E1 JUMP JUMPDEST MSTORE PUSH2 0x22B DUP3 PUSH2 0x19E1 JUMP JUMPDEST POP PUSH1 0x20 SWAP4 PUSH2 0x261 DUP5 MLOAD PUSH2 0x23E DUP8 DUP3 PUSH2 0x118F JUMP JUMPDEST DUP8 DUP2 MSTORE PUSH1 0x1F NOT DUP8 ADD CALLDATASIZE DUP9 DUP4 ADD CALLDATACOPY PUSH2 0x253 PUSH2 0x1932 JUMP JUMPDEST PUSH2 0x25B PUSH2 0x1932 JUMP JUMPDEST SWAP1 PUSH2 0x257C JUMP JUMPDEST POP DUP5 MLOAD SWAP3 SWAP1 PUSH2 0x140 PUSH2 0x273 DUP2 DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x9 DUP6 MSTORE PUSH1 0x1F NOT ADD CALLDATASIZE DUP9 DUP7 ADD CALLDATACOPY PUSH4 0x1BD8ADBB PUSH1 0xE3 SHL PUSH2 0x291 DUP6 PUSH2 0x19E1 JUMP JUMPDEST MSTORE PUSH1 0x2 SWAP4 PUSH4 0xD60EC19D PUSH1 0xE0 SHL PUSH2 0x2A6 DUP3 PUSH2 0x1A02 JUMP JUMPDEST MSTORE PUSH1 0x9 PUSH1 0x3 PUSH4 0x13BA9EF PUSH1 0xE2 SHL PUSH2 0x2BE PUSH1 0x2 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x2C8 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0xC1CC57B PUSH1 0xE4 SHL SWAP1 PUSH2 0x2DC SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x2E6 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x5A6B57C5 PUSH1 0xE1 SHL SWAP1 PUSH2 0x2FA SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x304 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x973A52F PUSH1 0xE1 SHL SWAP1 PUSH2 0x318 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x322 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x74A9F0D PUSH1 0xE1 SHL SWAP1 PUSH2 0x336 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x340 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x328922D1 PUSH1 0xE1 SHL SWAP1 PUSH2 0x354 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x35E DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x683003DF PUSH1 0xE1 SHL SWAP1 PUSH2 0x372 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE SUB PUSH2 0xB11 JUMPI SWAP1 DUP9 SWAP3 SWAP2 DUP8 MLOAD SWAP2 PUSH2 0x388 DUP4 PUSH2 0x1159 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP3 MSTORE DUP9 DUP3 ADD DUP5 SWAP1 MSTORE DUP8 DUP3 ADD MSTORE PUSH2 0x3A6 DUP7 PUSH2 0x1A02 JUMP JUMPDEST MSTORE PUSH2 0x3B0 DUP6 PUSH2 0x1A02 JUMP JUMPDEST POP DUP6 MLOAD SWAP4 DUP8 DUP1 DUP7 ADD SWAP7 PUSH4 0x7E4C707 PUSH1 0xE2 SHL DUP9 MSTORE PUSH1 0x84 DUP8 ADD DUP7 PUSH1 0x24 DUP10 ADD MSTORE DUP2 MLOAD DUP1 SWAP2 MSTORE PUSH1 0xA4 DUP9 ADD SWAP1 DUP4 PUSH1 0xA4 DUP3 PUSH1 0x5 SHL DUP12 ADD ADD SWAP4 ADD SWAP2 DUP8 SWAP1 JUMPDEST DUP3 DUP3 LT PUSH2 0xA62 JUMPI POP POP POP POP SWAP1 PUSH2 0x417 SWAP2 DUP6 PUSH1 0x44 DUP10 ADD MSTORE DUP6 DUP9 DUP3 SUB SWAP2 PUSH1 0x23 NOT DUP4 ADD PUSH1 0x64 DUP12 ADD MSTORE MSTORE DUP1 DUP9 MSTORE ADD DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x438 DUP8 MLOAD PUSH2 0x426 DUP10 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x1 DUP2 MSTORE PUSH1 0x5 PUSH1 0xF9 SHL DUP11 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH2 0x48C DUP8 MLOAD PUSH2 0x447 DUP7 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x2F DUP2 MSTORE PUSH32 0x2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D204465706C6F796D656E7473202D2D DUP11 DUP3 ADD MSTORE PUSH15 0x2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D PUSH1 0x88 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH1 0xD SLOAD SWAP1 DUP4 JUMPDEST DUP9 DUP11 DUP8 DUP6 DUP5 LT PUSH2 0x919 JUMPI POP POP POP POP POP POP PUSH2 0x4B2 PUSH2 0x4AD PUSH2 0x13B8 JUMP JUMPDEST PUSH2 0x2099 JUMP JUMPDEST PUSH2 0x4E2 DUP7 MLOAD PUSH2 0x4C1 DUP9 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x10 DUP2 MSTORE PUSH16 0x291195C1B1BDE48199A5B9A5CDA1959 PUSH1 0x82 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x90B JUMPI DUP6 MLOAD PUSH4 0x3B756E9B PUSH1 0xE1 SHL DUP2 MSTORE DUP3 DUP2 PUSH1 0x4 DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x90F JUMPI SWAP1 DUP4 SWAP2 PUSH2 0x8F6 JUMPI JUMPDEST POP POP PUSH2 0x55D DUP7 MLOAD PUSH2 0x537 DUP9 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x15 DUP2 MSTORE PUSH21 0x505052AB833B930B23290313CBA32B1B7B2329D05 PUSH1 0x59 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH0 DUP1 DUP8 MLOAD PUSH4 0x5F3BFAB PUSH1 0xE1 SHL DUP11 DUP3 ADD MSTORE DUP10 PUSH1 0x24 DUP3 ADD MSTORE PUSH2 0x592 DUP2 PUSH2 0x584 PUSH1 0x44 DUP3 ADD DUP11 PUSH2 0x15A1 JUMP JUMPDEST SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST DUP10 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP PUSH2 0x5DB DUP7 MLOAD PUSH2 0x5B5 DUP9 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x15 DUP2 MSTORE PUSH21 0x505051E9E9E9E9E9E9E9E9E9E9E9E9E9E9E9E9E85 PUSH1 0x59 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST DUP6 MLOAD PUSH4 0xCE57231 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND SWAP6 SWAP1 SWAP5 DUP9 DUP7 PUSH1 0x4 DUP2 DUP11 GAS STATICCALL SWAP6 DUP7 ISZERO PUSH2 0x8EC JUMPI DUP5 SWAP7 PUSH2 0x8B9 JUMPI JUMPDEST POP PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x8AB JUMPI DUP8 MLOAD PUSH4 0x3223EAB PUSH1 0xE1 SHL DUP2 MSTORE PUSH20 0xEAF9135D113B720259D923C044D621E604E1B533 PUSH1 0x4 DUP3 ADD MSTORE DUP5 DUP2 PUSH1 0x24 DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x8AF JUMPI SWAP1 DUP6 SWAP5 SWAP4 SWAP3 SWAP2 PUSH2 0x892 JUMPI JUMPDEST POP DUP4 SWAP1 MLOAD SWAP3 GAS CALL SWAP1 RETURNDATASIZE ISZERO PUSH2 0x88C JUMPI POP RETURNDATASIZE PUSH2 0x685 DUP2 PUSH2 0x11B2 JUMP JUMPDEST SWAP1 PUSH2 0x692 DUP7 MLOAD SWAP3 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 MSTORE DUP7 DUP7 RETURNDATASIZE SWAP3 ADD RETURNDATACOPY JUMPDEST ISZERO PUSH2 0x830 JUMPI DUP3 MLOAD PUSH4 0xCE57231 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 DUP5 DUP3 PUSH1 0x4 DUP2 DUP7 GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0x826 JUMPI DUP7 SWAP3 PUSH2 0x7F7 JUMPI JUMPDEST POP SUB PUSH2 0x7A1 JUMPI SWAP1 DUP3 PUSH1 0x4 SWAP3 PUSH2 0x705 DUP4 MLOAD PUSH2 0x6DD DUP6 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x17 DUP2 MSTORE PUSH23 0x2234B33334B1BAB63A3C903737BA1031B430B733B2B21D PUSH1 0x49 SHL DUP5 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST DUP3 MLOAD PUSH4 0xCE57231 PUSH1 0xE1 SHL DUP2 MSTORE SWAP4 DUP5 SWAP2 DUP3 SWAP1 GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0x797 JUMPI DUP5 SWAP3 PUSH2 0x764 JUMPI JUMPDEST POP SWAP1 PUSH0 SWAP3 DUP4 SWAP3 MLOAD SWAP2 PUSH4 0x27B7CF85 PUSH1 0xE0 SHL DUP3 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD MSTORE PUSH1 0x24 DUP3 MSTORE PUSH2 0x74E PUSH1 0x44 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP DUP1 RETURN JUMPDEST SWAP2 POP DUP3 DUP3 DUP2 RETURNDATASIZE DUP4 GT PUSH2 0x790 JUMPI JUMPDEST PUSH2 0x77B DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI SWAP1 MLOAD SWAP1 PUSH0 PUSH2 0x726 JUMP JUMPDEST PUSH0 DUP1 REVERT JUMPDEST POP RETURNDATASIZE PUSH2 0x771 JUMP JUMPDEST DUP2 MLOAD RETURNDATASIZE DUP7 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP2 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP5 SWAP1 MSTORE PUSH1 0x29 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x5570646174654469616D6F6E644D756C74697369673A20646966666963756C74 PUSH1 0x44 DUP3 ADD MSTORE PUSH9 0x1E4818DA185B99D959 PUSH1 0xBA SHL PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 SWAP1 REVERT JUMPDEST SWAP1 SWAP2 POP DUP5 DUP2 DUP2 RETURNDATASIZE DUP4 GT PUSH2 0x81F JUMPI JUMPDEST PUSH2 0x80F DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI MLOAD SWAP1 PUSH0 PUSH2 0x6C3 JUMP JUMPDEST POP RETURNDATASIZE PUSH2 0x805 JUMP JUMPDEST DUP5 MLOAD RETURNDATASIZE DUP9 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP3 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP6 SWAP1 MSTORE PUSH1 0x2F PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x5570646174654469616D6F6E644D756C74697369673A206661696C656420746F PUSH1 0x44 DUP3 ADD MSTORE PUSH15 0x81D5C19185D1948191A585B5BDB99 PUSH1 0x8A SHL PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 SWAP1 REVERT JUMPDEST POP PUSH2 0x69B JUMP JUMPDEST DUP5 PUSH2 0x89F SWAP2 SWAP6 SWAP3 SWAP6 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x8AB JUMPI DUP4 SWAP3 PUSH0 PUSH2 0x66C JUMP JUMPDEST DUP4 DUP1 REVERT JUMPDEST DUP10 MLOAD RETURNDATASIZE DUP8 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP10 DUP1 SWAP3 SWAP8 POP DUP2 SWAP6 POP RETURNDATASIZE DUP4 GT PUSH2 0x8E5 JUMPI JUMPDEST PUSH2 0x8D3 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI DUP9 SWAP3 MLOAD SWAP5 PUSH0 PUSH2 0x60A JUMP JUMPDEST POP RETURNDATASIZE PUSH2 0x8C9 JUMP JUMPDEST DUP9 MLOAD RETURNDATASIZE DUP7 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP2 PUSH2 0x900 SWAP2 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x90B JUMPI DUP2 PUSH0 PUSH2 0x526 JUMP JUMPDEST POP DUP1 REVERT JUMPDEST DUP8 MLOAD RETURNDATASIZE DUP6 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST SWAP2 PUSH2 0xA43 PUSH0 SWAP4 SWAP3 DUP5 SWAP4 PUSH2 0xA2F DUP9 PUSH2 0xA05 PUSH1 0x1 SWAP11 SWAP12 SWAP13 SWAP14 PUSH2 0x941 PUSH2 0x93B DUP13 PUSH2 0x2053 JUMP JUMPDEST POP PUSH2 0x14DE JUMP JUMPDEST SWAP1 DUP9 MLOAD SWAP6 PUSH1 0x3 DUP4 MLOAD SWAP8 DUP10 DUP2 DUP2 DUP8 ADD SWAP11 DUP1 DUP13 DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 DUP12 MLOAD SWAP7 PUSH2 0x96A DUP9 PUSH2 0x1174 JUMP JUMPDEST DUP2 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP9 MSTORE PUSH1 0x1 DUP3 ADD SLOAD DUP12 DUP10 ADD MSTORE DUP2 ADD SLOAD DUP13 DUP9 ADD MSTORE ADD SLOAD SWAP1 DUP6 ADD MSTORE DUP9 MLOAD SWAP2 PUSH2 0x99A DUP11 DUP5 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x5 DUP4 MSTORE DUP8 DUP4 ADD SWAP7 PUSH5 0x1B5B39326D PUSH1 0xD8 SHL DUP9 MSTORE DUP9 DUP12 MLOAD SWAP2 PUSH2 0x9BB DUP14 DUP5 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x4 DUP4 MSTORE DUP2 DUP4 ADD SWAP4 PUSH4 0x1B5B306D PUSH1 0xE0 SHL DUP6 MSTORE DUP14 MLOAD SWAP11 DUP12 SWAP8 MLOAD DUP1 SWAP2 DUP6 DUP11 ADD MCOPY DUP8 ADD SWAP1 DUP4 DUP3 ADD SWAP1 DUP8 DUP3 MSTORE MLOAD SWAP3 DUP4 SWAP2 MCOPY ADD ADD SWAP1 DUP4 DUP3 MSTORE MLOAD DUP1 SWAP3 DUP3 MCOPY ADD SWAP1 DUP2 MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP6 MSTORE DUP5 PUSH2 0x118F JUMP JUMPDEST DUP10 DUP1 PUSH1 0xA0 SHL SUB SWAP1 MLOAD AND SWAP2 DUP6 MLOAD SWAP6 DUP7 SWAP5 PUSH4 0x319AF333 PUSH1 0xE0 SHL SWAP1 DUP7 ADD MSTORE PUSH1 0x24 DUP6 ADD MSTORE PUSH1 0x64 DUP5 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 PUSH1 0x44 DUP4 ADD MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST DUP13 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP ADD SWAP1 DUP10 SWAP4 SWAP3 SWAP2 PUSH2 0x492 JUMP JUMPDEST SWAP3 SWAP6 SWAP7 SWAP8 POP SWAP3 SWAP1 SWAP4 POP PUSH1 0xA3 NOT DUP10 DUP3 SUB ADD DUP3 MSTORE DUP5 MLOAD SWAP1 DUP9 DUP2 ADD SWAP2 PUSH1 0x1 DUP1 PUSH1 0xA0 SHL SUB DUP2 MLOAD AND DUP3 MSTORE DUP14 DUP2 ADD MLOAD PUSH1 0x3 DUP2 LT ISZERO PUSH2 0xAFC JUMPI DUP3 DUP16 ADD MSTORE DUP13 ADD MLOAD DUP2 DUP14 ADD DUP11 SWAP1 MSTORE DUP1 MLOAD SWAP3 DUP4 SWAP1 MSTORE DUP14 SWAP3 PUSH1 0x80 SWAP1 SWAP3 ADD SWAP2 SWAP1 DUP4 ADD SWAP1 DUP16 SWAP1 JUMPDEST DUP1 DUP3 LT PUSH2 0xAD8 JUMPI POP POP POP SWAP1 DUP1 PUSH1 0x1 SWAP3 SWAP7 ADD SWAP3 ADD SWAP3 ADD SWAP3 DUP12 SWAP4 DUP14 SWAP8 SWAP7 SWAP6 SWAP4 PUSH2 0x3E7 JUMP JUMPDEST DUP3 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT AND DUP5 MSTORE DUP16 SWAP5 SWAP4 DUP5 ADD SWAP4 SWAP1 SWAP3 ADD SWAP2 PUSH1 0x1 SWAP2 SWAP1 SWAP2 ADD SWAP1 PUSH2 0xAB6 JUMP JUMPDEST POP PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP16 MSTORE PUSH1 0x21 PUSH1 0x4 MSTORE PUSH1 0x24 DUP16 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP10 MSTORE PUSH1 0x1 PUSH1 0x4 MSTORE PUSH1 0x24 DUP10 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST SWAP1 POP RETURNDATASIZE DUP1 DUP8 DUP4 RETURNDATACOPY PUSH2 0xB4A DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD PUSH1 0x20 DUP3 DUP3 SUB SLT PUSH2 0xB7A JUMPI DUP2 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0xB76 JUMPI PUSH2 0xB70 SWAP3 ADD PUSH2 0x1972 JUMP JUMPDEST PUSH0 PUSH2 0x1FD JUMP JUMPDEST DUP8 DUP1 REVERT JUMPDEST DUP7 DUP1 REVERT JUMPDEST PUSH1 0x20 SWAP2 SWAP3 SWAP4 POP DUP8 MLOAD PUSH2 0xB8F DUP2 PUSH2 0x1159 JUMP JUMPDEST DUP11 DUP2 MSTORE DUP11 DUP4 DUP3 ADD MSTORE DUP10 DUP10 DUP3 ADD MSTORE DUP3 DUP3 DUP10 ADD ADD MSTORE ADD SWAP1 DUP9 SWAP3 SWAP2 PUSH2 0x1CD JUMP JUMPDEST DUP3 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x5E PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x5570646174654469616D6F6E6456696577734D756C74697369673A2076696577 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x6572206661636574206E6F74206D6174636865642C2070726F6261626C792079 PUSH1 0x64 DUP3 ADD MSTORE PUSH32 0x6F75206861766520756E77616E746564206C6F63616C206368616E6765730000 PUSH1 0x84 DUP3 ADD MSTORE PUSH1 0xA4 SWAP1 REVERT JUMPDEST POP POP SWAP1 SWAP2 SWAP3 SWAP4 PUSH2 0x1AC JUMP JUMPDEST SWAP1 SWAP2 POP RETURNDATASIZE DUP1 DUP8 DUP4 RETURNDATACOPY PUSH2 0xC59 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH1 0x20 DUP2 DUP4 SUB SLT PUSH2 0xB7A JUMPI DUP1 MLOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT PUSH2 0xB76 JUMPI ADD DUP2 PUSH1 0x1F DUP3 ADD SLT ISZERO PUSH2 0xB7A JUMPI DUP1 MLOAD SWAP1 PUSH2 0xC8F DUP3 PUSH2 0x195B JUMP JUMPDEST SWAP3 PUSH2 0xC9C DUP7 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST DUP3 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP4 PUSH1 0x5 SHL DUP4 ADD ADD SWAP2 DUP2 DUP4 GT PUSH2 0xD6D JUMPI PUSH1 0x20 DUP2 ADD SWAP4 JUMPDEST DUP4 DUP6 LT PUSH2 0xCCC JUMPI POP POP POP POP POP SWAP1 PUSH0 PUSH2 0x167 JUMP JUMPDEST DUP5 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0xD69 JUMPI DUP3 ADD SWAP1 DUP9 PUSH1 0x1F NOT DUP4 DUP7 SUB ADD SLT PUSH2 0xD69 JUMPI DUP9 MLOAD SWAP1 DUP2 DUP11 ADD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT DUP4 DUP3 LT OR PUSH2 0xD55 JUMPI DUP11 MSTORE PUSH1 0x20 DUP4 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 SUB PUSH2 0xD51 JUMPI DUP3 MSTORE DUP3 DUP11 ADD MLOAD SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP4 GT PUSH2 0xD51 JUMPI PUSH2 0xD42 DUP7 PUSH1 0x20 DUP1 SWAP7 SWAP6 DUP2 SWAP7 ADD ADD PUSH2 0x1972 JUMP JUMPDEST DUP4 DUP3 ADD MSTORE DUP2 MSTORE ADD SWAP5 ADD SWAP4 PUSH2 0xCB9 JUMP JUMPDEST DUP14 DUP1 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP15 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 DUP15 REVERT JUMPDEST DUP12 DUP1 REVERT JUMPDEST DUP10 DUP1 REVERT JUMPDEST DUP4 MLOAD RETURNDATASIZE DUP9 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH2 0xD87 SWAP2 POP PUSH0 SWAP1 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP1 PUSH2 0xBA JUMP JUMPDEST PUSH1 0x40 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST CALLVALUE PUSH2 0x78C JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x78C JUMPI PUSH4 0xF877CB19 PUSH1 0xE0 SHL DUP2 MSTORE PUSH0 DUP2 DUP1 PUSH2 0xDC2 PUSH1 0x4 DUP3 ADD PUSH2 0x1245 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x113F JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH2 0xDFE PUSH1 0x10 SLOAD PUSH2 0x1272 JUMP JUMPDEST PUSH1 0x1F DUP2 GT PUSH2 0x1104 JUMPI JUMPDEST POP PUSH1 0x20 SWAP2 PUSH1 0x1F DUP3 GT PUSH1 0x1 EQ PUSH2 0x10A4 JUMPI PUSH2 0xE29 SWAP3 PUSH0 SWAP2 DUP4 PUSH2 0xF62 JUMPI JUMPDEST POP POP PUSH2 0x12C0 JUMP JUMPDEST PUSH1 0x10 SSTORE JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 ADD DUP2 PUSH0 PUSH1 0x10 SLOAD PUSH2 0xE42 DUP2 PUSH2 0x1272 JUMP JUMPDEST SWAP1 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x108A JUMPI POP PUSH1 0x1 EQ PUSH2 0x1048 JUMPI JUMPDEST POP PUSH2 0xE79 SWAP2 DUP2 PUSH5 0x173539B7B7 PUSH1 0xD9 SHL PUSH1 0x5 SWAP4 MSTORE SUB PUSH1 0x1A NOT DUP2 ADD DUP6 MSTORE ADD DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x6C985073 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 PUSH0 DUP3 PUSH1 0x4 DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH1 0x20 SWAP4 PUSH2 0xF18 SWAP4 PUSH0 SWAP4 PUSH2 0x1024 JUMPI JUMPDEST POP DUP5 PUSH1 0x40 MLOAD PUSH2 0xEC1 PUSH1 0x40 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xD DUP2 MSTORE DUP2 DUP2 ADD SWAP1 PUSH13 0x2F6465706C6F796D656E74732F PUSH1 0x98 SHL DUP3 MSTORE PUSH1 0x40 MLOAD SWAP8 DUP7 DUP10 SWAP8 MLOAD SWAP2 DUP3 SWAP2 ADD DUP6 DUP10 ADD MCOPY DUP7 ADD SWAP1 DUP4 DUP3 ADD SWAP1 PUSH0 DUP3 MSTORE MLOAD SWAP3 DUP4 SWAP2 MCOPY ADD ADD SWAP1 PUSH0 DUP3 MSTORE MLOAD DUP1 SWAP3 DUP3 MCOPY ADD PUSH0 DUP2 MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH2 0xF33 PUSH1 0xF SLOAD PUSH2 0x1272 JUMP JUMPDEST PUSH1 0x1F DUP2 GT PUSH2 0xFCA JUMPI JUMPDEST POP PUSH1 0x20 SWAP2 PUSH1 0x1F DUP3 GT PUSH1 0x1 EQ PUSH2 0xF6D JUMPI PUSH2 0xF5D SWAP3 PUSH0 SWAP2 DUP4 PUSH2 0xF62 JUMPI POP POP PUSH2 0x12C0 JUMP JUMPDEST PUSH1 0xF SSTORE STOP JUMPDEST ADD MLOAD SWAP1 POP DUP4 DUP1 PUSH2 0xE22 JUMP JUMPDEST PUSH1 0x1F NOT DUP3 AND SWAP3 PUSH1 0xF PUSH0 MSTORE DUP1 PUSH0 KECCAK256 SWAP2 PUSH0 JUMPDEST DUP6 DUP2 LT PUSH2 0xFB2 JUMPI POP DUP4 PUSH1 0x1 SWAP6 LT PUSH2 0xF9A JUMPI JUMPDEST POP POP POP DUP2 SHL ADD PUSH1 0xF SSTORE STOP JUMPDEST ADD MLOAD PUSH0 NOT PUSH1 0xF8 DUP5 PUSH1 0x3 SHL AND SHR NOT AND SWAP1 SSTORE DUP3 DUP1 DUP1 PUSH2 0xF8F JUMP JUMPDEST SWAP2 SWAP3 PUSH1 0x20 PUSH1 0x1 DUP2 SWAP3 DUP7 DUP6 ADD MLOAD DUP2 SSTORE ADD SWAP5 ADD SWAP3 ADD PUSH2 0xF7D JUMP JUMPDEST PUSH1 0xF PUSH0 MSTORE PUSH2 0x1000 SWAP1 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2986 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE PUSH1 0x1F DUP5 ADD PUSH1 0x5 SHR DUP2 ADD SWAP2 PUSH1 0x20 DUP6 LT PUSH2 0x1006 JUMPI JUMPDEST PUSH1 0x1F ADD PUSH1 0x5 SHR ADD SWAP1 PUSH2 0x12AA JUMP JUMPDEST DUP3 PUSH2 0xF3C JUMP JUMPDEST SWAP1 SWAP2 POP DUP2 SWAP1 PUSH2 0xFF3 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH2 0x1041 SWAP2 SWAP4 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH2 0x1220 JUMP JUMPDEST SWAP2 DUP6 PUSH2 0xEB1 JUMP JUMPDEST SWAP2 POP POP PUSH1 0x10 PUSH0 MSTORE DUP3 PUSH1 0x20 PUSH0 KECCAK256 PUSH0 SWAP1 JUMPDEST DUP4 DUP3 LT PUSH2 0x1070 JUMPI POP SWAP1 SWAP2 DUP3 ADD PUSH1 0x20 ADD SWAP1 POP PUSH2 0xE79 PUSH2 0xE57 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP3 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD DUP5 SWAP2 PUSH2 0x1057 JUMP JUMPDEST PUSH1 0xFF NOT AND DUP6 MSTORE POP DUP1 ISZERO ISZERO MUL DUP3 ADD PUSH1 0x20 ADD SWAP1 POP PUSH2 0xE79 PUSH2 0xE57 JUMP JUMPDEST PUSH1 0x1F NOT DUP3 AND SWAP3 PUSH1 0x10 PUSH0 MSTORE DUP1 PUSH0 KECCAK256 SWAP2 PUSH0 JUMPDEST DUP6 DUP2 LT PUSH2 0x10EC JUMPI POP DUP4 PUSH1 0x1 SWAP6 LT PUSH2 0x10D4 JUMPI JUMPDEST POP POP POP DUP2 SHL ADD PUSH1 0x10 SSTORE PUSH2 0xE2D JUMP JUMPDEST ADD MLOAD PUSH0 NOT PUSH1 0xF8 DUP5 PUSH1 0x3 SHL AND SHR NOT AND SWAP1 SSTORE DUP3 DUP1 DUP1 PUSH2 0x10C6 JUMP JUMPDEST SWAP2 SWAP3 PUSH1 0x20 PUSH1 0x1 DUP2 SWAP3 DUP7 DUP6 ADD MLOAD DUP2 SSTORE ADD SWAP5 ADD SWAP3 ADD PUSH2 0x10B4 JUMP JUMPDEST PUSH1 0x10 PUSH0 MSTORE PUSH2 0x1139 SWAP1 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2966 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE PUSH1 0x1F DUP5 ADD PUSH1 0x5 SHR DUP2 ADD SWAP2 PUSH1 0x20 DUP6 LT PUSH2 0x1006 JUMPI PUSH1 0x1F ADD PUSH1 0x5 SHR ADD SWAP1 PUSH2 0x12AA JUMP JUMPDEST DUP3 PUSH2 0xE07 JUMP JUMPDEST PUSH2 0x1153 SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 PUSH2 0xDE2 JUMP JUMPDEST PUSH1 0x60 DUP2 ADD SWAP1 DUP2 LT PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT OR PUSH2 0x1010 JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH1 0x80 DUP2 ADD SWAP1 DUP2 LT PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT OR PUSH2 0x1010 JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH1 0x1F SWAP1 SWAP2 ADD PUSH1 0x1F NOT AND DUP2 ADD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT SWAP1 DUP3 LT OR PUSH2 0x1010 JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH1 0x1F ADD PUSH1 0x1F NOT AND PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST SWAP3 SWAP2 SWAP3 PUSH2 0x11D9 DUP3 PUSH2 0x11B2 JUMP JUMPDEST SWAP2 PUSH2 0x11E7 PUSH1 0x40 MLOAD SWAP4 DUP5 PUSH2 0x118F JUMP JUMPDEST DUP3 SWAP5 DUP2 DUP5 MSTORE DUP2 DUP4 ADD GT PUSH2 0x78C JUMPI DUP3 DUP2 PUSH1 0x20 SWAP4 DUP5 PUSH0 SWAP7 ADD MCOPY ADD ADD MSTORE JUMP JUMPDEST SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH2 0x121D SWAP3 PUSH1 0x20 ADD PUSH2 0x11CD JUMP JUMPDEST SWAP1 JUMP JUMPDEST SWAP1 PUSH1 0x20 DUP3 DUP3 SUB SLT PUSH2 0x78C JUMPI DUP2 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x78C JUMPI PUSH2 0x121D SWAP3 ADD PUSH2 0x1203 JUMP JUMPDEST PUSH1 0x60 SWAP1 PUSH1 0x20 DUP2 MSTORE PUSH1 0x12 PUSH1 0x20 DUP3 ADD MSTORE PUSH18 0x434F4E5452414354535F454E565F4E414D45 PUSH1 0x70 SHL PUSH1 0x40 DUP3 ADD MSTORE ADD SWAP1 JUMP JUMPDEST SWAP1 PUSH1 0x1 DUP3 DUP2 SHR SWAP3 AND DUP1 ISZERO PUSH2 0x12A0 JUMPI JUMPDEST PUSH1 0x20 DUP4 LT EQ PUSH2 0x128C JUMPI JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST SWAP2 PUSH1 0x7F AND SWAP2 PUSH2 0x1281 JUMP JUMPDEST DUP2 DUP2 LT PUSH2 0x12B5 JUMPI POP POP JUMP JUMPDEST PUSH0 DUP2 SSTORE PUSH1 0x1 ADD PUSH2 0x12AA JUMP JUMPDEST DUP2 PUSH1 0x1 SHL SWAP2 PUSH0 NOT SWAP1 PUSH1 0x3 SHL SHR NOT AND OR SWAP1 JUMP JUMPDEST DUP2 MLOAD SWAP2 SWAP3 SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH2 0x12EF DUP3 SLOAD PUSH2 0x1272 JUMP JUMPDEST PUSH1 0x1F DUP2 GT PUSH2 0x1388 JUMPI JUMPDEST POP PUSH1 0x20 PUSH1 0x1F DUP3 GT PUSH1 0x1 EQ PUSH2 0x132A JUMPI DUP2 SWAP1 PUSH2 0x131B SWAP4 SWAP5 SWAP6 PUSH0 SWAP3 PUSH2 0x131F JUMPI POP POP PUSH2 0x12C0 JUMP JUMPDEST SWAP1 SSTORE JUMP JUMPDEST ADD MLOAD SWAP1 POP PUSH0 DUP1 PUSH2 0xE22 JUMP JUMPDEST PUSH1 0x1F NOT DUP3 AND SWAP1 DUP4 PUSH0 MSTORE DUP1 PUSH0 KECCAK256 SWAP2 PUSH0 JUMPDEST DUP2 DUP2 LT PUSH2 0x1370 JUMPI POP SWAP6 DUP4 PUSH1 0x1 SWAP6 SWAP7 SWAP8 LT PUSH2 0x1358 JUMPI JUMPDEST POP POP POP DUP2 SHL ADD SWAP1 SSTORE JUMP JUMPDEST ADD MLOAD PUSH0 NOT PUSH1 0xF8 DUP5 PUSH1 0x3 SHL AND SHR NOT AND SWAP1 SSTORE PUSH0 DUP1 DUP1 PUSH2 0x134E JUMP JUMPDEST SWAP2 SWAP3 PUSH1 0x20 PUSH1 0x1 DUP2 SWAP3 DUP7 DUP12 ADD MLOAD DUP2 SSTORE ADD SWAP5 ADD SWAP3 ADD PUSH2 0x1339 JUMP JUMPDEST PUSH2 0x13B2 SWAP1 DUP4 PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 PUSH1 0x1F DUP5 ADD PUSH1 0x5 SHR DUP2 ADD SWAP2 PUSH1 0x20 DUP6 LT PUSH2 0x1006 JUMPI PUSH1 0x1F ADD PUSH1 0x5 SHR ADD SWAP1 PUSH2 0x12AA JUMP JUMPDEST PUSH0 PUSH2 0x12F8 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH0 DUP3 PUSH1 0xF SLOAD SWAP2 PUSH2 0x13CB DUP4 PUSH2 0x1272 JUMP JUMPDEST DUP1 DUP4 MSTORE SWAP3 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x143D JUMPI POP PUSH1 0x1 EQ PUSH2 0x13F1 JUMPI JUMPDEST PUSH2 0x13EF SWAP3 POP SUB DUP4 PUSH2 0x118F JUMP JUMPDEST JUMP JUMPDEST POP PUSH1 0xF PUSH0 SWAP1 DUP2 MSTORE SWAP1 SWAP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2986 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE JUMPDEST DUP2 DUP4 LT PUSH2 0x1421 JUMPI POP POP SWAP1 PUSH1 0x20 PUSH2 0x13EF SWAP3 DUP3 ADD ADD PUSH2 0x13E3 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP4 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD SWAP1 SWAP2 DUP5 SWAP3 PUSH2 0x1409 JUMP JUMPDEST PUSH1 0x20 SWAP3 POP PUSH2 0x13EF SWAP5 SWAP2 POP PUSH1 0xFF NOT AND DUP3 DUP5 ADD MSTORE ISZERO ISZERO PUSH1 0x5 SHL DUP3 ADD ADD PUSH2 0x13E3 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH0 DUP3 PUSH1 0x10 SLOAD SWAP2 PUSH2 0x146F DUP4 PUSH2 0x1272 JUMP JUMPDEST DUP1 DUP4 MSTORE SWAP3 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x143D JUMPI POP PUSH1 0x1 EQ PUSH2 0x1492 JUMPI PUSH2 0x13EF SWAP3 POP SUB DUP4 PUSH2 0x118F JUMP JUMPDEST POP PUSH1 0x10 PUSH0 SWAP1 DUP2 MSTORE SWAP1 SWAP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2966 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE JUMPDEST DUP2 DUP4 LT PUSH2 0x14C2 JUMPI POP POP SWAP1 PUSH1 0x20 PUSH2 0x13EF SWAP3 DUP3 ADD ADD PUSH2 0x13E3 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP4 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD SWAP1 SWAP2 DUP5 SWAP3 PUSH2 0x14AA JUMP JUMPDEST SWAP1 PUSH1 0x40 MLOAD SWAP2 DUP3 PUSH0 DUP3 SLOAD SWAP3 PUSH2 0x14F1 DUP5 PUSH2 0x1272 JUMP JUMPDEST DUP1 DUP5 MSTORE SWAP4 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x155A JUMPI POP PUSH1 0x1 EQ PUSH2 0x1516 JUMPI JUMPDEST POP PUSH2 0x13EF SWAP3 POP SUB DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP1 POP PUSH0 SWAP3 SWAP2 SWAP3 MSTORE PUSH1 0x20 PUSH0 KECCAK256 SWAP1 PUSH0 SWAP2 JUMPDEST DUP2 DUP4 LT PUSH2 0x153E JUMPI POP POP SWAP1 PUSH1 0x20 PUSH2 0x13EF SWAP3 DUP3 ADD ADD PUSH0 PUSH2 0x1509 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP4 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD SWAP1 SWAP2 DUP5 SWAP3 PUSH2 0x1525 JUMP JUMPDEST SWAP1 POP PUSH1 0x20 SWAP3 POP PUSH2 0x13EF SWAP5 SWAP2 POP PUSH1 0xFF NOT AND DUP3 DUP5 ADD MSTORE ISZERO ISZERO PUSH1 0x5 SHL DUP3 ADD ADD PUSH0 PUSH2 0x1509 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH2 0x158B PUSH1 0x40 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x7 DUP3 MSTORE PUSH7 0x111A585B5BDB99 PUSH1 0xCA SHL PUSH1 0x20 DUP4 ADD MSTORE JUMP JUMPDEST DUP1 MLOAD DUP1 DUP4 MSTORE PUSH1 0x20 SWAP3 SWAP2 DUP2 SWAP1 DUP5 ADD DUP5 DUP5 ADD MCOPY PUSH0 DUP3 DUP3 ADD DUP5 ADD MSTORE PUSH1 0x1F ADD PUSH1 0x1F NOT AND ADD ADD SWAP1 JUMP JUMPDEST SWAP1 PUSH2 0x13EF PUSH1 0x5 PUSH1 0x21 PUSH1 0x20 SWAP5 PUSH1 0x40 MLOAD SWAP6 DUP7 SWAP2 PUSH1 0x17 PUSH1 0xF9 SHL DUP3 DUP5 ADD MSTORE DUP1 MLOAD SWAP2 DUP3 SWAP2 ADD DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH5 0x1730B23239 PUSH1 0xD9 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x1A NOT DUP2 ADD DUP6 MSTORE ADD DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x20 DUP2 DUP4 SUB SLT PUSH2 0x78C JUMPI DUP1 MLOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT PUSH2 0x78C JUMPI ADD SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH2 0x121D SWAP3 PUSH1 0x20 ADD PUSH2 0x11CD JUMP JUMPDEST SWAP1 SWAP2 PUSH2 0x1655 PUSH2 0x121D SWAP4 PUSH1 0x40 DUP5 MSTORE PUSH1 0x40 DUP5 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP2 PUSH1 0x20 DUP2 DUP5 SUB SWAP2 ADD MSTORE PUSH2 0x15A1 JUMP JUMPDEST SWAP1 DUP2 PUSH1 0x20 SWAP2 SUB SLT PUSH2 0x78C JUMPI MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 SUB PUSH2 0x78C JUMPI SWAP1 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x6C985073 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 PUSH0 DUP3 PUSH1 0x4 DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0xD8E JUMPI PUSH1 0x5 PUSH1 0xD PUSH1 0x20 SWAP5 PUSH2 0x1712 SWAP4 PUSH0 SWAP2 PUSH2 0x1918 JUMPI JUMPDEST POP DUP6 PUSH1 0x40 MLOAD SWAP7 DUP3 DUP9 SWAP4 MLOAD SWAP2 DUP3 SWAP2 ADD DUP4 DUP6 ADD MCOPY DUP3 ADD PUSH13 0x2F6465706C6F796D656E74732F PUSH1 0x98 SHL DUP3 DUP3 ADD MSTORE DUP7 MLOAD SWAP1 DUP2 DUP4 DUP10 ADD PUSH1 0x2D DUP4 ADD MCOPY ADD ADD PUSH5 0x173539B7B7 PUSH1 0xD9 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x1A NOT DUP2 ADD DUP6 MSTORE ADD DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x1794 PUSH0 PUSH1 0x40 SWAP4 DUP2 DUP1 DUP3 PUSH2 0x175E DUP9 MLOAD PUSH2 0x172B DUP11 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x8 DUP2 MSTORE PUSH8 0x706174683A202573 PUSH1 0xC0 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x584 DUP11 MLOAD SWAP4 DUP5 SWAP3 PUSH4 0x4B5C4277 PUSH1 0xE0 SHL PUSH1 0x20 DUP6 ADD MSTORE PUSH1 0x24 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST PUSH1 0x20 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP DUP5 MLOAD DUP1 SWAP4 DUP2 SWAP3 PUSH4 0x60F9BB11 PUSH1 0xE0 SHL DUP4 MSTORE PUSH1 0x20 PUSH1 0x4 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x18F4 JUMPI PUSH2 0x17DF SWAP2 PUSH0 SWAP2 DUP3 SWAP2 PUSH2 0x18FE JUMPI JUMPDEST POP PUSH2 0x17C4 DUP7 PUSH2 0x15C5 JUMP JUMPDEST DUP6 MLOAD PUSH4 0x85940EF1 PUSH1 0xE0 SHL DUP2 MSTORE SWAP4 DUP5 SWAP3 DUP4 SWAP3 SWAP1 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x18F4 JUMPI PUSH0 SWAP4 PUSH2 0x18A6 DUP6 SWAP5 PUSH2 0x1894 PUSH2 0x1882 SWAP6 PUSH2 0x18BA SWAP6 DUP9 SWAP2 PUSH2 0x18D2 JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 PUSH2 0x182F SWAP2 DUP2 ADD PUSH1 0x20 SWAP1 DUP2 ADD SWAP2 ADD PUSH2 0x1663 JUMP JUMPDEST AND SWAP9 DUP5 MLOAD SWAP5 PUSH2 0x183E DUP2 DUP8 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x15 DUP7 MSTORE PUSH21 0x636F6E74726163742025734025732069733A202573 PUSH1 0x58 SHL PUSH1 0x20 DUP8 ADD MSTORE MLOAD SWAP7 DUP8 SWAP6 PUSH4 0x1B55CBD1 PUSH1 0xE2 SHL PUSH1 0x20 DUP9 ADD MSTORE PUSH1 0x80 PUSH1 0x24 DUP9 ADD MSTORE PUSH1 0xA4 DUP8 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP6 DUP2 SUB PUSH1 0x23 NOT ADD PUSH1 0x44 DUP8 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP4 DUP2 SUB PUSH1 0x23 NOT ADD PUSH1 0x64 DUP6 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP7 PUSH1 0x84 DUP4 ADD MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x20 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP SWAP1 JUMP JUMPDEST PUSH2 0x18EE SWAP2 POP RETURNDATASIZE DUP1 DUP11 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH2 0x1608 JUMP JUMPDEST PUSH0 PUSH2 0x1811 JUMP JUMPDEST DUP4 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH2 0x1912 SWAP2 POP RETURNDATASIZE DUP1 DUP5 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x17BA JUMP JUMPDEST PUSH2 0x192C SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x16BE JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH2 0x1941 PUSH1 0x40 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xB DUP3 MSTORE PUSH11 0x159A595DD95C919858D95D PUSH1 0xAA SHL PUSH1 0x20 DUP4 ADD MSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH1 0x5 SHL PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD SWAP1 PUSH2 0x198A DUP3 PUSH2 0x195B JUMP JUMPDEST SWAP3 PUSH2 0x1998 PUSH1 0x40 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST DUP3 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP4 PUSH1 0x5 SHL DUP3 ADD ADD SWAP2 DUP3 GT PUSH2 0x78C JUMPI PUSH1 0x20 ADD SWAP2 JUMPDEST DUP2 DUP4 LT PUSH2 0x19C0 JUMPI POP POP POP SWAP1 JUMP JUMPDEST DUP3 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP2 AND DUP2 SUB PUSH2 0x78C JUMPI DUP2 MSTORE PUSH1 0x20 SWAP3 DUP4 ADD SWAP3 ADD PUSH2 0x19B3 JUMP JUMPDEST DUP1 MLOAD ISZERO PUSH2 0x19EE JUMPI PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x32 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST DUP1 MLOAD PUSH1 0x1 LT ISZERO PUSH2 0x19EE JUMPI PUSH1 0x40 ADD SWAP1 JUMP JUMPDEST DUP1 MLOAD DUP3 LT ISZERO PUSH2 0x19EE JUMPI PUSH1 0x20 SWAP2 PUSH1 0x5 SHL ADD ADD SWAP1 JUMP JUMPDEST PUSH0 PUSH2 0x584 PUSH2 0x1A53 DUP3 SWAP4 PUSH1 0x40 MLOAD SWAP3 DUP4 SWAP2 PUSH4 0x104C13EB PUSH1 0xE2 SHL PUSH1 0x20 DUP5 ADD MSTORE PUSH1 0x20 PUSH1 0x24 DUP5 ADD MSTORE PUSH1 0x44 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST PUSH1 0x20 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x130D191F PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD DUP2 SWAP1 MSTORE DUP2 DUP1 PUSH2 0x1A8F PUSH1 0x24 DUP3 ADD DUP7 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x200A JUMPI JUMPDEST POP ISZERO PUSH2 0x2007 JUMPI SWAP1 PUSH0 PUSH2 0x1ADE SWAP3 PUSH1 0x40 MLOAD DUP1 SWAP5 DUP2 SWAP3 PUSH4 0x60F9BB11 PUSH1 0xE0 SHL DUP4 MSTORE PUSH1 0x20 PUSH1 0x4 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP3 PUSH2 0x1FEB JUMPI JUMPDEST POP PUSH1 0x40 MLOAD PUSH4 0x427C833 PUSH1 0xE3 SHL DUP2 MSTORE PUSH1 0x40 PUSH1 0x4 DUP3 ADD MSTORE PUSH0 DUP2 PUSH1 0x20 PUSH2 0x1B24 PUSH1 0x44 DUP4 ADD DUP8 PUSH2 0x15A1 JUMP JUMPDEST DUP4 DUP4 DUP3 SUB SWAP2 PUSH1 0x3 NOT DUP4 ADD PUSH1 0x24 DUP7 ADD MSTORE MSTORE ADD DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x1F3A JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x40 SHL DUP2 GT PUSH2 0x1010 JUMPI PUSH1 0xD SLOAD DUP2 PUSH1 0xD SSTORE DUP1 DUP3 LT PUSH2 0x1EB8 JUMPI JUMPDEST POP PUSH1 0xD PUSH0 SWAP1 DUP2 MSTORE PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2946 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE PUSH1 0x20 DUP5 ADD JUMPDEST DUP4 DUP4 LT PUSH2 0x1E9B JUMPI POP POP POP POP PUSH0 JUMPDEST DUP2 MLOAD DUP2 LT ISZERO PUSH2 0x1E95 JUMPI DUP1 PUSH2 0x1BAF PUSH2 0x1BFD SWAP3 DUP5 PUSH2 0x1A12 JUMP JUMPDEST MLOAD PUSH1 0x40 MLOAD SWAP1 PUSH2 0x1BBD DUP3 PUSH2 0x1174 JUMP JUMPDEST PUSH0 DUP3 MSTORE PUSH1 0x20 DUP3 ADD PUSH0 DUP2 MSTORE PUSH1 0x40 DUP4 ADD PUSH0 DUP2 MSTORE PUSH1 0x60 DUP5 ADD SWAP2 PUSH0 DUP4 MSTORE PUSH0 PUSH2 0x1BE0 DUP6 PUSH2 0x15C5 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x85940EF1 PUSH1 0xE0 SHL DUP2 MSTORE SWAP9 DUP10 SWAP2 DUP3 SWAP2 SWAP1 DUP15 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL DUP1 ISZERO PUSH2 0xD8E JUMPI PUSH2 0x1CA5 SWAP8 PUSH0 SWAP2 PUSH2 0x1E7B JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 PUSH2 0x1C3E SWAP2 DUP2 ADD PUSH1 0x20 SWAP1 DUP2 ADD SWAP2 ADD PUSH2 0x1663 JUMP JUMPDEST AND DUP6 MSTORE PUSH1 0x40 MLOAD PUSH1 0x17 PUSH1 0xF9 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH0 DUP6 MLOAD SWAP2 PUSH2 0x1C88 PUSH1 0x9 PUSH1 0x21 DUP4 PUSH1 0x20 DUP12 ADD SWAP7 DUP1 DUP9 DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH9 0x5CC6DEC8CA90C2E6D PUSH1 0xBB SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x16 NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x85940EF1 PUSH1 0xE0 SHL DUP2 MSTORE SWAP10 DUP11 SWAP2 DUP3 SWAP2 SWAP1 DUP16 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP8 DUP9 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP9 PUSH2 0x1E5F JUMPI JUMPDEST POP PUSH1 0x20 DUP9 MLOAD SWAP9 DUP2 DUP1 DUP3 ADD SWAP11 DUP12 SWAP3 ADD ADD SUB SLT PUSH2 0x78C JUMPI PUSH2 0x1D25 SWAP8 MLOAD DUP3 MSTORE PUSH0 PUSH1 0x40 MLOAD PUSH1 0x17 PUSH1 0xF9 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x1C88 PUSH1 0xC PUSH1 0x21 DUP4 DUP11 MLOAD DUP1 DUP9 DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH12 0x17313637B1B5A73AB6B132B9 PUSH1 0xA1 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x13 NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP8 DUP9 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP9 PUSH2 0x1E43 JUMPI JUMPDEST POP PUSH1 0x20 DUP9 DUP1 MLOAD DUP2 ADD SUB SLT PUSH2 0x78C JUMPI PUSH1 0x20 PUSH2 0x1DA6 SWAP9 ADD MLOAD DUP4 MSTORE PUSH0 PUSH1 0x40 MLOAD PUSH1 0x17 PUSH1 0xF9 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x1C88 PUSH1 0x11 PUSH1 0x21 DUP4 DUP11 MLOAD DUP1 DUP9 DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH17 0x5CC6E4CAC2E8D2DEDC86DEC8CA90C2E6D PUSH1 0x7B SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0xE NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP8 DUP9 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP9 PUSH2 0x1E27 JUMPI JUMPDEST POP PUSH1 0x20 DUP9 MLOAD SWAP9 DUP2 DUP1 DUP3 ADD SWAP11 DUP12 SWAP3 ADD ADD SUB SLT PUSH2 0x78C JUMPI PUSH1 0x20 PUSH1 0x3 SWAP6 PUSH1 0x1 SWAP10 MLOAD DUP7 MSTORE PUSH1 0x40 MLOAD SWAP3 DUP4 SWAP2 MLOAD DUP1 SWAP2 DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 SWAP5 DUP8 DUP1 PUSH1 0xA0 SHL SUB SWAP1 MLOAD AND DUP8 DUP1 PUSH1 0xA0 SHL SUB NOT DUP7 SLOAD AND OR DUP6 SSTORE MLOAD DUP7 DUP6 ADD SSTORE MLOAD PUSH1 0x2 DUP5 ADD SSTORE MLOAD SWAP2 ADD SSTORE ADD PUSH2 0x1B98 JUMP JUMPDEST PUSH2 0x1E3C SWAP2 SWAP9 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP7 PUSH0 PUSH2 0x1DC6 JUMP JUMPDEST PUSH2 0x1E58 SWAP2 SWAP9 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP7 PUSH0 PUSH2 0x1D45 JUMP JUMPDEST PUSH2 0x1E74 SWAP2 SWAP9 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP7 PUSH0 PUSH2 0x1CC5 JUMP JUMPDEST PUSH2 0x1E8F SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x1C20 JUMP JUMPDEST POP POP SWAP1 POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x20 DUP3 PUSH2 0x1EAC DUP4 SWAP5 MLOAD DUP7 PUSH2 0x12D2 JUMP JUMPDEST ADD SWAP3 ADD SWAP3 ADD SWAP2 SWAP1 PUSH2 0x1B8B JUMP JUMPDEST PUSH1 0xD PUSH0 MSTORE PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2946 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE SWAP1 DUP2 ADD SWAP1 DUP3 ADD JUMPDEST DUP2 DUP2 LT PUSH2 0x1EDE JUMPI POP PUSH2 0x1B71 JUMP JUMPDEST DUP1 PUSH2 0x1EEB PUSH1 0x1 SWAP3 SLOAD PUSH2 0x1272 JUMP JUMPDEST DUP1 PUSH2 0x1EF8 JUMPI JUMPDEST POP ADD PUSH2 0x1ED1 JUMP JUMPDEST PUSH1 0x1F DUP2 GT DUP4 EQ PUSH2 0x1F0D JUMPI POP PUSH0 DUP2 SSTORE JUMPDEST PUSH0 PUSH2 0x1EF1 JUMP JUMPDEST PUSH2 0x1F29 SWAP1 DUP3 PUSH0 MSTORE DUP4 PUSH1 0x1F PUSH1 0x20 PUSH0 KECCAK256 SWAP3 ADD PUSH1 0x5 SHR DUP3 ADD SWAP2 ADD PUSH2 0x12AA JUMP JUMPDEST DUP1 PUSH0 MSTORE PUSH0 PUSH1 0x20 DUP2 KECCAK256 DUP2 DUP4 SSTORE SSTORE PUSH2 0x1F07 JUMP JUMPDEST SWAP1 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1F4B DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH1 0x20 DUP2 DUP4 SUB SLT PUSH2 0x78C JUMPI DUP1 MLOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT PUSH2 0x78C JUMPI ADD SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH2 0x1F81 DUP2 PUSH2 0x195B JUMP JUMPDEST SWAP3 PUSH2 0x1F8F PUSH1 0x40 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST DUP2 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP3 PUSH1 0x5 SHL DUP3 ADD ADD SWAP2 DUP4 DUP4 GT PUSH2 0x78C JUMPI PUSH1 0x20 DUP3 ADD SWAP1 JUMPDEST DUP4 DUP3 LT PUSH2 0x1FBE JUMPI POP POP POP POP POP PUSH0 PUSH2 0x1B54 JUMP JUMPDEST DUP2 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x78C JUMPI PUSH1 0x20 SWAP2 PUSH2 0x1FE0 DUP8 DUP5 DUP1 SWAP5 DUP9 ADD ADD PUSH2 0x1203 JUMP JUMPDEST DUP2 MSTORE ADD SWAP2 ADD SWAP1 PUSH2 0x1FAC JUMP JUMPDEST PUSH2 0x2000 SWAP2 SWAP3 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP1 PUSH0 PUSH2 0x1AFE JUMP JUMPDEST POP JUMP JUMPDEST SWAP1 POP PUSH1 0x20 DUP2 RETURNDATASIZE PUSH1 0x20 GT PUSH2 0x203D JUMPI JUMPDEST DUP2 PUSH2 0x2025 PUSH1 0x20 SWAP4 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI MLOAD DUP1 ISZERO ISZERO DUP2 SUB PUSH2 0x78C JUMPI PUSH0 PUSH2 0x1AB0 JUMP JUMPDEST RETURNDATASIZE SWAP2 POP PUSH2 0x2018 JUMP JUMPDEST PUSH0 NOT DUP2 EQ PUSH2 0xB25 JUMPI PUSH1 0x1 ADD SWAP1 JUMP JUMPDEST PUSH1 0xD SLOAD DUP2 LT ISZERO PUSH2 0x19EE JUMPI PUSH1 0xD PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 ADD SWAP1 PUSH0 SWAP1 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH2 0x207A PUSH1 0x40 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x10 DUP3 MSTORE PUSH16 0xC6E4CAC2E8D2DEDC86DEC8CA90C2E6D PUSH1 0x83 SHL PUSH1 0x20 DUP4 ADD MSTORE JUMP JUMPDEST SWAP1 PUSH0 SWAP1 PUSH1 0x20 SWAP1 PUSH1 0x40 MLOAD SWAP4 PUSH2 0x20AD DUP4 DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP6 MSTORE PUSH1 0x40 MLOAD PUSH2 0x20BD DUP5 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP2 MSTORE SWAP2 PUSH0 SWAP5 PUSH1 0x40 SWAP4 JUMPDEST PUSH1 0xD SLOAD DUP8 LT ISZERO PUSH2 0x2364 JUMPI POP PUSH2 0x20DE PUSH2 0x93B DUP8 PUSH2 0x2053 JUMP JUMPDEST DUP5 MLOAD DUP7 DUP2 DUP4 MLOAD DUP1 DUP4 DUP7 ADD DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 DUP6 MLOAD SWAP1 PUSH2 0x2100 DUP3 PUSH2 0x1174 JUMP JUMPDEST DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP3 MSTORE PUSH1 0x1 DUP2 ADD SLOAD DUP9 DUP4 ADD SWAP1 DUP2 MSTORE PUSH1 0x2 DUP3 ADD SLOAD DUP9 DUP5 ADD SWAP1 DUP2 MSTORE PUSH1 0x3 SWAP1 SWAP3 ADD SLOAD PUSH1 0x60 DUP5 ADD SWAP1 DUP2 MSTORE DUP9 MLOAD PUSH4 0xF877CB19 PUSH1 0xE0 SHL DUP2 MSTORE SWAP1 SWAP4 SWAP1 PUSH0 DUP2 DUP1 PUSH2 0x214E PUSH1 0x4 DUP3 ADD PUSH2 0x1245 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x235A JUMPI SWAP2 PUSH2 0x219D DUP12 PUSH0 SWAP4 DUP15 PUSH2 0x21E6 SWAP7 DUP7 SWAP3 PUSH2 0x2334 JUMPI JUMPDEST POP PUSH5 0x1B1BD8D85B PUSH1 0xDA SHL SWAP1 PUSH2 0x2191 DUP5 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x5 DUP5 MSTORE DUP4 ADD MSTORE PUSH2 0x2431 JUMP JUMPDEST PUSH2 0x2325 JUMPI JUMPDEST MLOAD DUP11 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND SWAP1 PUSH2 0x21BB DUP13 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x4 DUP2 MSTORE PUSH4 0x30B23239 PUSH1 0xE1 SHL DUP14 DUP3 ADD MSTORE DUP12 MLOAD SWAP4 DUP5 SWAP3 DUP4 SWAP3 PUSH4 0x4B963031 PUSH1 0xE1 SHL DUP5 MSTORE DUP11 PUSH1 0x4 DUP6 ADD PUSH2 0x245E JUMP JUMPDEST SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x231B JUMPI SWAP1 PUSH2 0x2232 SWAP3 SWAP2 PUSH2 0x2303 JUMPI JUMPDEST POP MLOAD DUP9 MLOAD PUSH2 0x2218 DUP11 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x8 DUP2 MSTORE PUSH8 0xC6DEC8CA90C2E6D PUSH1 0xC3 SHL DUP12 DUP3 ADD MSTORE DUP6 PUSH2 0x2498 JUMP JUMPDEST POP MLOAD PUSH0 PUSH2 0x2292 DUP9 MLOAD PUSH2 0x2244 DUP11 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xB DUP2 MSTORE PUSH11 0x313637B1B5A73AB6B132B9 PUSH1 0xA9 SHL DUP12 DUP3 ADD MSTORE DUP10 MLOAD PUSH4 0x94F4801 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x60 PUSH1 0x4 DUP3 ADD MSTORE SWAP4 DUP5 SWAP3 DUP4 SWAP3 PUSH2 0x2280 PUSH1 0x64 DUP6 ADD DUP11 PUSH2 0x15A1 JUMP JUMPDEST DUP5 DUP2 SUB PUSH1 0x3 NOT ADD PUSH1 0x24 DUP7 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 PUSH1 0x44 DUP4 ADD MSTORE SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x22F9 JUMPI PUSH2 0x22D9 SWAP3 PUSH1 0x1 SWAP5 SWAP3 PUSH2 0x22D2 SWAP3 PUSH2 0x22E1 JUMPI JUMPDEST POP MLOAD PUSH2 0x22CC PUSH2 0x206B JUMP JUMPDEST DUP4 PUSH2 0x2498 JUMP JUMPDEST SWAP1 DUP11 PUSH2 0x2504 JUMP JUMPDEST SWAP7 ADD SWAP6 PUSH2 0x20C7 JUMP JUMPDEST PUSH2 0x22F4 SWAP1 RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x22C2 JUMP JUMPDEST DUP8 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH2 0x2316 SWAP1 RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x220A JUMP JUMPDEST DUP10 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH1 0x1 DUP6 MSTORE DUP2 DUP5 MSTORE DUP2 DUP7 MSTORE PUSH2 0x21A2 JUMP JUMPDEST PUSH5 0x1B1BD8D85B PUSH1 0xDA SHL SWAP2 SWAP3 POP PUSH2 0x2353 SWAP1 RETURNDATASIZE DUP1 DUP10 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP2 SWAP1 PUSH2 0x217A JUMP JUMPDEST DUP11 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST SWAP2 SWAP6 POP SWAP3 SWAP2 SWAP6 POP PUSH2 0x2383 DUP3 MLOAD PUSH2 0x237A DUP7 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP2 MSTORE DUP3 PUSH2 0x2431 JUMP JUMPDEST PUSH2 0x2429 JUMPI PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH4 0xE23CD19F PUSH1 0xE0 SHL DUP2 MSTORE SWAP6 PUSH0 SWAP2 DUP8 SWAP2 DUP3 SWAP2 PUSH2 0x23BC SWAP2 SWAP1 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP5 DUP6 ISZERO PUSH2 0x241F JUMPI PUSH2 0x2007 SWAP5 SWAP6 PUSH2 0x2408 JUMPI JUMPDEST POP PUSH2 0x23ED SWAP1 MLOAD SWAP3 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 MSTORE PUSH2 0x2401 DUP2 PUSH2 0x23FB PUSH2 0x206B JUMP JUMPDEST DUP2 PUSH2 0x2504 JUMP JUMPDEST SWAP1 DUP1 PUSH2 0x2504 JUMP JUMPDEST PUSH2 0x2415 SWAP2 SWAP3 POP PUSH0 SWAP1 PUSH2 0x118F JUMP JUMPDEST PUSH0 SWAP1 PUSH2 0x23ED PUSH2 0x23E0 JUMP JUMPDEST POP MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST POP POP POP POP SWAP1 POP JUMP JUMPDEST SWAP1 DUP2 MLOAD DUP2 MLOAD SWAP1 DUP2 DUP2 EQ SWAP4 DUP5 PUSH2 0x2448 JUMPI JUMPDEST POP POP POP POP SWAP1 JUMP JUMPDEST PUSH1 0x20 SWAP3 SWAP4 SWAP5 POP DUP3 ADD KECCAK256 SWAP3 ADD KECCAK256 EQ PUSH0 DUP1 DUP1 DUP1 PUSH2 0x2441 JUMP JUMPDEST SWAP2 PUSH2 0x2488 SWAP1 PUSH2 0x247A PUSH1 0x40 SWAP4 SWAP7 SWAP6 SWAP7 PUSH1 0x60 DUP7 MSTORE PUSH1 0x60 DUP7 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 DUP5 DUP3 SUB PUSH1 0x20 DUP7 ADD MSTORE PUSH2 0x15A1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP5 AND SWAP2 ADD MSTORE JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0xB604AD1 PUSH1 0xE2 SHL DUP2 MSTORE PUSH1 0x60 PUSH1 0x4 DUP3 ADD MSTORE SWAP3 PUSH0 SWAP3 DUP5 SWAP3 DUP4 SWAP3 SWAP2 PUSH2 0x24C6 SWAP2 PUSH2 0x2280 SWAP1 PUSH1 0x64 DUP7 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 PUSH1 0x44 DUP4 ADD MSTORE SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x24F0 JUMPI POP SWAP1 JUMP JUMPDEST PUSH2 0x121D SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x2534 SWAP1 PUSH2 0x2558 PUSH0 SWAP4 SWAP5 PUSH2 0x2546 PUSH1 0x40 MLOAD SWAP7 DUP8 SWAP6 DUP7 SWAP6 PUSH4 0x88DA6D35 PUSH1 0xE0 SHL DUP8 MSTORE PUSH1 0x60 PUSH1 0x4 DUP9 ADD MSTORE PUSH1 0x64 DUP8 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP6 DUP2 SUB PUSH1 0x3 NOT ADD PUSH1 0x24 DUP8 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP4 DUP2 SUB PUSH1 0x3 NOT ADD PUSH1 0x44 DUP6 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x24F0 JUMPI POP SWAP1 JUMP JUMPDEST SWAP3 SWAP2 SWAP3 PUSH1 0x40 MLOAD DUP2 MLOAD SWAP1 PUSH1 0x20 DUP2 DUP2 DUP6 ADD SWAP4 DUP1 DUP6 DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 SWAP5 PUSH1 0x40 MLOAD SWAP1 PUSH2 0x25A8 DUP3 PUSH2 0x1174 JUMP JUMPDEST PUSH1 0x1 DUP1 PUSH1 0xA0 SHL SUB DUP8 SLOAD AND DUP3 MSTORE PUSH1 0x20 PUSH2 0x260C PUSH1 0x4 DUP3 PUSH1 0x3 PUSH1 0x1 DUP13 ADD SLOAD SWAP12 DUP3 DUP9 ADD SWAP13 DUP14 MSTORE PUSH1 0x2 DUP2 ADD SLOAD PUSH1 0x40 DUP10 ADD MSTORE ADD SLOAD SWAP9 PUSH1 0x60 DUP8 ADD SWAP10 DUP11 MSTORE PUSH1 0x40 MLOAD SWAP5 DUP2 DUP7 SWAP3 MLOAD SWAP2 DUP3 SWAP2 ADD DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH4 0xB9CDBDB PUSH1 0xE2 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x1B NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x8D1CC925 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE SWAP2 PUSH0 DUP4 DUP1 PUSH2 0x2631 PUSH1 0x24 DUP3 ADD DUP7 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP3 DUP4 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP4 PUSH2 0x28D2 JUMPI JUMPDEST POP PUSH0 PUSH1 0x20 SWAP3 PUSH2 0x2695 PUSH2 0x26B7 SWAP4 DUP6 PUSH1 0x40 MLOAD SWAP7 DUP8 SWAP3 DUP2 DUP1 DUP6 ADD SWAP11 DUP1 MLOAD SWAP2 DUP3 SWAP2 ADD DUP13 MCOPY DUP5 ADD SWAP1 DUP3 DUP3 ADD DUP9 DUP2 MSTORE DUP2 MLOAD SWAP4 DUP5 SWAP3 ADD SWAP1 MCOPY ADD ADD DUP5 DUP2 MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP7 MSTORE DUP6 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP4 DUP2 SWAP3 PUSH4 0xFAFDCED PUSH1 0xE2 SHL DUP4 MSTORE PUSH1 0x20 PUSH1 0x4 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x28B8 JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x20 SWAP1 SWAP2 ADD KECCAK256 DUP2 MLOAD DUP4 KECCAK256 SWAP4 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP1 ISZERO SWAP10 SWAP2 SWAP8 SWAP1 SWAP2 DUP11 ISZERO PUSH2 0x28AC JUMPI JUMPDEST POP DUP10 ISZERO PUSH2 0x28A0 JUMPI JUMPDEST POP DUP9 ISZERO PUSH2 0x2896 JUMPI JUMPDEST DUP9 ISZERO PUSH2 0x285B JUMPI POP MLOAD SWAP1 PUSH0 CREATE SWAP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP6 AND SWAP2 DUP3 ISZERO PUSH2 0x281A JUMPI DUP8 SWAP4 PUSH1 0x3 SWAP3 PUSH1 0x40 SWAP2 PUSH2 0x2764 DUP10 DUP10 DUP6 MLOAD PUSH2 0x2743 DUP8 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xF DUP2 MSTORE PUSH15 0x4465706C6F79202573206174202573 PUSH1 0x88 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x28FD JUMP JUMPDEST DUP3 MLOAD SWAP6 PUSH2 0x2770 DUP8 PUSH2 0x1174 JUMP JUMPDEST DUP7 MSTORE PUSH1 0x20 DUP7 ADD SWAP2 DUP3 MSTORE PUSH1 0x20 DUP4 DUP8 ADD SWAP4 NUMBER DUP6 MSTORE PUSH1 0x60 DUP9 ADD SWAP6 DUP7 MSTORE MLOAD DUP1 SWAP3 DUP11 MLOAD DUP1 SWAP2 DUP4 MCOPY PUSH1 0xE SWAP1 DUP3 ADD SWAP1 DUP2 MSTORE SUB ADD SWAP1 KECCAK256 SWAP5 MLOAD DUP6 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 SWAP1 SWAP2 AND OR DUP6 SSTORE MLOAD PUSH1 0x1 DUP6 ADD SSTORE MLOAD PUSH1 0x2 DUP5 ADD SSTORE MLOAD SWAP2 ADD SSTORE PUSH2 0x27D4 JUMPI POP SWAP2 SWAP1 JUMP JUMPDEST PUSH1 0xD SLOAD PUSH1 0x1 PUSH1 0x40 SHL DUP2 LT ISZERO PUSH2 0x1010 JUMPI DUP1 PUSH1 0x1 PUSH2 0x27F3 SWAP3 ADD PUSH1 0xD SSTORE PUSH2 0x2053 JUMP JUMPDEST SWAP2 SWAP1 SWAP2 PUSH2 0x2807 JUMPI PUSH2 0x2803 SWAP2 PUSH2 0x12D2 JUMP JUMPDEST SWAP2 SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x19 PUSH1 0x24 DUP3 ADD MSTORE PUSH25 0x11985A5B1959081D1BC819195C1B1BDE4818DBDB9D1C9858DD PUSH1 0x3A SHL PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 SWAP1 REVERT JUMPDEST SWAP6 POP POP POP POP POP DUP2 PUSH2 0x2803 SWAP2 PUSH1 0x40 MLOAD PUSH2 0x2874 PUSH1 0x40 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x10 DUP2 MSTORE PUSH16 0x52657573696E67202573206174202573 PUSH1 0x80 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x28FD JUMP JUMPDEST DUP1 EXTCODEHASH ISZERO SWAP9 POP PUSH2 0x270D JUMP JUMPDEST MLOAD DUP5 EQ ISZERO SWAP9 POP PUSH0 PUSH2 0x2705 JUMP JUMPDEST MLOAD DUP9 EQ ISZERO SWAP10 POP PUSH0 PUSH2 0x26FD JUMP JUMPDEST PUSH2 0x28CC SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x26D7 JUMP JUMPDEST PUSH2 0x26B7 SWAP2 SWAP4 POP PUSH1 0x20 SWAP3 PUSH2 0x2695 PUSH2 0x28F2 PUSH0 SWAP4 RETURNDATASIZE DUP1 DUP7 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP6 SWAP4 POP POP SWAP3 POP PUSH2 0x2651 JUMP JUMPDEST SWAP1 PUSH2 0x1A53 PUSH0 SWAP4 SWAP3 PUSH2 0x584 DUP6 SWAP5 PUSH1 0x40 MLOAD SWAP5 DUP6 SWAP4 PUSH4 0x95ED0195 PUSH1 0xE0 SHL PUSH1 0x20 DUP7 ADD MSTORE PUSH1 0x24 DUP6 ADD PUSH2 0x245E JUMP INVALID STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP PUSH18 0x9709ECFA91A80626FF3989D68F67F5B1DD1 0x2D 0xD7 0xB6 SWAP10 ADD SDIV PUSH18 0x9101DABEB77144F2A3385C8033ACD3AF97E9 TIMESTAMP GASPRICE PUSH10 0x5E81AD1EB51B6847DC74 BYTE SHL 0xC 0xD0 DUP14 0x27 DUP9 GASLIMIT 0xF9 0xD8 NOT 0xD8 PUSH28 0x734759AFB55FE2DE5CB82A9AE6728D1108E10BCB7C27DDDFC02ED9D6 SWAP4 LOG0 PUSH21 0x39D026CF4EA4240B40F7D581AC802A26469706673 PC 0x22 SLT KECCAK256 CREATE2 INVALID SWAP16 0xB2 DUP5 0xDA KECCAK256 0x22 NOT 0xAC 0x25 0xC9 NOT 0x22 0xC4 RETURN 0xE 0xE6 0xD1 EXTCODEHASH 0xD9 0xB7 0xCE 0xD7 0xE8 PUSH8 0xF21A10B32D9B6473 PUSH16 0x6C634300081A00330000000000000000 ","sourceMap":"1991:4470:35:-:0;;;;;;;;;;3166:4:2;1991:4470:35;;;3166:4:2;1991:4470:35;;;;;;;;;;;","linkReferences":{}},"deployedBytecode":{"functionDebugData":{"abi_decode_address_payable_fromMemory":{"entryPoint":5731,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_array_bytes4_dyn_fromMemory":{"entryPoint":6514,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_available_length_string_fromMemory":{"entryPoint":4557,"id":null,"parameterSlots":3,"returnSlots":1},"abi_decode_bytes_fromMemory":{"entryPoint":5640,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_string_fromMemory":{"entryPoint":4640,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_string_memory_ptr_fromMemory":{"entryPoint":4611,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_string":{"entryPoint":5537,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_string_string":{"entryPoint":5694,"id":null,"parameterSlots":3,"returnSlots":1},"abi_encode_string_string_address":{"entryPoint":9310,"id":null,"parameterSlots":4,"returnSlots":1},"abi_encode_stringliteral_4c01":{"entryPoint":4677,"id":null,"parameterSlots":1,"returnSlots":1},"array_allocation_size_array_struct_Facet_dyn":{"entryPoint":6491,"id":null,"parameterSlots":1,"returnSlots":1},"array_allocation_size_string":{"entryPoint":4530,"id":null,"parameterSlots":1,"returnSlots":1},"clear_storage_range_bytes1":{"entryPoint":4778,"id":null,"parameterSlots":2,"returnSlots":0},"copy_array_from_storage_to_memory_string":{"entryPoint":5342,"id":null,"parameterSlots":1,"returnSlots":1},"copy_array_from_storage_to_memory_string_19382":{"entryPoint":5048,"id":null,"parameterSlots":0,"returnSlots":1},"copy_array_from_storage_to_memory_string_19384":{"entryPoint":5212,"id":null,"parameterSlots":0,"returnSlots":1},"copy_byte_array_to_storage_from_string_to_string":{"entryPoint":4818,"id":null,"parameterSlots":2,"returnSlots":0},"copy_literal_to_memory_17163bc14ca589f519e924ce03713060635e27e6e081498498ca9bab560316b9":{"entryPoint":6450,"id":null,"parameterSlots":0,"returnSlots":1},"copy_literal_to_memory_47d95dac8bdcb163f6393eaafad841a3d94dcfeecb25399a4857c71942ea6f97":{"entryPoint":8299,"id":null,"parameterSlots":0,"returnSlots":1},"copy_literal_to_memory_aadb29765cb3e4f21bde5ecd65db8e565d901b6c9394dcec22aa81b8ff2d6e2f":{"entryPoint":5500,"id":null,"parameterSlots":0,"returnSlots":1},"extract_byte_array_length":{"entryPoint":4722,"id":null,"parameterSlots":1,"returnSlots":1},"extract_used_part_and_set_length_of_short_byte_array":{"entryPoint":4800,"id":null,"parameterSlots":2,"returnSlots":1},"finalize_allocation":{"entryPoint":4495,"id":null,"parameterSlots":2,"returnSlots":0},"finalize_allocation_19390":{"entryPoint":4441,"id":null,"parameterSlots":1,"returnSlots":0},"finalize_allocation_19408":{"entryPoint":4468,"id":null,"parameterSlots":1,"returnSlots":0},"fun_contractAddress":{"entryPoint":5762,"id":41101,"parameterSlots":2,"returnSlots":1},"fun_equal":{"entryPoint":9265,"id":36823,"parameterSlots":2,"returnSlots":1},"fun_loadDeployment":{"entryPoint":6762,"id":41585,"parameterSlots":1,"returnSlots":0},"fun_log":{"entryPoint":10493,"id":13933,"parameterSlots":3,"returnSlots":0},"fun_log_13136":{"entryPoint":6694,"id":13136,"parameterSlots":1,"returnSlots":0},"fun_saveDeployment":{"entryPoint":8345,"id":41729,"parameterSlots":1,"returnSlots":0},"fun_serialize":{"entryPoint":9368,"id":4253,"parameterSlots":3,"returnSlots":1},"fun_serialize_4331":{"entryPoint":9476,"id":4331,"parameterSlots":3,"returnSlots":1},"fun_tryDeployContract":{"entryPoint":9596,"id":41975,"parameterSlots":3,"returnSlots":2},"increment_uint256":{"entryPoint":8261,"id":null,"parameterSlots":1,"returnSlots":1},"memory_array_index_access_struct_Facet_dyn":{"entryPoint":6674,"id":null,"parameterSlots":2,"returnSlots":1},"memory_array_index_access_struct_Facet_dyn_19392":{"entryPoint":6625,"id":null,"parameterSlots":1,"returnSlots":1},"memory_array_index_access_struct_Facet_dyn_19401":{"entryPoint":6658,"id":null,"parameterSlots":1,"returnSlots":1},"storage_array_index_access_string__dyn":{"entryPoint":8275,"id":null,"parameterSlots":1,"returnSlots":2},"string_concat_stringliteral_6f01_string_stringliteral_4dad":{"entryPoint":5573,"id":null,"parameterSlots":1,"returnSlots":1}},"object":"6080806040526004361015610012575f80fd5b5f905f3560e01c9081630a9254e414610d9957508063c0406226146100675763f8ccbf471461003f575f80fd5b34610064578060031936011261006457602060ff600c5460101c166040519015158152f35b80fd5b503461078c575f36600319011261078c575f805160206129268339815191523b1561078c57604051637fb5297f60e01b81525f81600481835f805160206129268339815191525af18015610d8e57610d7b575b506100cb6100c66113b8565b611a6a565b604061010181516100dc838261118f565b60138152720529ba30b93a103232b83637bcb4b73397171760691b6020820152611a26565b61011a61010c61145c565b61011461157c565b90611682565b61012561010c61145c565b9161013961013161145c565b610114611932565b8151637a0ed62760e01b815290936001600160a01b0316928582600481875afa918215610d71578692610c47575b5085946001600160a01b031691855b8151811015610c3c57836001600160a01b036101928385611a12565b515116146101a257600101610176565b5050909192935060015b15610bac57606093858451936101c2878661118f565b60028552601f198701825b818110610b7e57505060248651809481936356fe50af60e11b835260048301525afa908115610826578691610b39575b5083519061020a82611159565b8682526002602083015284820152610221836119e1565b5261022b826119e1565b50602093610261845161023e878261118f565b878152601f1987013688830137610253611932565b61025b611932565b9061257c565b5084519290610140610273818661118f565b60098552601f19013688860137631bd8adbb60e31b610291856119e1565b5260029363d60ec19d60e01b6102a682611a02565b526009600363013ba9ef60e21b6102be600285611a12565b526102c881612045565b90630c1cc57b60e41b906102dc9085611a12565b526102e681612045565b90635a6b57c560e11b906102fa9085611a12565b5261030481612045565b90630973a52f60e11b906103189085611a12565b5261032281612045565b9063074a9f0d60e11b906103369085611a12565b5261034081612045565b9063328922d160e11b906103549085611a12565b5261035e81612045565b9063683003df60e11b906103729085611a12565b5203610b11579088929187519161038883611159565b6001600160a01b03168252888201849052878201526103a686611a02565b526103b085611a02565b5085519387808601966307e4c70760e21b885260848701866024890152815180915260a48801908360a48260051b8b010193019187905b828210610a62575050505090610417918560448901528588820391602319830160648b015252808852018661118f565b6104388751610426898261118f565b60018152600560f91b8a820152611a26565b61048c8751610447868261118f565b602f81527f2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d204465706c6f796d656e7473202d2d8a8201526e2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d60881b89820152611a26565b600d5490835b888a87858410610919575050505050506104b26104ad6113b8565b612099565b6104e286516104c1888261118f565b601081526f0291195c1b1bde48199a5b9a5cda195960821b89820152611a26565b5f805160206129268339815191523b1561090b578551633b756e9b60e11b81528281600481835f805160206129268339815191525af1801561090f579083916108f6575b505061055d8651610537888261118f565b60158152740505052ab833b930b23290313cba32b1b7b2329d0560591b89820152611a26565b5f8087516305f3bfab60e11b8a82015289602482015261059281610584604482018a6115a1565b03601f19810183528261118f565b89815191016a636f6e736f6c652e6c6f675afa506105db86516105b5888261118f565b60158152740505051e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e8560591b89820152611a26565b8551630ce5723160e11b81526001600160a01b03821695909488866004818a5afa9586156108ec5784966108b9575b505f805160206129268339815191523b156108ab5787516303223eab60e11b815273eaf9135d113b720259d923c044d621e604e1b53360048201528481602481835f805160206129268339815191525af180156108af57908594939291610892575b50839051925af1903d1561088c57503d610685816111b2565b906106928651928361118f565b815286863d92013e5b15610830578251630ce5723160e11b8152908482600481865afa9182156108265786926107f7575b50036107a157908260049261070583516106dd858261118f565b60178152762234b33334b1bab63a3c903737ba1031b430b733b2b21d60491b84820152611a26565b8251630ce5723160e11b815293849182905afa918215610797578492610764575b50905f92839251916327b7cf8560e01b8284015260248301526024825261074e60448361118f565b815191016a636f6e736f6c652e6c6f675afa5080f35b91508282813d8311610790575b61077b818361118f565b8101031261078c579051905f610726565b5f80fd5b503d610771565b81513d86823e3d90fd5b815162461bcd60e51b815260048101849052602960248201527f5570646174654469616d6f6e644d756c74697369673a20646966666963756c746044820152681e4818da185b99d95960ba1b6064820152608490fd5b9091508481813d831161081f575b61080f818361118f565b8101031261078c5751905f6106c3565b503d610805565b84513d88823e3d90fd5b825162461bcd60e51b815260048101859052602f60248201527f5570646174654469616d6f6e644d756c74697369673a206661696c656420746f60448201526e081d5c19185d1948191a585b5bdb99608a1b6064820152608490fd5b5061069b565b8461089f9195929561118f565b6108ab5783925f61066c565b8380fd5b89513d87823e3d90fd5b89809297508195503d83116108e5575b6108d3818361118f565b8101031261078c57889251945f61060a565b503d6108c9565b88513d86823e3d90fd5b816109009161118f565b61090b57815f610526565b5080fd5b87513d85823e3d90fd5b91610a435f93928493610a2f88610a0560019a9b9c9d61094161093b8c612053565b506114de565b90885195600383519789818187019a808c835e8101600e8152030190208b519661096a88611174565b81546001600160a01b0316885260018201548b8901528101548c88015201549085015288519161099a8a8461118f565b6005835287830196641b5b39326d60d81b8852888b51916109bb8d8461118f565b6004835281830193631b5b306d60e01b85528d519a8b97518091858a015e87019083820190878252519283915e010190838252518092825e0190815203601f19810185528461118f565b898060a01b0390511691855195869463319af33360e01b90860152602485015260648401906115a1565b90604483015203601f19810183528261118f565b8c815191016a636f6e736f6c652e6c6f675afa50019089939291610492565b92959697509290935060a3198982030182528451908881019160018060a01b0381511682528d8101516003811015610afc57828f01528c0151818d018a90528051928390528d92608090920191908301908f905b808210610ad8575050509080600192960192019201928b938d979695936103e7565b82516001600160e01b03191684528f94938401939092019160019190910190610ab6565b50634e487b7160e01b8f52602160045260248ffd5b634e487b7160e01b89526001600452602489fd5b634e487b7160e01b5f52601160045260245ffd5b90503d8087833e610b4a818361118f565b8101602082820312610b7a5781516001600160401b038111610b7657610b709201611972565b5f6101fd565b8780fd5b8680fd5b6020919293508751610b8f81611159565b8a81528a83820152898982015282828901015201908892916101cd565b825162461bcd60e51b815260206004820152605e60248201527f5570646174654469616d6f6e6456696577734d756c74697369673a207669657760448201527f6572206661636574206e6f74206d6174636865642c2070726f6261626c79207960648201527f6f75206861766520756e77616e746564206c6f63616c206368616e6765730000608482015260a490fd5b5050909192936101ac565b9091503d8087833e610c59818361118f565b810190602081830312610b7a578051906001600160401b038211610b76570181601f82011215610b7a57805190610c8f8261195b565b92610c9c8651948561118f565b82845260208085019360051b83010191818311610d6d5760208101935b838510610ccc575050505050905f610167565b84516001600160401b038111610d695782019088601f198386030112610d6957885190818a016001600160401b03811183821017610d55578a5260208301516001600160a01b0381168103610d51578252828a0151916001600160401b038311610d5157610d4286602080969581960101611972565b83820152815201940193610cb9565b8d80fd5b634e487b7160e01b8e52604160045260248efd5b8b80fd5b8980fd5b83513d88823e3d90fd5b610d8791505f9061118f565b5f806100ba565b6040513d5f823e3d90fd5b3461078c575f36600319011261078c5763f877cb1960e01b81525f8180610dc260048201611245565b03815f805160206129268339815191525afa908115610d8e575f9161113f575b5080516001600160401b03811161101057610dfe601054611272565b601f8111611104575b50602091601f82116001146110a457610e29925f9183610f62575b50506112c0565b6010555b60405160208101815f601054610e4281611272565b906001811690811561108a5750600114611048575b50610e79918164173539b7b760d91b6005935203601a1981018552018361118f565b604051636c98507360e11b8152905f826004815f805160206129268339815191525afa908115610d8e57602093610f18935f93611024575b5084604051610ec160408261118f565b600d8152818101906c2f6465706c6f796d656e74732f60981b82526040519786899751918291018589015e860190838201905f8252519283915e0101905f8252518092825e015f815203601f19810183528261118f565b80516001600160401b03811161101057610f33600f54611272565b601f8111610fca575b50602091601f8211600114610f6d57610f5d925f9183610f625750506112c0565b600f55005b015190508380610e22565b601f19821692600f5f52805f20915f5b858110610fb257508360019510610f9a575b505050811b01600f55005b01515f1960f88460031b161c19169055828080610f8f565b91926020600181928685015181550194019201610f7d565b600f5f52611000905f80516020612986833981519152601f840160051c81019160208510611006575b601f0160051c01906112aa565b82610f3c565b9091508190610ff3565b634e487b7160e01b5f52604160045260245ffd5b6110419193503d805f833e611039818361118f565b810190611220565b9185610eb1565b91505060105f528260205f205f905b8382106110705750909182016020019050610e79610e57565b602091925080600191548385890101520191018491611057565b60ff19168552508015150282016020019050610e79610e57565b601f1982169260105f52805f20915f5b8581106110ec575083600195106110d4575b505050811b01601055610e2d565b01515f1960f88460031b161c191690558280806110c6565b919260206001819286850151815501940192016110b4565b60105f52611139905f80516020612966833981519152601f840160051c8101916020851061100657601f0160051c01906112aa565b82610e07565b61115391503d805f833e611039818361118f565b81610de2565b606081019081106001600160401b0382111761101057604052565b608081019081106001600160401b0382111761101057604052565b601f909101601f19168101906001600160401b0382119082101761101057604052565b6001600160401b03811161101057601f01601f191660200190565b9291926111d9826111b2565b916111e7604051938461118f565b82948184528183011161078c578281602093845f96015e010152565b9080601f8301121561078c57815161121d926020016111cd565b90565b9060208282031261078c5781516001600160401b03811161078c5761121d9201611203565b606090602081526012602082015271434f4e5452414354535f454e565f4e414d4560701b60408201520190565b90600182811c921680156112a0575b602083101461128c57565b634e487b7160e01b5f52602260045260245ffd5b91607f1691611281565b8181106112b5575050565b5f81556001016112aa565b8160011b915f199060031b1c19161790565b81519192916001600160401b038111611010576112ef8254611272565b601f8111611388575b506020601f821160011461132a57819061131b9394955f9261131f5750506112c0565b9055565b015190505f80610e22565b601f19821690835f52805f20915f5b81811061137057509583600195969710611358575b505050811b019055565b01515f1960f88460031b161c191690555f808061134e565b9192602060018192868b015181550194019201611339565b6113b290835f5260205f20601f840160051c8101916020851061100657601f0160051c01906112aa565b5f6112f8565b604051905f82600f54916113cb83611272565b808352926001811690811561143d57506001146113f1575b6113ef9250038361118f565b565b50600f5f90815290915f805160206129868339815191525b8183106114215750509060206113ef928201016113e3565b6020919350806001915483858901015201910190918492611409565b602092506113ef94915060ff191682840152151560051b8201016113e3565b604051905f826010549161146f83611272565b808352926001811690811561143d5750600114611492576113ef9250038361118f565b5060105f90815290915f805160206129668339815191525b8183106114c25750509060206113ef928201016113e3565b60209193508060019154838589010152019101909184926114aa565b9060405191825f8254926114f184611272565b808452936001811690811561155a5750600114611516575b506113ef9250038361118f565b90505f9291925260205f20905f915b81831061153e5750509060206113ef928201015f611509565b6020919350806001915483858901015201910190918492611525565b9050602092506113ef94915060ff191682840152151560051b8201015f611509565b6040519061158b60408361118f565b6007825266111a585b5bdb9960ca1b6020830152565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b906113ef60056021602094604051958691601760f91b828401528051918291018484015e8101641730b2323960d91b838201520301601a1981018552018361118f565b60208183031261078c578051906001600160401b03821161078c57019080601f8301121561078c57815161121d926020016111cd565b909161165561121d936040845260408401906115a1565b9160208184039101526115a1565b9081602091031261078c57516001600160a01b038116810361078c5790565b604051636c98507360e11b8152905f826004815f805160206129268339815191525afa918215610d8e576005600d602094611712935f91611918575b50856040519682889351918291018385015e82016c2f6465706c6f796d656e74732f60981b8282015286519081838901602d83015e010164173539b7b760d91b838201520301601a1981018552018361118f565b6117945f60409381808261175e885161172b8a8261118f565b6008815267706174683a20257360c01b60208201526105848a51938492634b5c427760e01b60208501526024840161163e565b6020815191016a636f6e736f6c652e6c6f675afa508451809381926360f9bb1160e01b83526020600484015260248301906115a1565b03815f805160206129268339815191525afa9081156118f4576117df915f9182916118fe575b506117c4866115c5565b85516385940ef160e01b81529384928392906004840161163e565b03815f805160206129268339815191525afa9081156118f4575f936118a68594611894611882956118ba9588916118d2575b5080516001600160a01b039161182f91810160209081019101611663565b169884519461183e818761118f565b6015865274636f6e74726163742025734025732069733a20257360581b602087015251968795631b55cbd160e21b60208801526080602488015260a48701906115a1565b858103602319016044870152906115a1565b838103602319016064850152906115a1565b86608483015203601f19810183528261118f565b6020815191016a636f6e736f6c652e6c6f675afa5090565b6118ee91503d808a833e6118e6818361118f565b810190611608565b5f611811565b83513d5f823e3d90fd5b61191291503d8084833e611039818361118f565b5f6117ba565b61192c91503d805f833e611039818361118f565b5f6116be565b6040519061194160408361118f565b600b82526a159a595dd95c919858d95d60aa1b6020830152565b6001600160401b0381116110105760051b60200190565b9080601f8301121561078c5781519061198a8261195b565b92611998604051948561118f565b82845260208085019360051b82010191821161078c57602001915b8183106119c05750505090565b82516001600160e01b03198116810361078c578152602092830192016119b3565b8051156119ee5760200190565b634e487b7160e01b5f52603260045260245ffd5b8051600110156119ee5760400190565b80518210156119ee5760209160051b010190565b5f610584611a53829360405192839163104c13eb60e21b60208401526020602484015260448301906115a1565b6020815191016a636f6e736f6c652e6c6f675afa50565b60405163130d191f60e11b81526020600482018190528180611a8f60248201866115a1565b03815f5f805160206129268339815191525af1908115610d8e575f9161200a575b501561200757905f611ade92604051809481926360f9bb1160e01b83526020600484015260248301906115a1565b03815f805160206129268339815191525afa918215610d8e575f92611feb575b50604051630427c83360e31b8152604060048201525f816020611b2460448301876115a1565b8383820391600319830160248601525201815f805160206129268339815191525afa908115610d8e575f91611f3a575b508051600160401b811161101057600d5481600d55808210611eb8575b50600d5f9081525f80516020612946833981519152602084015b838310611e9b57505050505f5b8151811015611e955780611baf611bfd9284611a12565b5160405190611bbd82611174565b5f8252602082015f8152604083015f815260608401915f83525f611be0856115c5565b6040516385940ef160e01b81529889918291908e6004840161163e565b03815f805160206129268339815191525afa8015610d8e57611ca5975f91611e7b575b5080516001600160a01b0391611c3e91810160209081019101611663565b168552604051601760f91b60208201525f855191611c88600960218360208b019680888484015e81016805cc6dec8ca90c2e6d60bb1b83820152030160161981018452018261118f565b6040516385940ef160e01b8152998a918291908f6004840161163e565b03815f805160206129268339815191525afa978815610d8e575f98611e5f575b506020885198818082019a8b920101031261078c57611d25975182525f604051601760f91b6020820152611c88600c6021838a5180888484015e81016b17313637b1b5a73ab6b132b960a11b83820152030160131981018452018261118f565b03815f805160206129268339815191525afa978815610d8e575f98611e43575b5060208880518101031261078c576020611da698015183525f604051601760f91b6020820152611c8860116021838a5180888484015e81017005cc6e4cac2e8d2dedc86dec8ca90c2e6d607b1b838201520301600e1981018452018261118f565b03815f805160206129268339815191525afa978815610d8e575f98611e27575b506020885198818082019a8b920101031261078c576020600395600199518652604051928391518091835e8101600e81520301902094878060a01b03905116878060a01b031986541617855551868501555160028401555191015501611b98565b611e3c9198503d805f833e6118e6818361118f565b965f611dc6565b611e589198503d805f833e6118e6818361118f565b965f611d45565b611e749198503d805f833e6118e6818361118f565b965f611cc5565b611e8f91503d805f833e6118e6818361118f565b5f611c20565b50509050565b6001602082611eac839451866112d2565b01920192019190611b8b565b600d5f525f805160206129468339815191529081019082015b818110611ede5750611b71565b80611eeb60019254611272565b80611ef8575b5001611ed1565b601f81118314611f0d57505f81555b5f611ef1565b611f2990825f5283601f60205f20920160051c820191016112aa565b805f525f6020812081835555611f07565b90503d805f833e611f4b818361118f565b81019060208183031261078c578051906001600160401b03821161078c57019080601f8301121561078c578151611f818161195b565b92611f8f604051948561118f565b81845260208085019260051b8201019183831161078c5760208201905b838210611fbe5750505050505f611b54565b81516001600160401b03811161078c57602091611fe087848094880101611203565b815201910190611fac565b6120009192503d805f833e611039818361118f565b905f611afe565b50565b90506020813d60201161203d575b816120256020938361118f565b8101031261078c5751801515810361078c575f611ab0565b3d9150612018565b5f198114610b255760010190565b600d548110156119ee57600d5f5260205f2001905f90565b6040519061207a60408361118f565b601082526f0c6e4cac2e8d2dedc86dec8ca90c2e6d60831b6020830152565b905f90602090604051936120ad838661118f565b5f85526040516120bd848261118f565b5f8152915f946040935b600d5487101561236457506120de61093b87612053565b84518681835180838601835e8101600e81520301902085519061210082611174565b80546001600160a01b031682526001810154888301908152600282015488840190815260039092015460608401908152885163f877cb1960e01b81529093905f818061214e60048201611245565b03815f805160206129268339815191525afa90811561235a579161219d8b5f938e6121e6968692612334575b50641b1bd8d85b60da1b906121918451948561118f565b60058452830152612431565b612325575b518a516001600160a01b03909116906121bb8c8261118f565b600481526330b2323960e11b8d8201528b519384928392634b96303160e11b84528a6004850161245e565b0381835f805160206129268339815191525af1801561231b57906122329291612303575b505188516122188a8261118f565b60088152670c6dec8ca90c2e6d60c31b8b82015285612498565b50515f61229288516122448a8261118f565b600b81526a313637b1b5a73ab6b132b960a91b8b820152895163094f480160e11b8152606060048201529384928392612280606485018a6115a1565b848103600319016024860152906115a1565b9060448301520381835f805160206129268339815191525af180156122f9576122d992600194926122d2926122e1575b50516122cc61206b565b83612498565b908a612504565b9601956120c7565b6122f4903d805f833e611039818361118f565b6122c2565b87513d5f823e3d90fd5b612316903d805f833e611039818361118f565b61220a565b89513d5f823e3d90fd5b600185528184528186526121a2565b641b1bd8d85b60da1b919250612353903d8089833e611039818361118f565b919061217a565b8a513d5f823e3d90fd5b91955092919550612383825161237a868261118f565b5f815282612431565b612429575f805160206129268339815191523b1561078c57815163e23cd19f60e01b8152955f91879182916123bc91906004840161163e565b0381835f805160206129268339815191525af194851561241f576120079495612408575b506123ed9051928361118f565b8152612401816123fb61206b565b81612504565b9080612504565b6124159192505f9061118f565b5f906123ed6123e0565b50513d5f823e3d90fd5b505050509050565b9081518151908181149384612448575b5050505090565b602092939450820120920120145f808080612441565b916124889061247a6040939695966060865260608601906115a1565b9084820360208601526115a1565b6001600160a01b03909416910152565b604051630b604ad160e21b815260606004820152925f9284928392916124c6916122809060648601906115a1565b9060448301520381835f805160206129268339815191525af1908115610d8e575f916124f0575090565b61121d91503d805f833e611039818361118f565b612534906125585f939461254660405196879586956388da6d3560e01b87526060600488015260648701906115a1565b858103600319016024870152906115a1565b838103600319016044850152906115a1565b0381835f805160206129268339815191525af1908115610d8e575f916124f0575090565b929192604051815190602081818501938085835e8101600e81520301902094604051906125a882611174565b60018060a01b038754168252602061260c600482600360018c01549b8288019c8d526002810154604089015201549860608701998a526040519481869251918291018484015e8101630b9cdbdb60e21b838201520301601b1981018452018261118f565b604051638d1cc92560e01b815260206004820152915f838061263160248201866115a1565b03815f805160206129268339815191525afa928315610d8e575f936128d2575b505f6020926126956126b79385604051968792818085019a8051918291018c5e840190828201888152815193849201905e010184815203601f19810186528561118f565b60405180938192630fafdced60e21b83526020600484015260248301906115a1565b03815f805160206129268339815191525afa908115610d8e575f916128b8575b5080516020909101208151832093516001600160a01b0316801599919790918a156128ac575b5089156128a0575b508815612896575b881561285b575051905ff0936001600160a01b03851691821561281a57879360039260409161276489898551612743878261118f565b600f81526e4465706c6f7920257320617420257360881b60208201526128fd565b82519561277087611174565b865260208601918252602083870193438552606088019586525180928a518091835e600e90820190815203019020945185546001600160a01b0319166001600160a01b0391909116178555516001850155516002840155519101556127d457509190565b600d54600160401b811015611010578060016127f39201600d55612053565b91909161280757612803916112d2565b9190565b634e487b7160e01b5f525f60045260245ffd5b60405162461bcd60e51b815260206004820152601960248201527811985a5b1959081d1bc819195c1b1bde4818dbdb9d1c9858dd603a1b6044820152606490fd5b955050505050816128039160405161287460408261118f565b601081526f52657573696e6720257320617420257360801b60208201526128fd565b803f15985061270d565b5184141598505f612705565b5188141599505f6126fd565b6128cc91503d805f833e6118e6818361118f565b5f6126d7565b6126b79193506020926126956128f25f933d8086833e6118e6818361118f565b959350509250612651565b90611a535f939261058485946040519485936395ed019560e01b60208601526024850161245e56fe0000000000000000000000007109709ecfa91a80626ff3989d68f67f5b1dd12dd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb51b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae6728d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802a2646970667358221220f5fe9fb284da202219ac25c91922c4f30ee6d13fd9b7ced7e867f21a10b32d9b64736f6c634300081a0033","opcodes":"PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT ISZERO PUSH2 0x12 JUMPI PUSH0 DUP1 REVERT JUMPDEST PUSH0 SWAP1 PUSH0 CALLDATALOAD PUSH1 0xE0 SHR SWAP1 DUP2 PUSH4 0xA9254E4 EQ PUSH2 0xD99 JUMPI POP DUP1 PUSH4 0xC0406226 EQ PUSH2 0x67 JUMPI PUSH4 0xF8CCBF47 EQ PUSH2 0x3F JUMPI PUSH0 DUP1 REVERT JUMPDEST CALLVALUE PUSH2 0x64 JUMPI DUP1 PUSH1 0x3 NOT CALLDATASIZE ADD SLT PUSH2 0x64 JUMPI PUSH1 0x20 PUSH1 0xFF PUSH1 0xC SLOAD PUSH1 0x10 SHR AND PUSH1 0x40 MLOAD SWAP1 ISZERO ISZERO DUP2 MSTORE RETURN JUMPDEST DUP1 REVERT JUMPDEST POP CALLVALUE PUSH2 0x78C JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x78C JUMPI PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x78C JUMPI PUSH1 0x40 MLOAD PUSH4 0x7FB5297F PUSH1 0xE0 SHL DUP2 MSTORE PUSH0 DUP2 PUSH1 0x4 DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0xD8E JUMPI PUSH2 0xD7B JUMPI JUMPDEST POP PUSH2 0xCB PUSH2 0xC6 PUSH2 0x13B8 JUMP JUMPDEST PUSH2 0x1A6A JUMP JUMPDEST PUSH1 0x40 PUSH2 0x101 DUP2 MLOAD PUSH2 0xDC DUP4 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x13 DUP2 MSTORE PUSH19 0x529BA30B93A103232B83637BCB4B733971717 PUSH1 0x69 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH2 0x11A PUSH2 0x10C PUSH2 0x145C JUMP JUMPDEST PUSH2 0x114 PUSH2 0x157C JUMP JUMPDEST SWAP1 PUSH2 0x1682 JUMP JUMPDEST PUSH2 0x125 PUSH2 0x10C PUSH2 0x145C JUMP JUMPDEST SWAP2 PUSH2 0x139 PUSH2 0x131 PUSH2 0x145C JUMP JUMPDEST PUSH2 0x114 PUSH2 0x1932 JUMP JUMPDEST DUP2 MLOAD PUSH4 0x7A0ED627 PUSH1 0xE0 SHL DUP2 MSTORE SWAP1 SWAP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP3 DUP6 DUP3 PUSH1 0x4 DUP2 DUP8 GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0xD71 JUMPI DUP7 SWAP3 PUSH2 0xC47 JUMPI JUMPDEST POP DUP6 SWAP5 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP2 DUP6 JUMPDEST DUP2 MLOAD DUP2 LT ISZERO PUSH2 0xC3C JUMPI DUP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB PUSH2 0x192 DUP4 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MLOAD MLOAD AND EQ PUSH2 0x1A2 JUMPI PUSH1 0x1 ADD PUSH2 0x176 JUMP JUMPDEST POP POP SWAP1 SWAP2 SWAP3 SWAP4 POP PUSH1 0x1 JUMPDEST ISZERO PUSH2 0xBAC JUMPI PUSH1 0x60 SWAP4 DUP6 DUP5 MLOAD SWAP4 PUSH2 0x1C2 DUP8 DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x2 DUP6 MSTORE PUSH1 0x1F NOT DUP8 ADD DUP3 JUMPDEST DUP2 DUP2 LT PUSH2 0xB7E JUMPI POP POP PUSH1 0x24 DUP7 MLOAD DUP1 SWAP5 DUP2 SWAP4 PUSH4 0x56FE50AF PUSH1 0xE1 SHL DUP4 MSTORE PUSH1 0x4 DUP4 ADD MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x826 JUMPI DUP7 SWAP2 PUSH2 0xB39 JUMPI JUMPDEST POP DUP4 MLOAD SWAP1 PUSH2 0x20A DUP3 PUSH2 0x1159 JUMP JUMPDEST DUP7 DUP3 MSTORE PUSH1 0x2 PUSH1 0x20 DUP4 ADD MSTORE DUP5 DUP3 ADD MSTORE PUSH2 0x221 DUP4 PUSH2 0x19E1 JUMP JUMPDEST MSTORE PUSH2 0x22B DUP3 PUSH2 0x19E1 JUMP JUMPDEST POP PUSH1 0x20 SWAP4 PUSH2 0x261 DUP5 MLOAD PUSH2 0x23E DUP8 DUP3 PUSH2 0x118F JUMP JUMPDEST DUP8 DUP2 MSTORE PUSH1 0x1F NOT DUP8 ADD CALLDATASIZE DUP9 DUP4 ADD CALLDATACOPY PUSH2 0x253 PUSH2 0x1932 JUMP JUMPDEST PUSH2 0x25B PUSH2 0x1932 JUMP JUMPDEST SWAP1 PUSH2 0x257C JUMP JUMPDEST POP DUP5 MLOAD SWAP3 SWAP1 PUSH2 0x140 PUSH2 0x273 DUP2 DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x9 DUP6 MSTORE PUSH1 0x1F NOT ADD CALLDATASIZE DUP9 DUP7 ADD CALLDATACOPY PUSH4 0x1BD8ADBB PUSH1 0xE3 SHL PUSH2 0x291 DUP6 PUSH2 0x19E1 JUMP JUMPDEST MSTORE PUSH1 0x2 SWAP4 PUSH4 0xD60EC19D PUSH1 0xE0 SHL PUSH2 0x2A6 DUP3 PUSH2 0x1A02 JUMP JUMPDEST MSTORE PUSH1 0x9 PUSH1 0x3 PUSH4 0x13BA9EF PUSH1 0xE2 SHL PUSH2 0x2BE PUSH1 0x2 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x2C8 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0xC1CC57B PUSH1 0xE4 SHL SWAP1 PUSH2 0x2DC SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x2E6 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x5A6B57C5 PUSH1 0xE1 SHL SWAP1 PUSH2 0x2FA SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x304 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x973A52F PUSH1 0xE1 SHL SWAP1 PUSH2 0x318 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x322 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x74A9F0D PUSH1 0xE1 SHL SWAP1 PUSH2 0x336 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x340 DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x328922D1 PUSH1 0xE1 SHL SWAP1 PUSH2 0x354 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE PUSH2 0x35E DUP2 PUSH2 0x2045 JUMP JUMPDEST SWAP1 PUSH4 0x683003DF PUSH1 0xE1 SHL SWAP1 PUSH2 0x372 SWAP1 DUP6 PUSH2 0x1A12 JUMP JUMPDEST MSTORE SUB PUSH2 0xB11 JUMPI SWAP1 DUP9 SWAP3 SWAP2 DUP8 MLOAD SWAP2 PUSH2 0x388 DUP4 PUSH2 0x1159 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP3 MSTORE DUP9 DUP3 ADD DUP5 SWAP1 MSTORE DUP8 DUP3 ADD MSTORE PUSH2 0x3A6 DUP7 PUSH2 0x1A02 JUMP JUMPDEST MSTORE PUSH2 0x3B0 DUP6 PUSH2 0x1A02 JUMP JUMPDEST POP DUP6 MLOAD SWAP4 DUP8 DUP1 DUP7 ADD SWAP7 PUSH4 0x7E4C707 PUSH1 0xE2 SHL DUP9 MSTORE PUSH1 0x84 DUP8 ADD DUP7 PUSH1 0x24 DUP10 ADD MSTORE DUP2 MLOAD DUP1 SWAP2 MSTORE PUSH1 0xA4 DUP9 ADD SWAP1 DUP4 PUSH1 0xA4 DUP3 PUSH1 0x5 SHL DUP12 ADD ADD SWAP4 ADD SWAP2 DUP8 SWAP1 JUMPDEST DUP3 DUP3 LT PUSH2 0xA62 JUMPI POP POP POP POP SWAP1 PUSH2 0x417 SWAP2 DUP6 PUSH1 0x44 DUP10 ADD MSTORE DUP6 DUP9 DUP3 SUB SWAP2 PUSH1 0x23 NOT DUP4 ADD PUSH1 0x64 DUP12 ADD MSTORE MSTORE DUP1 DUP9 MSTORE ADD DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x438 DUP8 MLOAD PUSH2 0x426 DUP10 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x1 DUP2 MSTORE PUSH1 0x5 PUSH1 0xF9 SHL DUP11 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH2 0x48C DUP8 MLOAD PUSH2 0x447 DUP7 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x2F DUP2 MSTORE PUSH32 0x2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D204465706C6F796D656E7473202D2D DUP11 DUP3 ADD MSTORE PUSH15 0x2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D PUSH1 0x88 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH1 0xD SLOAD SWAP1 DUP4 JUMPDEST DUP9 DUP11 DUP8 DUP6 DUP5 LT PUSH2 0x919 JUMPI POP POP POP POP POP POP PUSH2 0x4B2 PUSH2 0x4AD PUSH2 0x13B8 JUMP JUMPDEST PUSH2 0x2099 JUMP JUMPDEST PUSH2 0x4E2 DUP7 MLOAD PUSH2 0x4C1 DUP9 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x10 DUP2 MSTORE PUSH16 0x291195C1B1BDE48199A5B9A5CDA1959 PUSH1 0x82 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x90B JUMPI DUP6 MLOAD PUSH4 0x3B756E9B PUSH1 0xE1 SHL DUP2 MSTORE DUP3 DUP2 PUSH1 0x4 DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x90F JUMPI SWAP1 DUP4 SWAP2 PUSH2 0x8F6 JUMPI JUMPDEST POP POP PUSH2 0x55D DUP7 MLOAD PUSH2 0x537 DUP9 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x15 DUP2 MSTORE PUSH21 0x505052AB833B930B23290313CBA32B1B7B2329D05 PUSH1 0x59 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST PUSH0 DUP1 DUP8 MLOAD PUSH4 0x5F3BFAB PUSH1 0xE1 SHL DUP11 DUP3 ADD MSTORE DUP10 PUSH1 0x24 DUP3 ADD MSTORE PUSH2 0x592 DUP2 PUSH2 0x584 PUSH1 0x44 DUP3 ADD DUP11 PUSH2 0x15A1 JUMP JUMPDEST SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST DUP10 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP PUSH2 0x5DB DUP7 MLOAD PUSH2 0x5B5 DUP9 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x15 DUP2 MSTORE PUSH21 0x505051E9E9E9E9E9E9E9E9E9E9E9E9E9E9E9E9E85 PUSH1 0x59 SHL DUP10 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST DUP6 MLOAD PUSH4 0xCE57231 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND SWAP6 SWAP1 SWAP5 DUP9 DUP7 PUSH1 0x4 DUP2 DUP11 GAS STATICCALL SWAP6 DUP7 ISZERO PUSH2 0x8EC JUMPI DUP5 SWAP7 PUSH2 0x8B9 JUMPI JUMPDEST POP PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x8AB JUMPI DUP8 MLOAD PUSH4 0x3223EAB PUSH1 0xE1 SHL DUP2 MSTORE PUSH20 0xEAF9135D113B720259D923C044D621E604E1B533 PUSH1 0x4 DUP3 ADD MSTORE DUP5 DUP2 PUSH1 0x24 DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x8AF JUMPI SWAP1 DUP6 SWAP5 SWAP4 SWAP3 SWAP2 PUSH2 0x892 JUMPI JUMPDEST POP DUP4 SWAP1 MLOAD SWAP3 GAS CALL SWAP1 RETURNDATASIZE ISZERO PUSH2 0x88C JUMPI POP RETURNDATASIZE PUSH2 0x685 DUP2 PUSH2 0x11B2 JUMP JUMPDEST SWAP1 PUSH2 0x692 DUP7 MLOAD SWAP3 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 MSTORE DUP7 DUP7 RETURNDATASIZE SWAP3 ADD RETURNDATACOPY JUMPDEST ISZERO PUSH2 0x830 JUMPI DUP3 MLOAD PUSH4 0xCE57231 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 DUP5 DUP3 PUSH1 0x4 DUP2 DUP7 GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0x826 JUMPI DUP7 SWAP3 PUSH2 0x7F7 JUMPI JUMPDEST POP SUB PUSH2 0x7A1 JUMPI SWAP1 DUP3 PUSH1 0x4 SWAP3 PUSH2 0x705 DUP4 MLOAD PUSH2 0x6DD DUP6 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x17 DUP2 MSTORE PUSH23 0x2234B33334B1BAB63A3C903737BA1031B430B733B2B21D PUSH1 0x49 SHL DUP5 DUP3 ADD MSTORE PUSH2 0x1A26 JUMP JUMPDEST DUP3 MLOAD PUSH4 0xCE57231 PUSH1 0xE1 SHL DUP2 MSTORE SWAP4 DUP5 SWAP2 DUP3 SWAP1 GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0x797 JUMPI DUP5 SWAP3 PUSH2 0x764 JUMPI JUMPDEST POP SWAP1 PUSH0 SWAP3 DUP4 SWAP3 MLOAD SWAP2 PUSH4 0x27B7CF85 PUSH1 0xE0 SHL DUP3 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD MSTORE PUSH1 0x24 DUP3 MSTORE PUSH2 0x74E PUSH1 0x44 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP DUP1 RETURN JUMPDEST SWAP2 POP DUP3 DUP3 DUP2 RETURNDATASIZE DUP4 GT PUSH2 0x790 JUMPI JUMPDEST PUSH2 0x77B DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI SWAP1 MLOAD SWAP1 PUSH0 PUSH2 0x726 JUMP JUMPDEST PUSH0 DUP1 REVERT JUMPDEST POP RETURNDATASIZE PUSH2 0x771 JUMP JUMPDEST DUP2 MLOAD RETURNDATASIZE DUP7 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP2 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP5 SWAP1 MSTORE PUSH1 0x29 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x5570646174654469616D6F6E644D756C74697369673A20646966666963756C74 PUSH1 0x44 DUP3 ADD MSTORE PUSH9 0x1E4818DA185B99D959 PUSH1 0xBA SHL PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 SWAP1 REVERT JUMPDEST SWAP1 SWAP2 POP DUP5 DUP2 DUP2 RETURNDATASIZE DUP4 GT PUSH2 0x81F JUMPI JUMPDEST PUSH2 0x80F DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI MLOAD SWAP1 PUSH0 PUSH2 0x6C3 JUMP JUMPDEST POP RETURNDATASIZE PUSH2 0x805 JUMP JUMPDEST DUP5 MLOAD RETURNDATASIZE DUP9 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP3 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP6 SWAP1 MSTORE PUSH1 0x2F PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x5570646174654469616D6F6E644D756C74697369673A206661696C656420746F PUSH1 0x44 DUP3 ADD MSTORE PUSH15 0x81D5C19185D1948191A585B5BDB99 PUSH1 0x8A SHL PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 SWAP1 REVERT JUMPDEST POP PUSH2 0x69B JUMP JUMPDEST DUP5 PUSH2 0x89F SWAP2 SWAP6 SWAP3 SWAP6 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x8AB JUMPI DUP4 SWAP3 PUSH0 PUSH2 0x66C JUMP JUMPDEST DUP4 DUP1 REVERT JUMPDEST DUP10 MLOAD RETURNDATASIZE DUP8 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP10 DUP1 SWAP3 SWAP8 POP DUP2 SWAP6 POP RETURNDATASIZE DUP4 GT PUSH2 0x8E5 JUMPI JUMPDEST PUSH2 0x8D3 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI DUP9 SWAP3 MLOAD SWAP5 PUSH0 PUSH2 0x60A JUMP JUMPDEST POP RETURNDATASIZE PUSH2 0x8C9 JUMP JUMPDEST DUP9 MLOAD RETURNDATASIZE DUP7 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST DUP2 PUSH2 0x900 SWAP2 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x90B JUMPI DUP2 PUSH0 PUSH2 0x526 JUMP JUMPDEST POP DUP1 REVERT JUMPDEST DUP8 MLOAD RETURNDATASIZE DUP6 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST SWAP2 PUSH2 0xA43 PUSH0 SWAP4 SWAP3 DUP5 SWAP4 PUSH2 0xA2F DUP9 PUSH2 0xA05 PUSH1 0x1 SWAP11 SWAP12 SWAP13 SWAP14 PUSH2 0x941 PUSH2 0x93B DUP13 PUSH2 0x2053 JUMP JUMPDEST POP PUSH2 0x14DE JUMP JUMPDEST SWAP1 DUP9 MLOAD SWAP6 PUSH1 0x3 DUP4 MLOAD SWAP8 DUP10 DUP2 DUP2 DUP8 ADD SWAP11 DUP1 DUP13 DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 DUP12 MLOAD SWAP7 PUSH2 0x96A DUP9 PUSH2 0x1174 JUMP JUMPDEST DUP2 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP9 MSTORE PUSH1 0x1 DUP3 ADD SLOAD DUP12 DUP10 ADD MSTORE DUP2 ADD SLOAD DUP13 DUP9 ADD MSTORE ADD SLOAD SWAP1 DUP6 ADD MSTORE DUP9 MLOAD SWAP2 PUSH2 0x99A DUP11 DUP5 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x5 DUP4 MSTORE DUP8 DUP4 ADD SWAP7 PUSH5 0x1B5B39326D PUSH1 0xD8 SHL DUP9 MSTORE DUP9 DUP12 MLOAD SWAP2 PUSH2 0x9BB DUP14 DUP5 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x4 DUP4 MSTORE DUP2 DUP4 ADD SWAP4 PUSH4 0x1B5B306D PUSH1 0xE0 SHL DUP6 MSTORE DUP14 MLOAD SWAP11 DUP12 SWAP8 MLOAD DUP1 SWAP2 DUP6 DUP11 ADD MCOPY DUP8 ADD SWAP1 DUP4 DUP3 ADD SWAP1 DUP8 DUP3 MSTORE MLOAD SWAP3 DUP4 SWAP2 MCOPY ADD ADD SWAP1 DUP4 DUP3 MSTORE MLOAD DUP1 SWAP3 DUP3 MCOPY ADD SWAP1 DUP2 MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP6 MSTORE DUP5 PUSH2 0x118F JUMP JUMPDEST DUP10 DUP1 PUSH1 0xA0 SHL SUB SWAP1 MLOAD AND SWAP2 DUP6 MLOAD SWAP6 DUP7 SWAP5 PUSH4 0x319AF333 PUSH1 0xE0 SHL SWAP1 DUP7 ADD MSTORE PUSH1 0x24 DUP6 ADD MSTORE PUSH1 0x64 DUP5 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 PUSH1 0x44 DUP4 ADD MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST DUP13 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP ADD SWAP1 DUP10 SWAP4 SWAP3 SWAP2 PUSH2 0x492 JUMP JUMPDEST SWAP3 SWAP6 SWAP7 SWAP8 POP SWAP3 SWAP1 SWAP4 POP PUSH1 0xA3 NOT DUP10 DUP3 SUB ADD DUP3 MSTORE DUP5 MLOAD SWAP1 DUP9 DUP2 ADD SWAP2 PUSH1 0x1 DUP1 PUSH1 0xA0 SHL SUB DUP2 MLOAD AND DUP3 MSTORE DUP14 DUP2 ADD MLOAD PUSH1 0x3 DUP2 LT ISZERO PUSH2 0xAFC JUMPI DUP3 DUP16 ADD MSTORE DUP13 ADD MLOAD DUP2 DUP14 ADD DUP11 SWAP1 MSTORE DUP1 MLOAD SWAP3 DUP4 SWAP1 MSTORE DUP14 SWAP3 PUSH1 0x80 SWAP1 SWAP3 ADD SWAP2 SWAP1 DUP4 ADD SWAP1 DUP16 SWAP1 JUMPDEST DUP1 DUP3 LT PUSH2 0xAD8 JUMPI POP POP POP SWAP1 DUP1 PUSH1 0x1 SWAP3 SWAP7 ADD SWAP3 ADD SWAP3 ADD SWAP3 DUP12 SWAP4 DUP14 SWAP8 SWAP7 SWAP6 SWAP4 PUSH2 0x3E7 JUMP JUMPDEST DUP3 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT AND DUP5 MSTORE DUP16 SWAP5 SWAP4 DUP5 ADD SWAP4 SWAP1 SWAP3 ADD SWAP2 PUSH1 0x1 SWAP2 SWAP1 SWAP2 ADD SWAP1 PUSH2 0xAB6 JUMP JUMPDEST POP PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP16 MSTORE PUSH1 0x21 PUSH1 0x4 MSTORE PUSH1 0x24 DUP16 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP10 MSTORE PUSH1 0x1 PUSH1 0x4 MSTORE PUSH1 0x24 DUP10 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST SWAP1 POP RETURNDATASIZE DUP1 DUP8 DUP4 RETURNDATACOPY PUSH2 0xB4A DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD PUSH1 0x20 DUP3 DUP3 SUB SLT PUSH2 0xB7A JUMPI DUP2 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0xB76 JUMPI PUSH2 0xB70 SWAP3 ADD PUSH2 0x1972 JUMP JUMPDEST PUSH0 PUSH2 0x1FD JUMP JUMPDEST DUP8 DUP1 REVERT JUMPDEST DUP7 DUP1 REVERT JUMPDEST PUSH1 0x20 SWAP2 SWAP3 SWAP4 POP DUP8 MLOAD PUSH2 0xB8F DUP2 PUSH2 0x1159 JUMP JUMPDEST DUP11 DUP2 MSTORE DUP11 DUP4 DUP3 ADD MSTORE DUP10 DUP10 DUP3 ADD MSTORE DUP3 DUP3 DUP10 ADD ADD MSTORE ADD SWAP1 DUP9 SWAP3 SWAP2 PUSH2 0x1CD JUMP JUMPDEST DUP3 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x5E PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x5570646174654469616D6F6E6456696577734D756C74697369673A2076696577 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x6572206661636574206E6F74206D6174636865642C2070726F6261626C792079 PUSH1 0x64 DUP3 ADD MSTORE PUSH32 0x6F75206861766520756E77616E746564206C6F63616C206368616E6765730000 PUSH1 0x84 DUP3 ADD MSTORE PUSH1 0xA4 SWAP1 REVERT JUMPDEST POP POP SWAP1 SWAP2 SWAP3 SWAP4 PUSH2 0x1AC JUMP JUMPDEST SWAP1 SWAP2 POP RETURNDATASIZE DUP1 DUP8 DUP4 RETURNDATACOPY PUSH2 0xC59 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH1 0x20 DUP2 DUP4 SUB SLT PUSH2 0xB7A JUMPI DUP1 MLOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT PUSH2 0xB76 JUMPI ADD DUP2 PUSH1 0x1F DUP3 ADD SLT ISZERO PUSH2 0xB7A JUMPI DUP1 MLOAD SWAP1 PUSH2 0xC8F DUP3 PUSH2 0x195B JUMP JUMPDEST SWAP3 PUSH2 0xC9C DUP7 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST DUP3 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP4 PUSH1 0x5 SHL DUP4 ADD ADD SWAP2 DUP2 DUP4 GT PUSH2 0xD6D JUMPI PUSH1 0x20 DUP2 ADD SWAP4 JUMPDEST DUP4 DUP6 LT PUSH2 0xCCC JUMPI POP POP POP POP POP SWAP1 PUSH0 PUSH2 0x167 JUMP JUMPDEST DUP5 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0xD69 JUMPI DUP3 ADD SWAP1 DUP9 PUSH1 0x1F NOT DUP4 DUP7 SUB ADD SLT PUSH2 0xD69 JUMPI DUP9 MLOAD SWAP1 DUP2 DUP11 ADD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT DUP4 DUP3 LT OR PUSH2 0xD55 JUMPI DUP11 MSTORE PUSH1 0x20 DUP4 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 SUB PUSH2 0xD51 JUMPI DUP3 MSTORE DUP3 DUP11 ADD MLOAD SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP4 GT PUSH2 0xD51 JUMPI PUSH2 0xD42 DUP7 PUSH1 0x20 DUP1 SWAP7 SWAP6 DUP2 SWAP7 ADD ADD PUSH2 0x1972 JUMP JUMPDEST DUP4 DUP3 ADD MSTORE DUP2 MSTORE ADD SWAP5 ADD SWAP4 PUSH2 0xCB9 JUMP JUMPDEST DUP14 DUP1 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP15 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 DUP15 REVERT JUMPDEST DUP12 DUP1 REVERT JUMPDEST DUP10 DUP1 REVERT JUMPDEST DUP4 MLOAD RETURNDATASIZE DUP9 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH2 0xD87 SWAP2 POP PUSH0 SWAP1 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP1 PUSH2 0xBA JUMP JUMPDEST PUSH1 0x40 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST CALLVALUE PUSH2 0x78C JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x78C JUMPI PUSH4 0xF877CB19 PUSH1 0xE0 SHL DUP2 MSTORE PUSH0 DUP2 DUP1 PUSH2 0xDC2 PUSH1 0x4 DUP3 ADD PUSH2 0x1245 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x113F JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH2 0xDFE PUSH1 0x10 SLOAD PUSH2 0x1272 JUMP JUMPDEST PUSH1 0x1F DUP2 GT PUSH2 0x1104 JUMPI JUMPDEST POP PUSH1 0x20 SWAP2 PUSH1 0x1F DUP3 GT PUSH1 0x1 EQ PUSH2 0x10A4 JUMPI PUSH2 0xE29 SWAP3 PUSH0 SWAP2 DUP4 PUSH2 0xF62 JUMPI JUMPDEST POP POP PUSH2 0x12C0 JUMP JUMPDEST PUSH1 0x10 SSTORE JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 ADD DUP2 PUSH0 PUSH1 0x10 SLOAD PUSH2 0xE42 DUP2 PUSH2 0x1272 JUMP JUMPDEST SWAP1 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x108A JUMPI POP PUSH1 0x1 EQ PUSH2 0x1048 JUMPI JUMPDEST POP PUSH2 0xE79 SWAP2 DUP2 PUSH5 0x173539B7B7 PUSH1 0xD9 SHL PUSH1 0x5 SWAP4 MSTORE SUB PUSH1 0x1A NOT DUP2 ADD DUP6 MSTORE ADD DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x6C985073 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 PUSH0 DUP3 PUSH1 0x4 DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH1 0x20 SWAP4 PUSH2 0xF18 SWAP4 PUSH0 SWAP4 PUSH2 0x1024 JUMPI JUMPDEST POP DUP5 PUSH1 0x40 MLOAD PUSH2 0xEC1 PUSH1 0x40 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xD DUP2 MSTORE DUP2 DUP2 ADD SWAP1 PUSH13 0x2F6465706C6F796D656E74732F PUSH1 0x98 SHL DUP3 MSTORE PUSH1 0x40 MLOAD SWAP8 DUP7 DUP10 SWAP8 MLOAD SWAP2 DUP3 SWAP2 ADD DUP6 DUP10 ADD MCOPY DUP7 ADD SWAP1 DUP4 DUP3 ADD SWAP1 PUSH0 DUP3 MSTORE MLOAD SWAP3 DUP4 SWAP2 MCOPY ADD ADD SWAP1 PUSH0 DUP3 MSTORE MLOAD DUP1 SWAP3 DUP3 MCOPY ADD PUSH0 DUP2 MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH2 0xF33 PUSH1 0xF SLOAD PUSH2 0x1272 JUMP JUMPDEST PUSH1 0x1F DUP2 GT PUSH2 0xFCA JUMPI JUMPDEST POP PUSH1 0x20 SWAP2 PUSH1 0x1F DUP3 GT PUSH1 0x1 EQ PUSH2 0xF6D JUMPI PUSH2 0xF5D SWAP3 PUSH0 SWAP2 DUP4 PUSH2 0xF62 JUMPI POP POP PUSH2 0x12C0 JUMP JUMPDEST PUSH1 0xF SSTORE STOP JUMPDEST ADD MLOAD SWAP1 POP DUP4 DUP1 PUSH2 0xE22 JUMP JUMPDEST PUSH1 0x1F NOT DUP3 AND SWAP3 PUSH1 0xF PUSH0 MSTORE DUP1 PUSH0 KECCAK256 SWAP2 PUSH0 JUMPDEST DUP6 DUP2 LT PUSH2 0xFB2 JUMPI POP DUP4 PUSH1 0x1 SWAP6 LT PUSH2 0xF9A JUMPI JUMPDEST POP POP POP DUP2 SHL ADD PUSH1 0xF SSTORE STOP JUMPDEST ADD MLOAD PUSH0 NOT PUSH1 0xF8 DUP5 PUSH1 0x3 SHL AND SHR NOT AND SWAP1 SSTORE DUP3 DUP1 DUP1 PUSH2 0xF8F JUMP JUMPDEST SWAP2 SWAP3 PUSH1 0x20 PUSH1 0x1 DUP2 SWAP3 DUP7 DUP6 ADD MLOAD DUP2 SSTORE ADD SWAP5 ADD SWAP3 ADD PUSH2 0xF7D JUMP JUMPDEST PUSH1 0xF PUSH0 MSTORE PUSH2 0x1000 SWAP1 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2986 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE PUSH1 0x1F DUP5 ADD PUSH1 0x5 SHR DUP2 ADD SWAP2 PUSH1 0x20 DUP6 LT PUSH2 0x1006 JUMPI JUMPDEST PUSH1 0x1F ADD PUSH1 0x5 SHR ADD SWAP1 PUSH2 0x12AA JUMP JUMPDEST DUP3 PUSH2 0xF3C JUMP JUMPDEST SWAP1 SWAP2 POP DUP2 SWAP1 PUSH2 0xFF3 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH2 0x1041 SWAP2 SWAP4 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH2 0x1220 JUMP JUMPDEST SWAP2 DUP6 PUSH2 0xEB1 JUMP JUMPDEST SWAP2 POP POP PUSH1 0x10 PUSH0 MSTORE DUP3 PUSH1 0x20 PUSH0 KECCAK256 PUSH0 SWAP1 JUMPDEST DUP4 DUP3 LT PUSH2 0x1070 JUMPI POP SWAP1 SWAP2 DUP3 ADD PUSH1 0x20 ADD SWAP1 POP PUSH2 0xE79 PUSH2 0xE57 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP3 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD DUP5 SWAP2 PUSH2 0x1057 JUMP JUMPDEST PUSH1 0xFF NOT AND DUP6 MSTORE POP DUP1 ISZERO ISZERO MUL DUP3 ADD PUSH1 0x20 ADD SWAP1 POP PUSH2 0xE79 PUSH2 0xE57 JUMP JUMPDEST PUSH1 0x1F NOT DUP3 AND SWAP3 PUSH1 0x10 PUSH0 MSTORE DUP1 PUSH0 KECCAK256 SWAP2 PUSH0 JUMPDEST DUP6 DUP2 LT PUSH2 0x10EC JUMPI POP DUP4 PUSH1 0x1 SWAP6 LT PUSH2 0x10D4 JUMPI JUMPDEST POP POP POP DUP2 SHL ADD PUSH1 0x10 SSTORE PUSH2 0xE2D JUMP JUMPDEST ADD MLOAD PUSH0 NOT PUSH1 0xF8 DUP5 PUSH1 0x3 SHL AND SHR NOT AND SWAP1 SSTORE DUP3 DUP1 DUP1 PUSH2 0x10C6 JUMP JUMPDEST SWAP2 SWAP3 PUSH1 0x20 PUSH1 0x1 DUP2 SWAP3 DUP7 DUP6 ADD MLOAD DUP2 SSTORE ADD SWAP5 ADD SWAP3 ADD PUSH2 0x10B4 JUMP JUMPDEST PUSH1 0x10 PUSH0 MSTORE PUSH2 0x1139 SWAP1 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2966 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE PUSH1 0x1F DUP5 ADD PUSH1 0x5 SHR DUP2 ADD SWAP2 PUSH1 0x20 DUP6 LT PUSH2 0x1006 JUMPI PUSH1 0x1F ADD PUSH1 0x5 SHR ADD SWAP1 PUSH2 0x12AA JUMP JUMPDEST DUP3 PUSH2 0xE07 JUMP JUMPDEST PUSH2 0x1153 SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 PUSH2 0xDE2 JUMP JUMPDEST PUSH1 0x60 DUP2 ADD SWAP1 DUP2 LT PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT OR PUSH2 0x1010 JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH1 0x80 DUP2 ADD SWAP1 DUP2 LT PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT OR PUSH2 0x1010 JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH1 0x1F SWAP1 SWAP2 ADD PUSH1 0x1F NOT AND DUP2 ADD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT SWAP1 DUP3 LT OR PUSH2 0x1010 JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH1 0x1F ADD PUSH1 0x1F NOT AND PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST SWAP3 SWAP2 SWAP3 PUSH2 0x11D9 DUP3 PUSH2 0x11B2 JUMP JUMPDEST SWAP2 PUSH2 0x11E7 PUSH1 0x40 MLOAD SWAP4 DUP5 PUSH2 0x118F JUMP JUMPDEST DUP3 SWAP5 DUP2 DUP5 MSTORE DUP2 DUP4 ADD GT PUSH2 0x78C JUMPI DUP3 DUP2 PUSH1 0x20 SWAP4 DUP5 PUSH0 SWAP7 ADD MCOPY ADD ADD MSTORE JUMP JUMPDEST SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH2 0x121D SWAP3 PUSH1 0x20 ADD PUSH2 0x11CD JUMP JUMPDEST SWAP1 JUMP JUMPDEST SWAP1 PUSH1 0x20 DUP3 DUP3 SUB SLT PUSH2 0x78C JUMPI DUP2 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x78C JUMPI PUSH2 0x121D SWAP3 ADD PUSH2 0x1203 JUMP JUMPDEST PUSH1 0x60 SWAP1 PUSH1 0x20 DUP2 MSTORE PUSH1 0x12 PUSH1 0x20 DUP3 ADD MSTORE PUSH18 0x434F4E5452414354535F454E565F4E414D45 PUSH1 0x70 SHL PUSH1 0x40 DUP3 ADD MSTORE ADD SWAP1 JUMP JUMPDEST SWAP1 PUSH1 0x1 DUP3 DUP2 SHR SWAP3 AND DUP1 ISZERO PUSH2 0x12A0 JUMPI JUMPDEST PUSH1 0x20 DUP4 LT EQ PUSH2 0x128C JUMPI JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST SWAP2 PUSH1 0x7F AND SWAP2 PUSH2 0x1281 JUMP JUMPDEST DUP2 DUP2 LT PUSH2 0x12B5 JUMPI POP POP JUMP JUMPDEST PUSH0 DUP2 SSTORE PUSH1 0x1 ADD PUSH2 0x12AA JUMP JUMPDEST DUP2 PUSH1 0x1 SHL SWAP2 PUSH0 NOT SWAP1 PUSH1 0x3 SHL SHR NOT AND OR SWAP1 JUMP JUMPDEST DUP2 MLOAD SWAP2 SWAP3 SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH2 0x12EF DUP3 SLOAD PUSH2 0x1272 JUMP JUMPDEST PUSH1 0x1F DUP2 GT PUSH2 0x1388 JUMPI JUMPDEST POP PUSH1 0x20 PUSH1 0x1F DUP3 GT PUSH1 0x1 EQ PUSH2 0x132A JUMPI DUP2 SWAP1 PUSH2 0x131B SWAP4 SWAP5 SWAP6 PUSH0 SWAP3 PUSH2 0x131F JUMPI POP POP PUSH2 0x12C0 JUMP JUMPDEST SWAP1 SSTORE JUMP JUMPDEST ADD MLOAD SWAP1 POP PUSH0 DUP1 PUSH2 0xE22 JUMP JUMPDEST PUSH1 0x1F NOT DUP3 AND SWAP1 DUP4 PUSH0 MSTORE DUP1 PUSH0 KECCAK256 SWAP2 PUSH0 JUMPDEST DUP2 DUP2 LT PUSH2 0x1370 JUMPI POP SWAP6 DUP4 PUSH1 0x1 SWAP6 SWAP7 SWAP8 LT PUSH2 0x1358 JUMPI JUMPDEST POP POP POP DUP2 SHL ADD SWAP1 SSTORE JUMP JUMPDEST ADD MLOAD PUSH0 NOT PUSH1 0xF8 DUP5 PUSH1 0x3 SHL AND SHR NOT AND SWAP1 SSTORE PUSH0 DUP1 DUP1 PUSH2 0x134E JUMP JUMPDEST SWAP2 SWAP3 PUSH1 0x20 PUSH1 0x1 DUP2 SWAP3 DUP7 DUP12 ADD MLOAD DUP2 SSTORE ADD SWAP5 ADD SWAP3 ADD PUSH2 0x1339 JUMP JUMPDEST PUSH2 0x13B2 SWAP1 DUP4 PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 PUSH1 0x1F DUP5 ADD PUSH1 0x5 SHR DUP2 ADD SWAP2 PUSH1 0x20 DUP6 LT PUSH2 0x1006 JUMPI PUSH1 0x1F ADD PUSH1 0x5 SHR ADD SWAP1 PUSH2 0x12AA JUMP JUMPDEST PUSH0 PUSH2 0x12F8 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH0 DUP3 PUSH1 0xF SLOAD SWAP2 PUSH2 0x13CB DUP4 PUSH2 0x1272 JUMP JUMPDEST DUP1 DUP4 MSTORE SWAP3 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x143D JUMPI POP PUSH1 0x1 EQ PUSH2 0x13F1 JUMPI JUMPDEST PUSH2 0x13EF SWAP3 POP SUB DUP4 PUSH2 0x118F JUMP JUMPDEST JUMP JUMPDEST POP PUSH1 0xF PUSH0 SWAP1 DUP2 MSTORE SWAP1 SWAP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2986 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE JUMPDEST DUP2 DUP4 LT PUSH2 0x1421 JUMPI POP POP SWAP1 PUSH1 0x20 PUSH2 0x13EF SWAP3 DUP3 ADD ADD PUSH2 0x13E3 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP4 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD SWAP1 SWAP2 DUP5 SWAP3 PUSH2 0x1409 JUMP JUMPDEST PUSH1 0x20 SWAP3 POP PUSH2 0x13EF SWAP5 SWAP2 POP PUSH1 0xFF NOT AND DUP3 DUP5 ADD MSTORE ISZERO ISZERO PUSH1 0x5 SHL DUP3 ADD ADD PUSH2 0x13E3 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH0 DUP3 PUSH1 0x10 SLOAD SWAP2 PUSH2 0x146F DUP4 PUSH2 0x1272 JUMP JUMPDEST DUP1 DUP4 MSTORE SWAP3 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x143D JUMPI POP PUSH1 0x1 EQ PUSH2 0x1492 JUMPI PUSH2 0x13EF SWAP3 POP SUB DUP4 PUSH2 0x118F JUMP JUMPDEST POP PUSH1 0x10 PUSH0 SWAP1 DUP2 MSTORE SWAP1 SWAP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2966 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE JUMPDEST DUP2 DUP4 LT PUSH2 0x14C2 JUMPI POP POP SWAP1 PUSH1 0x20 PUSH2 0x13EF SWAP3 DUP3 ADD ADD PUSH2 0x13E3 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP4 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD SWAP1 SWAP2 DUP5 SWAP3 PUSH2 0x14AA JUMP JUMPDEST SWAP1 PUSH1 0x40 MLOAD SWAP2 DUP3 PUSH0 DUP3 SLOAD SWAP3 PUSH2 0x14F1 DUP5 PUSH2 0x1272 JUMP JUMPDEST DUP1 DUP5 MSTORE SWAP4 PUSH1 0x1 DUP2 AND SWAP1 DUP2 ISZERO PUSH2 0x155A JUMPI POP PUSH1 0x1 EQ PUSH2 0x1516 JUMPI JUMPDEST POP PUSH2 0x13EF SWAP3 POP SUB DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP1 POP PUSH0 SWAP3 SWAP2 SWAP3 MSTORE PUSH1 0x20 PUSH0 KECCAK256 SWAP1 PUSH0 SWAP2 JUMPDEST DUP2 DUP4 LT PUSH2 0x153E JUMPI POP POP SWAP1 PUSH1 0x20 PUSH2 0x13EF SWAP3 DUP3 ADD ADD PUSH0 PUSH2 0x1509 JUMP JUMPDEST PUSH1 0x20 SWAP2 SWAP4 POP DUP1 PUSH1 0x1 SWAP2 SLOAD DUP4 DUP6 DUP10 ADD ADD MSTORE ADD SWAP2 ADD SWAP1 SWAP2 DUP5 SWAP3 PUSH2 0x1525 JUMP JUMPDEST SWAP1 POP PUSH1 0x20 SWAP3 POP PUSH2 0x13EF SWAP5 SWAP2 POP PUSH1 0xFF NOT AND DUP3 DUP5 ADD MSTORE ISZERO ISZERO PUSH1 0x5 SHL DUP3 ADD ADD PUSH0 PUSH2 0x1509 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH2 0x158B PUSH1 0x40 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x7 DUP3 MSTORE PUSH7 0x111A585B5BDB99 PUSH1 0xCA SHL PUSH1 0x20 DUP4 ADD MSTORE JUMP JUMPDEST DUP1 MLOAD DUP1 DUP4 MSTORE PUSH1 0x20 SWAP3 SWAP2 DUP2 SWAP1 DUP5 ADD DUP5 DUP5 ADD MCOPY PUSH0 DUP3 DUP3 ADD DUP5 ADD MSTORE PUSH1 0x1F ADD PUSH1 0x1F NOT AND ADD ADD SWAP1 JUMP JUMPDEST SWAP1 PUSH2 0x13EF PUSH1 0x5 PUSH1 0x21 PUSH1 0x20 SWAP5 PUSH1 0x40 MLOAD SWAP6 DUP7 SWAP2 PUSH1 0x17 PUSH1 0xF9 SHL DUP3 DUP5 ADD MSTORE DUP1 MLOAD SWAP2 DUP3 SWAP2 ADD DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH5 0x1730B23239 PUSH1 0xD9 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x1A NOT DUP2 ADD DUP6 MSTORE ADD DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x20 DUP2 DUP4 SUB SLT PUSH2 0x78C JUMPI DUP1 MLOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT PUSH2 0x78C JUMPI ADD SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH2 0x121D SWAP3 PUSH1 0x20 ADD PUSH2 0x11CD JUMP JUMPDEST SWAP1 SWAP2 PUSH2 0x1655 PUSH2 0x121D SWAP4 PUSH1 0x40 DUP5 MSTORE PUSH1 0x40 DUP5 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP2 PUSH1 0x20 DUP2 DUP5 SUB SWAP2 ADD MSTORE PUSH2 0x15A1 JUMP JUMPDEST SWAP1 DUP2 PUSH1 0x20 SWAP2 SUB SLT PUSH2 0x78C JUMPI MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 SUB PUSH2 0x78C JUMPI SWAP1 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x6C985073 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 PUSH0 DUP3 PUSH1 0x4 DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0xD8E JUMPI PUSH1 0x5 PUSH1 0xD PUSH1 0x20 SWAP5 PUSH2 0x1712 SWAP4 PUSH0 SWAP2 PUSH2 0x1918 JUMPI JUMPDEST POP DUP6 PUSH1 0x40 MLOAD SWAP7 DUP3 DUP9 SWAP4 MLOAD SWAP2 DUP3 SWAP2 ADD DUP4 DUP6 ADD MCOPY DUP3 ADD PUSH13 0x2F6465706C6F796D656E74732F PUSH1 0x98 SHL DUP3 DUP3 ADD MSTORE DUP7 MLOAD SWAP1 DUP2 DUP4 DUP10 ADD PUSH1 0x2D DUP4 ADD MCOPY ADD ADD PUSH5 0x173539B7B7 PUSH1 0xD9 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x1A NOT DUP2 ADD DUP6 MSTORE ADD DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x1794 PUSH0 PUSH1 0x40 SWAP4 DUP2 DUP1 DUP3 PUSH2 0x175E DUP9 MLOAD PUSH2 0x172B DUP11 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x8 DUP2 MSTORE PUSH8 0x706174683A202573 PUSH1 0xC0 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x584 DUP11 MLOAD SWAP4 DUP5 SWAP3 PUSH4 0x4B5C4277 PUSH1 0xE0 SHL PUSH1 0x20 DUP6 ADD MSTORE PUSH1 0x24 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST PUSH1 0x20 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP DUP5 MLOAD DUP1 SWAP4 DUP2 SWAP3 PUSH4 0x60F9BB11 PUSH1 0xE0 SHL DUP4 MSTORE PUSH1 0x20 PUSH1 0x4 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x18F4 JUMPI PUSH2 0x17DF SWAP2 PUSH0 SWAP2 DUP3 SWAP2 PUSH2 0x18FE JUMPI JUMPDEST POP PUSH2 0x17C4 DUP7 PUSH2 0x15C5 JUMP JUMPDEST DUP6 MLOAD PUSH4 0x85940EF1 PUSH1 0xE0 SHL DUP2 MSTORE SWAP4 DUP5 SWAP3 DUP4 SWAP3 SWAP1 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x18F4 JUMPI PUSH0 SWAP4 PUSH2 0x18A6 DUP6 SWAP5 PUSH2 0x1894 PUSH2 0x1882 SWAP6 PUSH2 0x18BA SWAP6 DUP9 SWAP2 PUSH2 0x18D2 JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 PUSH2 0x182F SWAP2 DUP2 ADD PUSH1 0x20 SWAP1 DUP2 ADD SWAP2 ADD PUSH2 0x1663 JUMP JUMPDEST AND SWAP9 DUP5 MLOAD SWAP5 PUSH2 0x183E DUP2 DUP8 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x15 DUP7 MSTORE PUSH21 0x636F6E74726163742025734025732069733A202573 PUSH1 0x58 SHL PUSH1 0x20 DUP8 ADD MSTORE MLOAD SWAP7 DUP8 SWAP6 PUSH4 0x1B55CBD1 PUSH1 0xE2 SHL PUSH1 0x20 DUP9 ADD MSTORE PUSH1 0x80 PUSH1 0x24 DUP9 ADD MSTORE PUSH1 0xA4 DUP8 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP6 DUP2 SUB PUSH1 0x23 NOT ADD PUSH1 0x44 DUP8 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP4 DUP2 SUB PUSH1 0x23 NOT ADD PUSH1 0x64 DUP6 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP7 PUSH1 0x84 DUP4 ADD MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP4 MSTORE DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x20 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP SWAP1 JUMP JUMPDEST PUSH2 0x18EE SWAP2 POP RETURNDATASIZE DUP1 DUP11 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH2 0x1608 JUMP JUMPDEST PUSH0 PUSH2 0x1811 JUMP JUMPDEST DUP4 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH2 0x1912 SWAP2 POP RETURNDATASIZE DUP1 DUP5 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x17BA JUMP JUMPDEST PUSH2 0x192C SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x16BE JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH2 0x1941 PUSH1 0x40 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xB DUP3 MSTORE PUSH11 0x159A595DD95C919858D95D PUSH1 0xAA SHL PUSH1 0x20 DUP4 ADD MSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x1010 JUMPI PUSH1 0x5 SHL PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD SWAP1 PUSH2 0x198A DUP3 PUSH2 0x195B JUMP JUMPDEST SWAP3 PUSH2 0x1998 PUSH1 0x40 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST DUP3 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP4 PUSH1 0x5 SHL DUP3 ADD ADD SWAP2 DUP3 GT PUSH2 0x78C JUMPI PUSH1 0x20 ADD SWAP2 JUMPDEST DUP2 DUP4 LT PUSH2 0x19C0 JUMPI POP POP POP SWAP1 JUMP JUMPDEST DUP3 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP2 AND DUP2 SUB PUSH2 0x78C JUMPI DUP2 MSTORE PUSH1 0x20 SWAP3 DUP4 ADD SWAP3 ADD PUSH2 0x19B3 JUMP JUMPDEST DUP1 MLOAD ISZERO PUSH2 0x19EE JUMPI PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x32 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST DUP1 MLOAD PUSH1 0x1 LT ISZERO PUSH2 0x19EE JUMPI PUSH1 0x40 ADD SWAP1 JUMP JUMPDEST DUP1 MLOAD DUP3 LT ISZERO PUSH2 0x19EE JUMPI PUSH1 0x20 SWAP2 PUSH1 0x5 SHL ADD ADD SWAP1 JUMP JUMPDEST PUSH0 PUSH2 0x584 PUSH2 0x1A53 DUP3 SWAP4 PUSH1 0x40 MLOAD SWAP3 DUP4 SWAP2 PUSH4 0x104C13EB PUSH1 0xE2 SHL PUSH1 0x20 DUP5 ADD MSTORE PUSH1 0x20 PUSH1 0x24 DUP5 ADD MSTORE PUSH1 0x44 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST PUSH1 0x20 DUP2 MLOAD SWAP2 ADD PUSH11 0x636F6E736F6C652E6C6F67 GAS STATICCALL POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x130D191F PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD DUP2 SWAP1 MSTORE DUP2 DUP1 PUSH2 0x1A8F PUSH1 0x24 DUP3 ADD DUP7 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x200A JUMPI JUMPDEST POP ISZERO PUSH2 0x2007 JUMPI SWAP1 PUSH0 PUSH2 0x1ADE SWAP3 PUSH1 0x40 MLOAD DUP1 SWAP5 DUP2 SWAP3 PUSH4 0x60F9BB11 PUSH1 0xE0 SHL DUP4 MSTORE PUSH1 0x20 PUSH1 0x4 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP2 DUP3 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP3 PUSH2 0x1FEB JUMPI JUMPDEST POP PUSH1 0x40 MLOAD PUSH4 0x427C833 PUSH1 0xE3 SHL DUP2 MSTORE PUSH1 0x40 PUSH1 0x4 DUP3 ADD MSTORE PUSH0 DUP2 PUSH1 0x20 PUSH2 0x1B24 PUSH1 0x44 DUP4 ADD DUP8 PUSH2 0x15A1 JUMP JUMPDEST DUP4 DUP4 DUP3 SUB SWAP2 PUSH1 0x3 NOT DUP4 ADD PUSH1 0x24 DUP7 ADD MSTORE MSTORE ADD DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x1F3A JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x40 SHL DUP2 GT PUSH2 0x1010 JUMPI PUSH1 0xD SLOAD DUP2 PUSH1 0xD SSTORE DUP1 DUP3 LT PUSH2 0x1EB8 JUMPI JUMPDEST POP PUSH1 0xD PUSH0 SWAP1 DUP2 MSTORE PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2946 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE PUSH1 0x20 DUP5 ADD JUMPDEST DUP4 DUP4 LT PUSH2 0x1E9B JUMPI POP POP POP POP PUSH0 JUMPDEST DUP2 MLOAD DUP2 LT ISZERO PUSH2 0x1E95 JUMPI DUP1 PUSH2 0x1BAF PUSH2 0x1BFD SWAP3 DUP5 PUSH2 0x1A12 JUMP JUMPDEST MLOAD PUSH1 0x40 MLOAD SWAP1 PUSH2 0x1BBD DUP3 PUSH2 0x1174 JUMP JUMPDEST PUSH0 DUP3 MSTORE PUSH1 0x20 DUP3 ADD PUSH0 DUP2 MSTORE PUSH1 0x40 DUP4 ADD PUSH0 DUP2 MSTORE PUSH1 0x60 DUP5 ADD SWAP2 PUSH0 DUP4 MSTORE PUSH0 PUSH2 0x1BE0 DUP6 PUSH2 0x15C5 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x85940EF1 PUSH1 0xE0 SHL DUP2 MSTORE SWAP9 DUP10 SWAP2 DUP3 SWAP2 SWAP1 DUP15 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL DUP1 ISZERO PUSH2 0xD8E JUMPI PUSH2 0x1CA5 SWAP8 PUSH0 SWAP2 PUSH2 0x1E7B JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 PUSH2 0x1C3E SWAP2 DUP2 ADD PUSH1 0x20 SWAP1 DUP2 ADD SWAP2 ADD PUSH2 0x1663 JUMP JUMPDEST AND DUP6 MSTORE PUSH1 0x40 MLOAD PUSH1 0x17 PUSH1 0xF9 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH0 DUP6 MLOAD SWAP2 PUSH2 0x1C88 PUSH1 0x9 PUSH1 0x21 DUP4 PUSH1 0x20 DUP12 ADD SWAP7 DUP1 DUP9 DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH9 0x5CC6DEC8CA90C2E6D PUSH1 0xBB SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x16 NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x85940EF1 PUSH1 0xE0 SHL DUP2 MSTORE SWAP10 DUP11 SWAP2 DUP3 SWAP2 SWAP1 DUP16 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP8 DUP9 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP9 PUSH2 0x1E5F JUMPI JUMPDEST POP PUSH1 0x20 DUP9 MLOAD SWAP9 DUP2 DUP1 DUP3 ADD SWAP11 DUP12 SWAP3 ADD ADD SUB SLT PUSH2 0x78C JUMPI PUSH2 0x1D25 SWAP8 MLOAD DUP3 MSTORE PUSH0 PUSH1 0x40 MLOAD PUSH1 0x17 PUSH1 0xF9 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x1C88 PUSH1 0xC PUSH1 0x21 DUP4 DUP11 MLOAD DUP1 DUP9 DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH12 0x17313637B1B5A73AB6B132B9 PUSH1 0xA1 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x13 NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP8 DUP9 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP9 PUSH2 0x1E43 JUMPI JUMPDEST POP PUSH1 0x20 DUP9 DUP1 MLOAD DUP2 ADD SUB SLT PUSH2 0x78C JUMPI PUSH1 0x20 PUSH2 0x1DA6 SWAP9 ADD MLOAD DUP4 MSTORE PUSH0 PUSH1 0x40 MLOAD PUSH1 0x17 PUSH1 0xF9 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x1C88 PUSH1 0x11 PUSH1 0x21 DUP4 DUP11 MLOAD DUP1 DUP9 DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH17 0x5CC6E4CAC2E8D2DEDC86DEC8CA90C2E6D PUSH1 0x7B SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0xE NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP8 DUP9 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP9 PUSH2 0x1E27 JUMPI JUMPDEST POP PUSH1 0x20 DUP9 MLOAD SWAP9 DUP2 DUP1 DUP3 ADD SWAP11 DUP12 SWAP3 ADD ADD SUB SLT PUSH2 0x78C JUMPI PUSH1 0x20 PUSH1 0x3 SWAP6 PUSH1 0x1 SWAP10 MLOAD DUP7 MSTORE PUSH1 0x40 MLOAD SWAP3 DUP4 SWAP2 MLOAD DUP1 SWAP2 DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 SWAP5 DUP8 DUP1 PUSH1 0xA0 SHL SUB SWAP1 MLOAD AND DUP8 DUP1 PUSH1 0xA0 SHL SUB NOT DUP7 SLOAD AND OR DUP6 SSTORE MLOAD DUP7 DUP6 ADD SSTORE MLOAD PUSH1 0x2 DUP5 ADD SSTORE MLOAD SWAP2 ADD SSTORE ADD PUSH2 0x1B98 JUMP JUMPDEST PUSH2 0x1E3C SWAP2 SWAP9 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP7 PUSH0 PUSH2 0x1DC6 JUMP JUMPDEST PUSH2 0x1E58 SWAP2 SWAP9 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP7 PUSH0 PUSH2 0x1D45 JUMP JUMPDEST PUSH2 0x1E74 SWAP2 SWAP9 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP7 PUSH0 PUSH2 0x1CC5 JUMP JUMPDEST PUSH2 0x1E8F SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x1C20 JUMP JUMPDEST POP POP SWAP1 POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x20 DUP3 PUSH2 0x1EAC DUP4 SWAP5 MLOAD DUP7 PUSH2 0x12D2 JUMP JUMPDEST ADD SWAP3 ADD SWAP3 ADD SWAP2 SWAP1 PUSH2 0x1B8B JUMP JUMPDEST PUSH1 0xD PUSH0 MSTORE PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2946 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE SWAP1 DUP2 ADD SWAP1 DUP3 ADD JUMPDEST DUP2 DUP2 LT PUSH2 0x1EDE JUMPI POP PUSH2 0x1B71 JUMP JUMPDEST DUP1 PUSH2 0x1EEB PUSH1 0x1 SWAP3 SLOAD PUSH2 0x1272 JUMP JUMPDEST DUP1 PUSH2 0x1EF8 JUMPI JUMPDEST POP ADD PUSH2 0x1ED1 JUMP JUMPDEST PUSH1 0x1F DUP2 GT DUP4 EQ PUSH2 0x1F0D JUMPI POP PUSH0 DUP2 SSTORE JUMPDEST PUSH0 PUSH2 0x1EF1 JUMP JUMPDEST PUSH2 0x1F29 SWAP1 DUP3 PUSH0 MSTORE DUP4 PUSH1 0x1F PUSH1 0x20 PUSH0 KECCAK256 SWAP3 ADD PUSH1 0x5 SHR DUP3 ADD SWAP2 ADD PUSH2 0x12AA JUMP JUMPDEST DUP1 PUSH0 MSTORE PUSH0 PUSH1 0x20 DUP2 KECCAK256 DUP2 DUP4 SSTORE SSTORE PUSH2 0x1F07 JUMP JUMPDEST SWAP1 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1F4B DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SWAP1 PUSH1 0x20 DUP2 DUP4 SUB SLT PUSH2 0x78C JUMPI DUP1 MLOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP3 GT PUSH2 0x78C JUMPI ADD SWAP1 DUP1 PUSH1 0x1F DUP4 ADD SLT ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH2 0x1F81 DUP2 PUSH2 0x195B JUMP JUMPDEST SWAP3 PUSH2 0x1F8F PUSH1 0x40 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST DUP2 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP3 PUSH1 0x5 SHL DUP3 ADD ADD SWAP2 DUP4 DUP4 GT PUSH2 0x78C JUMPI PUSH1 0x20 DUP3 ADD SWAP1 JUMPDEST DUP4 DUP3 LT PUSH2 0x1FBE JUMPI POP POP POP POP POP PUSH0 PUSH2 0x1B54 JUMP JUMPDEST DUP2 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT PUSH2 0x78C JUMPI PUSH1 0x20 SWAP2 PUSH2 0x1FE0 DUP8 DUP5 DUP1 SWAP5 DUP9 ADD ADD PUSH2 0x1203 JUMP JUMPDEST DUP2 MSTORE ADD SWAP2 ADD SWAP1 PUSH2 0x1FAC JUMP JUMPDEST PUSH2 0x2000 SWAP2 SWAP3 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP1 PUSH0 PUSH2 0x1AFE JUMP JUMPDEST POP JUMP JUMPDEST SWAP1 POP PUSH1 0x20 DUP2 RETURNDATASIZE PUSH1 0x20 GT PUSH2 0x203D JUMPI JUMPDEST DUP2 PUSH2 0x2025 PUSH1 0x20 SWAP4 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0x78C JUMPI MLOAD DUP1 ISZERO ISZERO DUP2 SUB PUSH2 0x78C JUMPI PUSH0 PUSH2 0x1AB0 JUMP JUMPDEST RETURNDATASIZE SWAP2 POP PUSH2 0x2018 JUMP JUMPDEST PUSH0 NOT DUP2 EQ PUSH2 0xB25 JUMPI PUSH1 0x1 ADD SWAP1 JUMP JUMPDEST PUSH1 0xD SLOAD DUP2 LT ISZERO PUSH2 0x19EE JUMPI PUSH1 0xD PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 ADD SWAP1 PUSH0 SWAP1 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 PUSH2 0x207A PUSH1 0x40 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x10 DUP3 MSTORE PUSH16 0xC6E4CAC2E8D2DEDC86DEC8CA90C2E6D PUSH1 0x83 SHL PUSH1 0x20 DUP4 ADD MSTORE JUMP JUMPDEST SWAP1 PUSH0 SWAP1 PUSH1 0x20 SWAP1 PUSH1 0x40 MLOAD SWAP4 PUSH2 0x20AD DUP4 DUP7 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP6 MSTORE PUSH1 0x40 MLOAD PUSH2 0x20BD DUP5 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP2 MSTORE SWAP2 PUSH0 SWAP5 PUSH1 0x40 SWAP4 JUMPDEST PUSH1 0xD SLOAD DUP8 LT ISZERO PUSH2 0x2364 JUMPI POP PUSH2 0x20DE PUSH2 0x93B DUP8 PUSH2 0x2053 JUMP JUMPDEST DUP5 MLOAD DUP7 DUP2 DUP4 MLOAD DUP1 DUP4 DUP7 ADD DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 DUP6 MLOAD SWAP1 PUSH2 0x2100 DUP3 PUSH2 0x1174 JUMP JUMPDEST DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP3 MSTORE PUSH1 0x1 DUP2 ADD SLOAD DUP9 DUP4 ADD SWAP1 DUP2 MSTORE PUSH1 0x2 DUP3 ADD SLOAD DUP9 DUP5 ADD SWAP1 DUP2 MSTORE PUSH1 0x3 SWAP1 SWAP3 ADD SLOAD PUSH1 0x60 DUP5 ADD SWAP1 DUP2 MSTORE DUP9 MLOAD PUSH4 0xF877CB19 PUSH1 0xE0 SHL DUP2 MSTORE SWAP1 SWAP4 SWAP1 PUSH0 DUP2 DUP1 PUSH2 0x214E PUSH1 0x4 DUP3 ADD PUSH2 0x1245 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x235A JUMPI SWAP2 PUSH2 0x219D DUP12 PUSH0 SWAP4 DUP15 PUSH2 0x21E6 SWAP7 DUP7 SWAP3 PUSH2 0x2334 JUMPI JUMPDEST POP PUSH5 0x1B1BD8D85B PUSH1 0xDA SHL SWAP1 PUSH2 0x2191 DUP5 MLOAD SWAP5 DUP6 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x5 DUP5 MSTORE DUP4 ADD MSTORE PUSH2 0x2431 JUMP JUMPDEST PUSH2 0x2325 JUMPI JUMPDEST MLOAD DUP11 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND SWAP1 PUSH2 0x21BB DUP13 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x4 DUP2 MSTORE PUSH4 0x30B23239 PUSH1 0xE1 SHL DUP14 DUP3 ADD MSTORE DUP12 MLOAD SWAP4 DUP5 SWAP3 DUP4 SWAP3 PUSH4 0x4B963031 PUSH1 0xE1 SHL DUP5 MSTORE DUP11 PUSH1 0x4 DUP6 ADD PUSH2 0x245E JUMP JUMPDEST SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x231B JUMPI SWAP1 PUSH2 0x2232 SWAP3 SWAP2 PUSH2 0x2303 JUMPI JUMPDEST POP MLOAD DUP9 MLOAD PUSH2 0x2218 DUP11 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x8 DUP2 MSTORE PUSH8 0xC6DEC8CA90C2E6D PUSH1 0xC3 SHL DUP12 DUP3 ADD MSTORE DUP6 PUSH2 0x2498 JUMP JUMPDEST POP MLOAD PUSH0 PUSH2 0x2292 DUP9 MLOAD PUSH2 0x2244 DUP11 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xB DUP2 MSTORE PUSH11 0x313637B1B5A73AB6B132B9 PUSH1 0xA9 SHL DUP12 DUP3 ADD MSTORE DUP10 MLOAD PUSH4 0x94F4801 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x60 PUSH1 0x4 DUP3 ADD MSTORE SWAP4 DUP5 SWAP3 DUP4 SWAP3 PUSH2 0x2280 PUSH1 0x64 DUP6 ADD DUP11 PUSH2 0x15A1 JUMP JUMPDEST DUP5 DUP2 SUB PUSH1 0x3 NOT ADD PUSH1 0x24 DUP7 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 PUSH1 0x44 DUP4 ADD MSTORE SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL DUP1 ISZERO PUSH2 0x22F9 JUMPI PUSH2 0x22D9 SWAP3 PUSH1 0x1 SWAP5 SWAP3 PUSH2 0x22D2 SWAP3 PUSH2 0x22E1 JUMPI JUMPDEST POP MLOAD PUSH2 0x22CC PUSH2 0x206B JUMP JUMPDEST DUP4 PUSH2 0x2498 JUMP JUMPDEST SWAP1 DUP11 PUSH2 0x2504 JUMP JUMPDEST SWAP7 ADD SWAP6 PUSH2 0x20C7 JUMP JUMPDEST PUSH2 0x22F4 SWAP1 RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x22C2 JUMP JUMPDEST DUP8 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH2 0x2316 SWAP1 RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x220A JUMP JUMPDEST DUP10 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST PUSH1 0x1 DUP6 MSTORE DUP2 DUP5 MSTORE DUP2 DUP7 MSTORE PUSH2 0x21A2 JUMP JUMPDEST PUSH5 0x1B1BD8D85B PUSH1 0xDA SHL SWAP2 SWAP3 POP PUSH2 0x2353 SWAP1 RETURNDATASIZE DUP1 DUP10 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP2 SWAP1 PUSH2 0x217A JUMP JUMPDEST DUP11 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST SWAP2 SWAP6 POP SWAP3 SWAP2 SWAP6 POP PUSH2 0x2383 DUP3 MLOAD PUSH2 0x237A DUP7 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH0 DUP2 MSTORE DUP3 PUSH2 0x2431 JUMP JUMPDEST PUSH2 0x2429 JUMPI PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE EXTCODESIZE ISZERO PUSH2 0x78C JUMPI DUP2 MLOAD PUSH4 0xE23CD19F PUSH1 0xE0 SHL DUP2 MSTORE SWAP6 PUSH0 SWAP2 DUP8 SWAP2 DUP3 SWAP2 PUSH2 0x23BC SWAP2 SWAP1 PUSH1 0x4 DUP5 ADD PUSH2 0x163E JUMP JUMPDEST SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP5 DUP6 ISZERO PUSH2 0x241F JUMPI PUSH2 0x2007 SWAP5 SWAP6 PUSH2 0x2408 JUMPI JUMPDEST POP PUSH2 0x23ED SWAP1 MLOAD SWAP3 DUP4 PUSH2 0x118F JUMP JUMPDEST DUP2 MSTORE PUSH2 0x2401 DUP2 PUSH2 0x23FB PUSH2 0x206B JUMP JUMPDEST DUP2 PUSH2 0x2504 JUMP JUMPDEST SWAP1 DUP1 PUSH2 0x2504 JUMP JUMPDEST PUSH2 0x2415 SWAP2 SWAP3 POP PUSH0 SWAP1 PUSH2 0x118F JUMP JUMPDEST PUSH0 SWAP1 PUSH2 0x23ED PUSH2 0x23E0 JUMP JUMPDEST POP MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST POP POP POP POP SWAP1 POP JUMP JUMPDEST SWAP1 DUP2 MLOAD DUP2 MLOAD SWAP1 DUP2 DUP2 EQ SWAP4 DUP5 PUSH2 0x2448 JUMPI JUMPDEST POP POP POP POP SWAP1 JUMP JUMPDEST PUSH1 0x20 SWAP3 SWAP4 SWAP5 POP DUP3 ADD KECCAK256 SWAP3 ADD KECCAK256 EQ PUSH0 DUP1 DUP1 DUP1 PUSH2 0x2441 JUMP JUMPDEST SWAP2 PUSH2 0x2488 SWAP1 PUSH2 0x247A PUSH1 0x40 SWAP4 SWAP7 SWAP6 SWAP7 PUSH1 0x60 DUP7 MSTORE PUSH1 0x60 DUP7 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 DUP5 DUP3 SUB PUSH1 0x20 DUP7 ADD MSTORE PUSH2 0x15A1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP5 AND SWAP2 ADD MSTORE JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0xB604AD1 PUSH1 0xE2 SHL DUP2 MSTORE PUSH1 0x60 PUSH1 0x4 DUP3 ADD MSTORE SWAP3 PUSH0 SWAP3 DUP5 SWAP3 DUP4 SWAP3 SWAP2 PUSH2 0x24C6 SWAP2 PUSH2 0x2280 SWAP1 PUSH1 0x64 DUP7 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SWAP1 PUSH1 0x44 DUP4 ADD MSTORE SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x24F0 JUMPI POP SWAP1 JUMP JUMPDEST PUSH2 0x121D SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x1039 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH2 0x2534 SWAP1 PUSH2 0x2558 PUSH0 SWAP4 SWAP5 PUSH2 0x2546 PUSH1 0x40 MLOAD SWAP7 DUP8 SWAP6 DUP7 SWAP6 PUSH4 0x88DA6D35 PUSH1 0xE0 SHL DUP8 MSTORE PUSH1 0x60 PUSH1 0x4 DUP9 ADD MSTORE PUSH1 0x64 DUP8 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP6 DUP2 SUB PUSH1 0x3 NOT ADD PUSH1 0x24 DUP8 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST DUP4 DUP2 SUB PUSH1 0x3 NOT ADD PUSH1 0x44 DUP6 ADD MSTORE SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 DUP4 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS CALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x24F0 JUMPI POP SWAP1 JUMP JUMPDEST SWAP3 SWAP2 SWAP3 PUSH1 0x40 MLOAD DUP2 MLOAD SWAP1 PUSH1 0x20 DUP2 DUP2 DUP6 ADD SWAP4 DUP1 DUP6 DUP4 MCOPY DUP2 ADD PUSH1 0xE DUP2 MSTORE SUB ADD SWAP1 KECCAK256 SWAP5 PUSH1 0x40 MLOAD SWAP1 PUSH2 0x25A8 DUP3 PUSH2 0x1174 JUMP JUMPDEST PUSH1 0x1 DUP1 PUSH1 0xA0 SHL SUB DUP8 SLOAD AND DUP3 MSTORE PUSH1 0x20 PUSH2 0x260C PUSH1 0x4 DUP3 PUSH1 0x3 PUSH1 0x1 DUP13 ADD SLOAD SWAP12 DUP3 DUP9 ADD SWAP13 DUP14 MSTORE PUSH1 0x2 DUP2 ADD SLOAD PUSH1 0x40 DUP10 ADD MSTORE ADD SLOAD SWAP9 PUSH1 0x60 DUP8 ADD SWAP10 DUP11 MSTORE PUSH1 0x40 MLOAD SWAP5 DUP2 DUP7 SWAP3 MLOAD SWAP2 DUP3 SWAP2 ADD DUP5 DUP5 ADD MCOPY DUP2 ADD PUSH4 0xB9CDBDB PUSH1 0xE2 SHL DUP4 DUP3 ADD MSTORE SUB ADD PUSH1 0x1B NOT DUP2 ADD DUP5 MSTORE ADD DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x8D1CC925 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE SWAP2 PUSH0 DUP4 DUP1 PUSH2 0x2631 PUSH1 0x24 DUP3 ADD DUP7 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP3 DUP4 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP4 PUSH2 0x28D2 JUMPI JUMPDEST POP PUSH0 PUSH1 0x20 SWAP3 PUSH2 0x2695 PUSH2 0x26B7 SWAP4 DUP6 PUSH1 0x40 MLOAD SWAP7 DUP8 SWAP3 DUP2 DUP1 DUP6 ADD SWAP11 DUP1 MLOAD SWAP2 DUP3 SWAP2 ADD DUP13 MCOPY DUP5 ADD SWAP1 DUP3 DUP3 ADD DUP9 DUP2 MSTORE DUP2 MLOAD SWAP4 DUP5 SWAP3 ADD SWAP1 MCOPY ADD ADD DUP5 DUP2 MSTORE SUB PUSH1 0x1F NOT DUP2 ADD DUP7 MSTORE DUP6 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP4 DUP2 SWAP3 PUSH4 0xFAFDCED PUSH1 0xE2 SHL DUP4 MSTORE PUSH1 0x20 PUSH1 0x4 DUP5 ADD MSTORE PUSH1 0x24 DUP4 ADD SWAP1 PUSH2 0x15A1 JUMP JUMPDEST SUB DUP2 PUSH0 DUP1 MLOAD PUSH1 0x20 PUSH2 0x2926 DUP4 CODECOPY DUP2 MLOAD SWAP2 MSTORE GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0xD8E JUMPI PUSH0 SWAP2 PUSH2 0x28B8 JUMPI JUMPDEST POP DUP1 MLOAD PUSH1 0x20 SWAP1 SWAP2 ADD KECCAK256 DUP2 MLOAD DUP4 KECCAK256 SWAP4 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP1 ISZERO SWAP10 SWAP2 SWAP8 SWAP1 SWAP2 DUP11 ISZERO PUSH2 0x28AC JUMPI JUMPDEST POP DUP10 ISZERO PUSH2 0x28A0 JUMPI JUMPDEST POP DUP9 ISZERO PUSH2 0x2896 JUMPI JUMPDEST DUP9 ISZERO PUSH2 0x285B JUMPI POP MLOAD SWAP1 PUSH0 CREATE SWAP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP6 AND SWAP2 DUP3 ISZERO PUSH2 0x281A JUMPI DUP8 SWAP4 PUSH1 0x3 SWAP3 PUSH1 0x40 SWAP2 PUSH2 0x2764 DUP10 DUP10 DUP6 MLOAD PUSH2 0x2743 DUP8 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0xF DUP2 MSTORE PUSH15 0x4465706C6F79202573206174202573 PUSH1 0x88 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x28FD JUMP JUMPDEST DUP3 MLOAD SWAP6 PUSH2 0x2770 DUP8 PUSH2 0x1174 JUMP JUMPDEST DUP7 MSTORE PUSH1 0x20 DUP7 ADD SWAP2 DUP3 MSTORE PUSH1 0x20 DUP4 DUP8 ADD SWAP4 NUMBER DUP6 MSTORE PUSH1 0x60 DUP9 ADD SWAP6 DUP7 MSTORE MLOAD DUP1 SWAP3 DUP11 MLOAD DUP1 SWAP2 DUP4 MCOPY PUSH1 0xE SWAP1 DUP3 ADD SWAP1 DUP2 MSTORE SUB ADD SWAP1 KECCAK256 SWAP5 MLOAD DUP6 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 SWAP1 SWAP2 AND OR DUP6 SSTORE MLOAD PUSH1 0x1 DUP6 ADD SSTORE MLOAD PUSH1 0x2 DUP5 ADD SSTORE MLOAD SWAP2 ADD SSTORE PUSH2 0x27D4 JUMPI POP SWAP2 SWAP1 JUMP JUMPDEST PUSH1 0xD SLOAD PUSH1 0x1 PUSH1 0x40 SHL DUP2 LT ISZERO PUSH2 0x1010 JUMPI DUP1 PUSH1 0x1 PUSH2 0x27F3 SWAP3 ADD PUSH1 0xD SSTORE PUSH2 0x2053 JUMP JUMPDEST SWAP2 SWAP1 SWAP2 PUSH2 0x2807 JUMPI PUSH2 0x2803 SWAP2 PUSH2 0x12D2 JUMP JUMPDEST SWAP2 SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x19 PUSH1 0x24 DUP3 ADD MSTORE PUSH25 0x11985A5B1959081D1BC819195C1B1BDE4818DBDB9D1C9858DD PUSH1 0x3A SHL PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 SWAP1 REVERT JUMPDEST SWAP6 POP POP POP POP POP DUP2 PUSH2 0x2803 SWAP2 PUSH1 0x40 MLOAD PUSH2 0x2874 PUSH1 0x40 DUP3 PUSH2 0x118F JUMP JUMPDEST PUSH1 0x10 DUP2 MSTORE PUSH16 0x52657573696E67202573206174202573 PUSH1 0x80 SHL PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x28FD JUMP JUMPDEST DUP1 EXTCODEHASH ISZERO SWAP9 POP PUSH2 0x270D JUMP JUMPDEST MLOAD DUP5 EQ ISZERO SWAP9 POP PUSH0 PUSH2 0x2705 JUMP JUMPDEST MLOAD DUP9 EQ ISZERO SWAP10 POP PUSH0 PUSH2 0x26FD JUMP JUMPDEST PUSH2 0x28CC SWAP2 POP RETURNDATASIZE DUP1 PUSH0 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST PUSH0 PUSH2 0x26D7 JUMP JUMPDEST PUSH2 0x26B7 SWAP2 SWAP4 POP PUSH1 0x20 SWAP3 PUSH2 0x2695 PUSH2 0x28F2 PUSH0 SWAP4 RETURNDATASIZE DUP1 DUP7 DUP4 RETURNDATACOPY PUSH2 0x18E6 DUP2 DUP4 PUSH2 0x118F JUMP JUMPDEST SWAP6 SWAP4 POP POP SWAP3 POP PUSH2 0x2651 JUMP JUMPDEST SWAP1 PUSH2 0x1A53 PUSH0 SWAP4 SWAP3 PUSH2 0x584 DUP6 SWAP5 PUSH1 0x40 MLOAD SWAP5 DUP6 SWAP4 PUSH4 0x95ED0195 PUSH1 0xE0 SHL PUSH1 0x20 DUP7 ADD MSTORE PUSH1 0x24 DUP6 ADD PUSH2 0x245E JUMP INVALID STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP PUSH18 0x9709ECFA91A80626FF3989D68F67F5B1DD1 0x2D 0xD7 0xB6 SWAP10 ADD SDIV PUSH18 0x9101DABEB77144F2A3385C8033ACD3AF97E9 TIMESTAMP GASPRICE PUSH10 0x5E81AD1EB51B6847DC74 BYTE SHL 0xC 0xD0 DUP14 0x27 DUP9 GASLIMIT 0xF9 0xD8 NOT 0xD8 PUSH28 0x734759AFB55FE2DE5CB82A9AE6728D1108E10BCB7C27DDDFC02ED9D6 SWAP4 LOG0 PUSH21 0x39D026CF4EA4240B40F7D581AC802A26469706673 PC 0x22 SLT KECCAK256 CREATE2 INVALID SWAP16 0xB2 DUP5 0xDA KECCAK256 0x22 NOT 0xAC 0x25 0xC9 NOT 0x22 0xC4 RETURN 0xE 0xE6 0xD1 EXTCODEHASH 0xD9 0xB7 0xCE 0xD7 0xE8 PUSH8 0xF21A10B32D9B6473 PUSH16 0x6C634300081A00330000000000000000 ","sourceMap":"1991:4470:35:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;800:28:1;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;1991:4470:35;;;;-1:-1:-1;;;;;;;;;;;5389:19:35;;;;1991:4470;;-1:-1:-1;;;5389:19:35;;1991:4470;;;;;-1:-1:-1;;;;;;;;;;;5389:19:35;;;;;;;;1991:4470;;5086:36;1991:4470;;:::i;:::-;5086:36;:::i;:::-;1991:4470;5133:36;1991:4470;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1590:14:0;1991:4470:35;;;5133:36;:::i;:::-;5461:35;1991:4470;;:::i;:::-;;;:::i;:::-;5461:35;;:::i;:::-;3120;1991:4470;;:::i;3120:35::-;1991:4470;3188:39;1991:4470;;:::i;:::-;;;:::i;3188:39::-;1991:4470;;-1:-1:-1;;;3589:31:35;;1991:4470;;-1:-1:-1;;;;;1991:4470:35;;3589:31;1991:4470;;;;3589:31;;;;;;;;;;;1991:4470;-1:-1:-1;3630:18:35;;-1:-1:-1;;;;;1991:4470:35;;3630:18;3703:3;1590:14:0;;3678:23:35;;;;;1991:4470;-1:-1:-1;;;;;3726:15:35;;;;:::i;:::-;;1991:4470;;3726:43;3722:117;;1991:4470;;3663:13;;3722:117;3789:12;;;;;;;1991:4470;3658:191;1991:4470;;;;;;;;1590:14:0;;;;;:::i;:::-;4230:1:35;1991:4470;;-1:-1:-1;;1991:4470:35;;;;;;;;;;;4283:58;1991:4470;;1590:14:0;;;;;;;4283:58:35;;1991:4470;4283:58;;2234:42;4283:58;;;;;;;;;;;1991:4470;;;;1590:14:0;;;;:::i;:::-;1991:4470:35;;;4230:1;1590:14:0;4367:180:35;;1991:4470;4367:180;;;1991:4470;4351:196;;;:::i;:::-;;;;;:::i;:::-;;1590:14:0;1991:4470:35;4569:59:36;1991:4470:35;;1590:14:0;;;;:::i;:::-;;;;-1:-1:-1;;1991:4470:35;;;;;;;;;:::i;:::-;;;:::i;:::-;4569:59:36;;:::i;:::-;-1:-1:-1;1991:4470:35;;;;;1590:14:0;1991:4470:35;;1590:14:0;:::i;:::-;16320:1:37;1991:4470:35;;-1:-1:-1;;1991:4470:35;;;;;;-1:-1:-1;;;16412:55:37;;;:::i;:::-;1991:4470:35;4230:1;;-1:-1:-1;;;16477:47:37;16494:30;16477:47;:::i;:::-;1991:4470:35;16320:1:37;1991:4470:35;-1:-1:-1;;;16534:48:37;4230:1:35;16534:48:37;;:::i;:::-;1991:4470:35;16602:3:37;;;:::i;:::-;16609:29;-1:-1:-1;;;16609:29:37;16592:46;;;;:::i;:::-;1991:4470:35;16658:3:37;;;:::i;:::-;16665:28;-1:-1:-1;;;16665:28:37;16648:45;;;;:::i;:::-;1991:4470:35;16713:3:37;;;:::i;:::-;16720:28;-1:-1:-1;;;16720:28:37;16703:45;;;;:::i;:::-;1991:4470:35;16768:3:37;;;:::i;:::-;16775:27;-1:-1:-1;;;16775:27:37;16758:44;;;;:::i;:::-;1991:4470:35;16822:3:37;;;:::i;:::-;16829:27;-1:-1:-1;;;16829:27:37;16812:44;;;;:::i;:::-;1991:4470:35;16876:3:37;;;:::i;:::-;16883:26;-1:-1:-1;;;16883:26:37;16866:43;;;;:::i;:::-;1991:4470:35;16927:10:37;1991:4470:35;;;;;;;;1590:14:0;;;;:::i;:::-;-1:-1:-1;;;;;1991:4470:35;;;4698:179;;;1991:4470;;;4698:179;;;1991:4470;4682:195;;;:::i;:::-;;;;;:::i;:::-;;1991:4470;;4912:83;;;;;4935:31;;;;4912:83;;1991:4470;;;4912:83;4283:58;4912:83;;1991:4470;1590:14:0;;;;;;;;1991:4470:35;;1590:14:0;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;4912:83;1991:4470;;;;;2234:42;1991:4470;;;;;;;;;;;;;1590:14:0;4912:83:35;;;;;;:::i;:::-;7345:17:36;1991:4470:35;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;7345:17:36;:::i;:::-;7372:62;1991:4470:35;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;1991:4470:35;;;;;-1:-1:-1;;;1991:4470:35;;;;7372:62:36;:::i;:::-;7468:10;1991:4470:35;;7449:13:36;7464:35;;;;;;;;;1991:4470:35;;;;;;5261:36;1991:4470;;:::i;:::-;5261:36;:::i;:::-;5308:33;1991:4470;;1590:14:0;;;;:::i;:::-;5477:7:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;5308:33;:::i;:::-;-1:-1:-1;;;;;;;;;;;5576:18:35;;;;1991:4470;;-1:-1:-1;;;5576:18:35;;;1991:4470;;;5576:18;-1:-1:-1;;;;;;;;;;;5576:18:35;;;;;;;;;;;7444:289:36;1590:14:0;;5695:41:35;1991:4470;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;5695:41;:::i;:::-;762:159:10;1991:4470:35;;;1728:41:10;;;;;;;;4283:58:35;1728:41:10;;1991:4470:35;1728:41:10;1991:4470:35;;;;;;;:::i;:::-;1728:41:10;1590:14:0;;1728:41:10;;;;;;:::i;:::-;1590:14:0;;;762:159:10;;131:42;762:159;;;5801:41:35;1991:4470;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;5801:41;:::i;:::-;1991:4470;;-1:-1:-1;;;5954:36:35;;-1:-1:-1;;;;;1991:4470:35;;;;;5954:36;1991:4470;;;;5954:36;;;;;;;;;;;7444:289:36;6001:40:35;-1:-1:-1;;;;;;;;;;;6001:40:35;;;;1991:4470;;-1:-1:-1;;;6001:40:35;;2234:42;1991:4470;6001:40;;2234:42;6001:40;1991:4470;4283:58;1991:4470;6001:40;-1:-1:-1;;;;;;;;;;;6001:40:35;;;;;;;;;;;;;;7444:289:36;6070:17:35;;;;;;;;2234:42;;;;;;1590:14:0;;;:::i;:::-;1991:4470:35;1590:14:0;1991:4470:35;;1590:14:0;;;:::i;:::-;;;2234:42:35;;;;;;;;;;1991:4470;;-1:-1:-1;;;6201:36:35;;1991:4470;6201:36;1991:4470;;;6201:36;;;;;;;;;;;;2234:42;6255:35;;2234:42;;1590:14:0;;1991:4470:35;1590:14:0;6346:39:35;1991:4470;;1590:14:0;;;;:::i;:::-;2234:42:35;1590:14:0;;-1:-1:-1;;;2234:42:35;;;;6346:39;:::i;:::-;1991:4470;;-1:-1:-1;;;6415:36:35;;1991:4470;;;;;6415:36;;;;;;;;;;;2234:42;1991:4470;;762:159:10;1991:4470:35;;;;5827:43:10;;;;;;;;4283:58:35;5827:43:10;;1991:4470:35;4283:58;5827:43:10;;;1991:4470:35;5827:43:10;;:::i;:::-;1590:14:0;;762:159:10;;131:42;762:159;;;1991:4470:35;;6415:36;;;;;;;;;;;;;;;;:::i;:::-;;;1991:4470;;;;;;;762:159:10;6415:36:35;;1991:4470;-1:-1:-1;1991:4470:35;;6415:36;;;;;;1991:4470;;1590:14:0;1991:4470:35;;1590:14:0;;;;2234:42:35;1991:4470;;-1:-1:-1;;;2234:42:35;;1991:4470;2234:42;;;;;;4283:58;2234:42;;1590:14:0;2234:42:35;1991:4470;1590:14:0;;2234:42:35;-1:-1:-1;;;1991:4470:35;2234:42;;;1991:4470;;2234:42;6201:36;;;;;;;;;;;;;;;;;:::i;:::-;;;1991:4470;;;;;6201:36;;;;;;;;;;1991:4470;;1590:14:0;1991:4470:35;;1590:14:0;;;;2234:42:35;1991:4470;;-1:-1:-1;;;2234:42:35;;1991:4470;2234:42;;;;;1991:4470;4283:58;2234:42;;1590:14:0;2234:42:35;1991:4470;1590:14:0;;2234:42:35;-1:-1:-1;;;1991:4470:35;2234:42;;;1991:4470;;2234:42;;;;;6001:40;;;;;;;;:::i;:::-;1991:4470;;6001:40;;;;;1991:4470;;;;6001:40;1991:4470;;1590:14:0;1991:4470:35;;1590:14:0;;;;5954:36:35;;;;;;;;;;;;;;;;;;;:::i;:::-;;;1991:4470;;;;;;;5954:36;;;;;;;;;;1991:4470;;1590:14:0;1991:4470:35;;1590:14:0;;;;5576:18:35;;;;;:::i;:::-;1991:4470;;5576:18;;;;1991:4470;;;;5576:18;1991:4470;;1590:14:0;1991:4470:35;;1590:14:0;;;;7501:3:36;7541:27;7704:54:10;762:159;7541:27:36;;;;1991:4470:35;7541:27:36;847:36:7;1991:4470:35;7541:27:36;;;;1991:4470:35;7541:27:36;;;:::i;:::-;1991:4470:35;;:::i;:::-;;;;1590:14:0;1991:4470:35;1590:14:0;;2107:15:35;;;;;;1590:14:0;;;;;;;7625:20:36;1991:4470:35;;;;;;;;1590:14:0;;;;:::i;:::-;1991:4470:35;;-1:-1:-1;;;;;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;1590:14:0;1991:4470:35;;1590:14:0;:::i;:::-;1991:4470:35;1590:14:0;;1991:4470:35;;;;;;;;;;;;1590:14:0;;;;;:::i;:::-;1991:4470:35;1590:14:0;;1991:4470:35;;;;;;;;;;;1590:14:0;;;;847:36:7;;;;;1590:14:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;847:36:7;1590:14:0;;847:36:7;;;;;;:::i;:::-;1991:4470:35;;;;;;;;;;;7704:54:10;;;;;;;;;;4283:58:35;7704:54:10;;1991:4470:35;;;;;;:::i;:::-;;;;;2234:42;7704:54:10;1590:14:0;;7704:54:10;;;;;;:::i;:::-;1590:14:0;;;762:159:10;;131:42;762:159;;;1991:4470:35;7449:13:36;;;;;;;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;1590:14:0;1991:4470:35;;;;;;;2234:42;;1991:4470;;;;;;;;;;;;;;;;;;;;;;;1590:14:0;;;;;;1991:4470:35;;1590:14:0;;;;;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;1991:4470:35;;;;;4283:58;1590:14:0;1991:4470:35;;-1:-1:-1;;;1991:4470:35;;;;;4283:58;1590:14:0;1991:4470:35;;1590:14:0;;;-1:-1:-1;1991:4470:35;;;;;-1:-1:-1;1991:4470:35;4283:58;;;;;;;;;;;;:::i;:::-;;;1590:14:0;1991:4470:35;;;;;;;;-1:-1:-1;;;;;1991:4470:35;;;;;;;;:::i;:::-;4283:58;;;1991:4470;;;;;;;;;1590:14:0;1991:4470:35;;;;;;1590:14:0;;;:::i;:::-;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;1991:4470:35;;1590:14:0;1991:4470:35;;;;;;;;1590:14:0;1991:4470:35;1590:14:0;;;1991:4470:35;;;;;;;;;;;;;;3678:23;;;;;;;;;3589:31;;;;;;;;;;;;;:::i;:::-;;;1991:4470;1590:14:0;1991:4470:35;;;;;;;;;-1:-1:-1;;;;;1991:4470:35;;;;;;1590:14:0;1991:4470:35;;;;;;;;;;;;:::i;:::-;;1590:14:0;1991:4470:35;;1590:14:0;;;:::i;:::-;1991:4470:35;;;1590:14:0;1991:4470:35;;;;;;;;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;;3589:31;;;;;;;;;1991:4470;;;-1:-1:-1;;;;;1991:4470:35;;;;;;1590:14:0;;;;1991:4470:35;;;;;;;;;;1590:14:0;;;-1:-1:-1;;;;;1590:14:0;;;;;;;;;;;1991:4470:35;;;-1:-1:-1;;;;;1991:4470:35;;;;;;;;;;;;;-1:-1:-1;;;;;1991:4470:35;;;;;;1590:14:0;1991:4470:35;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;1590:14:0;-1:-1:-1;;;1590:14:0;;;1991:4470:35;1590:14:0;;;;1991:4470:35;;;;;;;;3589:31;1991:4470;;1590:14:0;1991:4470:35;;1590:14:0;;;;5389:19:35;;;;1991:4470;5389:19;;:::i;:::-;1991:4470;5389:19;;;;1991:4470;;1590:14:0;1991:4470:35;1590:14:0;;;;;1991:4470:35;;;;;;-1:-1:-1;;1991:4470:35;;;;-1:-1:-1;;;2329:34:35;;1991:4470;2329:34;;;1991:4470;2329:34;;;:::i;:::-;;;-1:-1:-1;;;;;;;;;;;2329:34:35;;;;;;;1991:4470;2329:34;;;1991:4470;-1:-1:-1;1590:14:0;;-1:-1:-1;;;;;1590:14:0;;;;;2319:44:35;1590:14:0;;:::i;:::-;;;;;;1991:4470:35;1590:14:0;;;;;;;;;;;;1991:4470:35;;1590:14:0;;;;;;;:::i;:::-;2319:44:35;1590:14:0;;1991:4470:35;;1590:14:0;;;;1991:4470:35;2319:44;1590:14:0;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;1590:14:0;;;;;;;;;;;;;:::i;:::-;1991:4470:35;;-1:-1:-1;;;2476:16:35;;1991:4470;;;;;-1:-1:-1;;;;;;;;;;;2476:16:35;;;;;;;1590:14:0;2476:16:35;2107:15;2476:16;1991:4470;2476:16;;;1590:14:0;;1991:4470:35;;;1590:14:0;1991:4470:35;1590:14:0;;:::i;:::-;;;;;;;;-1:-1:-1;;;1590:14:0;;1991:4470:35;;1590:14:0;;;;;2107:15:35;;;;;;;1590:14:0;;;;;;;;1991:4470:35;1590:14:0;;;;;;;;;;1991:4470:35;1590:14:0;;;;;;;;1991:4470:35;1590:14:0;;2107:15:35;1590:14:0;;2107:15:35;;;;;;:::i;:::-;1590:14:0;;-1:-1:-1;;;;;1590:14:0;;;;;2440:82:35;1590:14:0;;:::i;:::-;;;;;;;;;;;;;;;;;;;1991:4470:35;;1590:14:0;;;;;;:::i;:::-;2440:82:35;1590:14:0;1991:4470:35;1590:14:0;;;;-1:-1:-1;1590:14:0;;;;;;;;;;2440:82:35;1991:4470;1590:14:0;;1991:4470:35;1590:14:0;;1991:4470:35;1590:14:0;;;;;;;;;;;;;;-1:-1:-1;;;1590:14:0;;;2440:82:35;1590:14:0;1991:4470:35;1590:14:0;;;;;;;;;;1991:4470:35;1590:14:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2440:82:35;1991:4470;1590:14:0;;;-1:-1:-1;;;;;;;;;;;1590:14:0;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;1590:14:0;;;;;;;;1991:4470:35;1590:14:0;;1991:4470:35;1590:14:0;;1991:4470:35;1590:14:0;2476:16:35;;;;;;;1991:4470;2476:16;;;;;;:::i;:::-;;;;;:::i;:::-;;;;;1590:14:0;;;;2319:44:35;1991:4470;1590:14:0;;;1991:4470:35;1590:14:0;1991:4470:35;1590:14:0;;;;;;;-1:-1:-1;1590:14:0;;;;;;;-1:-1:-1;1590:14:0;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;1590:14:0;;;-1:-1:-1;1590:14:0;;;;;;;;;-1:-1:-1;1590:14:0;;;;;;;;;2319:44:35;1991:4470;1590:14:0;;1991:4470:35;1590:14:0;;1991:4470:35;1590:14:0;;;;;;;;;;;;;;;;;;;;2319:44:35;1590:14:0;;;;;;;;;;;;;1991:4470:35;1590:14:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2319:44:35;1991:4470;1590:14:0;;;-1:-1:-1;;;;;;;;;;;1590:14:0;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;2329:34:35;;;;;;1991:4470;2329:34;;;;;;:::i;:::-;;;;1590:14:0;1991:4470:35;1590:14:0;;;;;-1:-1:-1;;;;;1590:14:0;;;;;;;:::o;:::-;1991:4470:35;1590:14:0;;;;;-1:-1:-1;;;;;1590:14:0;;;;;;;:::o;:::-;;;;;-1:-1:-1;;1590:14:0;;;;-1:-1:-1;;;;;1590:14:0;;;;;;;;;;:::o;:::-;-1:-1:-1;;;;;1590:14:0;;;;;;-1:-1:-1;;1590:14:0;;;;:::o;:::-;;;;;;;:::i;:::-;1991:4470:35;1590:14:0;1991:4470:35;;1590:14:0;;;:::i;:::-;;;;;;;;;;;;;;;;;-1:-1:-1;1590:14:0;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;:::i;:::-;;:::o;:::-;;;;;;;;;;;-1:-1:-1;;;;;1590:14:0;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;1590:14:0;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;1991:4470:35;1590:14:0;;;;:::o;:::-;;;;;;-1:-1:-1;;;;;1590:14:0;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;-1:-1:-1;1590:14:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;1991:4470:35;1590:14:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1590:14:0;;-1:-1:-1;1590:14:0;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;1991:4470:35;;;;-1:-1:-1;1991:4470:35;5102:19;1991:4470;;;;;:::i;:::-;1590:14:0;;;;1991:4470:35;;;;;;;;1590:14:0;1991:4470:35;1590:14:0;;;1991:4470:35;;;;;;;:::i;:::-;:::o;:::-;-1:-1:-1;5102:19:35;-1:-1:-1;1590:14:0;;;;;-1:-1:-1;;;;;;;;;;;1991:4470:35;;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;1590:14:0;;;1991:4470:35;1590:14:0;;;;;1991:4470:35;1590:14:0;;;1991:4470:35;;;;;;;;;;;;;;-1:-1:-1;1991:4470:35;5477:7;1991:4470;;;;;:::i;:::-;1590:14:0;;;;1991:4470:35;;;;;;;;1590:14:0;1991:4470:35;1590:14:0;;;1991:4470:35;;;;;;:::i;:::-;-1:-1:-1;5477:7:35;-1:-1:-1;1590:14:0;;;;;-1:-1:-1;;;;;;;;;;;1991:4470:35;;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1991:4470:35;;;;;;:::i;:::-;1590:14:0;;;;1991:4470:35;;;;;;;;1590:14:0;1991:4470:35;1590:14:0;;;1991:4470:35;;;;;;;;:::i;:::-;1590:14:0;;-1:-1:-1;1590:14:0;;;;;-1:-1:-1;1590:14:0;1991:4470:35;-1:-1:-1;1991:4470:35;;;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;1590:14:0;;;;;1991:4470:35;1590:14:0;;;;;1991:4470:35;1590:14:0;;;1991:4470:35;;;;;;;;;;;;1590:14:0;1991:4470:35;1590:14:0;;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1590:14:0;1991:4470:35;;;:::o;:::-;1590:14:0;;;;;;;1991:4470:35;1590:14:0;;1991:4470:35;;1590:14:0;;;;-1:-1:-1;1590:14:0;;;;;;;;-1:-1:-1;;1590:14:0;1991:4470:35;;;:::o;:::-;;;;;;;;;;;;-1:-1:-1;;;1991:4470:35;;;;1590:14:0;;2107:15:35;;;;1991:4470;;;1590:14:0;;;-1:-1:-1;;;1590:14:0;;;1991:4470:35;;;1590:14:0;;1991:4470:35;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;1991:4470:35;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;:::i;:::-;;;;;;;;;;-1:-1:-1;;;;;1991:4470:35;;;;;;;:::o;2535:494::-;1991:4470;;-1:-1:-1;;;2675:16:35;;1991:4470;2675:16;1991:4470;2675:16;1991:4470;-1:-1:-1;;;;;;;;;;;2675:16:35;;;;;;;1991:4470;;;2675:16;1991:4470;2675:16;;;;;2535:494;1991:4470;;;;1590:14:0;;;;;2107:15:35;;;;1991:4470;;;1590:14:0;;;-1:-1:-1;;;1590:14:0;;;;;;2107:15:35;;;;;1991:4470;;;1590:14:0;;;-1:-1:-1;;;1590:14:0;;;;1991:4470:35;;1590:14:0;;1991:4470:35;;;;;;;:::i;:::-;;2675:16;1590:14:0;1991:4470:35;;;;7409:53:10;1991:4470:35;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;7409:53:10;1991:4470:35;;7409:53:10;;;;;;1991:4470:35;7409:53:10;;;;;;;:::i;:::-;762:159;1590:14:0;;762:159:10;;131:42;762:159;;;1991:4470:35;;1590:14:0;;;;;;;2794:17:35;;1991:4470;2675:16;2794:17;;1991:4470;7409:53:10;1991:4470:35;;;;:::i;:::-;2794:17;;-1:-1:-1;;;;;;;;;;;2794:17:35;;;;;;;2841:53;2794:17;2675:16;2794:17;;;;;2535:494;2860:33;;;;:::i;:::-;1991:4470;;-1:-1:-1;;;2841:53:35;;1991:4470;;;;;;2675:16;2841:53;;;:::i;:::-;;;-1:-1:-1;;;;;;;;;;;2841:53:35;;;;;;;762:159:10;2841:53:35;1991:4470;2841:53;;1991:4470;;2841:53;35698:76:10;2841:53:35;;;;;2535:494;-1:-1:-1;1590:14:0;;-1:-1:-1;;;;;1991:4470:35;2916:27;;;;1991:4470;2916:27;;;;;;:::i;:::-;1991:4470;1590:14:0;1991:4470:35;;1590:14:0;;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;;35698:76:10;;;;;;1991:4470:35;35698:76:10;;;1991:4470:35;7409:53:10;35698:76;;1991:4470:35;;;;;;:::i;:::-;;;;-1:-1:-1;;1991:4470:35;;;;;;;:::i;:::-;;;;-1:-1:-1;;1991:4470:35;;;;;;;:::i;:::-;;;;;2234:42;35698:76:10;1590:14:0;;35698:76:10;;;;;;:::i;:::-;762:159;1590:14:0;;762:159:10;;131:42;762:159;;;2535:494:35;:::o;2841:53::-;;;;;;;;;;;;;:::i;:::-;;;;;:::i;:::-;;;;;1991:4470;;1590:14:0;2675:16:35;1590:14:0;;;;;2794:17:35;;;;;;;;;;;;;:::i;:::-;;;;2675:16;;;;;;;;;;;;;:::i;:::-;;;;1991:4470;1590:14:0;1991:4470:35;1590:14:0;;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;:::o;:::-;-1:-1:-1;;;;;1991:4470:35;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;:::i;:::-;;1590:14:0;1991:4470:35;;1590:14:0;;;:::i;:::-;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;-1:-1:-1;;;;;;1991:4470:35;;;;;;;;;;;;;;;;;1590:14:0;;1991:4470:35;;;;;;:::o;:::-;1590:14:0;;;1991:4470:35;;;;;;;;;1590:14:0;;1991:4470:35;;;;;;;;:::o;:::-;1590:14:0;;1991:4470:35;;;;;;;;;;;;:::o;6114:121:10:-;762:159;1991:4470:35;6185:42:10;6114:121;;1991:4470:35;;6185:42:10;;;;;;;;;;;;;;1991:4470:35;;;;;;:::i;6185:42:10:-;762:159;1590:14:0;;762:159:10;;131:42;762:159;;;6114:121::o;1444:1021:36:-;1991:4470:35;;-1:-1:-1;;;1513:15:36;;1991:4470:35;1513:15:36;;;1991:4470:35;;;;;;;;;;;:::i;:::-;1513:15:36;;-1:-1:-1;;;;;;;;;;;;1513:15:36;;;;;;;-1:-1:-1;1513:15:36;;;1444:1021;1512:16;;1508:53;;1991:4470:35;-1:-1:-1;1991:4470:35;;;;1590:14:0;;;;;;;1592:17:36;;1991:4470:35;1513:15:36;1592:17;;1991:4470:35;;;;;;:::i;:::-;1592:17:36;;-1:-1:-1;;;;;;;;;;;1592:17:36;;;;;;;-1:-1:-1;1592:17:36;;;1444:1021;1991:4470:35;;;1590:14:0;;;1642:26:36;;1991:4470:35;1513:15:36;1642:26;;1991:4470:35;-1:-1:-1;1991:4470:35;;;;;;;;:::i;:::-;;;;;;;;;;;;;;1590:14:0;1642:26:36;;-1:-1:-1;;;;;;;;;;;1642:26:36;;;;;;;-1:-1:-1;1642:26:36;;;1444:1021;-1:-1:-1;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;1679:10:36;1991:4470:35;;1679:10:36;1991:4470:35;;;;;;1444:1021:36;-1:-1:-1;1679:10:36;-1:-1:-1;1590:14:0;;;-1:-1:-1;;;;;;;;;;;1991:4470:35;;;;;;;;;1725:13:36;;;;-1:-1:-1;1757:3:36;1590:14:0;;1740:15:36;;;;;1796:7;;1908:52;1796:7;;;:::i;:::-;;1991:4470:35;;1590:14:0;;;;:::i;:::-;-1:-1:-1;1991:4470:35;;;;;-1:-1:-1;1991:4470:35;;;;;-1:-1:-1;1991:4470:35;;;;;;-1:-1:-1;1991:4470:35;;-1:-1:-1;1927:32:36;;;:::i;:::-;1991:4470:35;;-1:-1:-1;;;1908:52:36;;1991:4470:35;;;;;1590:14:0;1991:4470:35;1513:15:36;1908:52;;;:::i;:::-;;;-1:-1:-1;;;;;;;;;;;1908:52:36;;;;;;2025:56;1908:52;-1:-1:-1;1908:52:36;;;1757:3;-1:-1:-1;1590:14:0;;-1:-1:-1;;;;;1991:4470:35;1897:75:36;;;;1991:4470:35;1897:75:36;;;;;;:::i;:::-;1991:4470:35;;;;;-1:-1:-1;;;1991:4470:35;;;;-1:-1:-1;1590:14:0;;2107:15:35;1991:4470;;;2107:15;1991:4470;2107:15;;1991:4470;;;;;;1590:14:0;;;-1:-1:-1;;;1590:14:0;;;1991:4470:35;;;;;;;;;;;;:::i;:::-;;;-1:-1:-1;;;2025:56:36;;1991:4470:35;;;;;1590:14:0;1991:4470:35;1513:15:36;2025:56;;;:::i;:::-;;;-1:-1:-1;;;;;;;;;;;2025:56:36;;;;;;;-1:-1:-1;2025:56:36;;;1757:3;1590:14:0;1991:4470:35;1590:14:0;;2014:79:36;;;;;;;;;;1991:4470:35;;;;2165:59:36;1991:4470:35;;;;-1:-1:-1;1991:4470:35;;-1:-1:-1;;;1991:4470:35;;;;;;;1590:14:0;;;1991:4470:35;;;;;1590:14:0;;;-1:-1:-1;;;1590:14:0;;;1991:4470:35;;;;;;;;;;;;:::i;2165:59:36:-;;;-1:-1:-1;;;;;;;;;;;2165:59:36;;;;;;;-1:-1:-1;2165:59:36;;;1757:3;1590:14:0;1991:4470:35;1590:14:0;;;2154:82:36;;1991:4470:35;;;;;2313:64:36;2154:82;;1991:4470:35;;;-1:-1:-1;1991:4470:35;;-1:-1:-1;;;1991:4470:35;;;;;;;1590:14:0;;;1991:4470:35;;;;;1590:14:0;;;-1:-1:-1;;;1590:14:0;;;1991:4470:35;;;;;;;;;;;;:::i;2313:64:36:-;;;-1:-1:-1;;;;;;;;;;;2313:64:36;;;;;;;-1:-1:-1;2313:64:36;;;1757:3;1590:14:0;1991:4470:35;1590:14:0;;2302:87:36;;;;;;;;;;1991:4470:35;;;;;;;;;;;;;;1590:14:0;;;;;;;;;;2404:20:36;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1725:13:36;;2313:64;;;;;;;-1:-1:-1;2313:64:36;;;;;;:::i;:::-;;;;;2165:59;;;;;;;-1:-1:-1;2165:59:36;;;;;;:::i;:::-;;;;;2025:56;;;;;;;-1:-1:-1;2025:56:36;;;;;;:::i;:::-;;;;;1908:52;;;;;;-1:-1:-1;1908:52:36;;;;;;:::i;:::-;;;;1740:15;;;;;1444:1021::o;1991:4470:35:-;;;1590:14:0;;;;;;;:::i;:::-;1991:4470:35;;;;;;;;;;1679:10:36;-1:-1:-1;1590:14:0;-1:-1:-1;;;;;;;;;;;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;-1:-1:-1;1991:4470:35;;;;;;;;1590:14:0;;-1:-1:-1;1590:14:0;;1991:4470:35;;-1:-1:-1;1590:14:0;;;;;1991:4470:35;;;;;:::i;:::-;1590:14:0;-1:-1:-1;1590:14:0;-1:-1:-1;1991:4470:35;1590:14:0;;1991:4470:35;;;;;;1642:26:36;;;;;-1:-1:-1;1642:26:36;;;;;;:::i;:::-;;;1991:4470:35;;;;;;;;;;;-1:-1:-1;;;;;1991:4470:35;;;;;;;;;;;;;;;;;;;:::i;:::-;;1590:14:0;1991:4470:35;;1590:14:0;;;:::i;:::-;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1642:26:36;;;;;;;;1991:4470:35;;;-1:-1:-1;;;;;1991:4470:35;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;1592:17:36;;;;;;;-1:-1:-1;1592:17:36;;;;;;:::i;:::-;;;;;1508:53;1544:7;:::o;1513:15::-;;;1991:4470:35;1513:15:36;;1991:4470:35;1513:15:36;;;;;;1991:4470:35;1513:15:36;;;:::i;:::-;;;1991:4470:35;;;;;;;;;;;;1513:15:36;;;;;;-1:-1:-1;1513:15:36;;1991:4470:35;-1:-1:-1;;1991:4470:35;;;;;;;:::o;:::-;7468:10:36;1991:4470:35;;;;;;7468:10:36;-1:-1:-1;1590:14:0;;-1:-1:-1;1590:14:0;1991:4470:35;;-1:-1:-1;1991:4470:35;:::o;:::-;1590:14:0;1991:4470:35;1590:14:0;;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;:::o;2471:1376:36:-;;1991:4470:35;1590:14:0;;1991:4470:35;;;1590:14:0;;;;;:::i;:::-;1991:4470:35;1590:14:0;;1991:4470:35;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;2613:13:36;1991:4470:35;1590:14:0;;;2665:3:36;2632:10;1991:4470:35;2628:35:36;;;;;2705:27;1991:4470:35;2705:27:36;;;:::i;1991:4470:35:-;;;1590:14:0;;;;2107:15:35;;;;1590:14:0;;;;2789:20:36;1991:4470:35;;;;;;;;1590:14:0;;;;:::i;:::-;1991:4470:35;;-1:-1:-1;;;;;1991:4470:35;;;1590:14:0;1991:4470:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;2854:34:36;;1991:4470:35;;;;;;2854:34:36;;;;;:::i;:::-;;;-1:-1:-1;;;;;;;;;;;2854:34:36;;;;;;;;2906:22;2854:34;1991:4470:35;2854:34:36;;4514:40:4;2854:34:36;;;;;2665:3;1991:4470:35;-1:-1:-1;;;1991:4470:35;1590:14:0;1991:4470:35;;1590:14:0;;;:::i;:::-;1991:4470:35;1590:14:0;;1991:4470:35;;;2906:22:36;:::i;:::-;2902:253;;2665:3;1991:4470:35;;;-1:-1:-1;;;;;1991:4470:35;;;;1590:14:0;1991:4470:35;;1590:14:0;:::i;:::-;2854:34:36;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;;;1590:14:0;;;;;;;;4514:40:4;;;2854:34:36;4514:40:4;;;:::i;:::-;;;;-1:-1:-1;;;;;;;;;;;4514:40:4;;;;;;;3228:53:36;4514:40:4;;;;2665:3:36;1991:4470:35;;;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;3228:53:36;;:::i;:::-;;1991:4470:35;;;;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;1991:4470:35;;;;;;-1:-1:-1;;;3756:37:4;;1991:4470:35;2854:34:36;3756:37:4;;1991:4470:35;;;;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;1991:4470:35;;;;;;;:::i;:::-;;;;;;3756:37:4;;;-1:-1:-1;;;;;;;;;;;3756:37:4;;;;;;3499:51:36;3756:37:4;1991:4470:35;3756:37:4;;3408:69:36;3756:37:4;;;2665:3:36;1991:4470:35;;;;:::i;:::-;3408:69:36;;:::i;:::-;3499:51;;;:::i;:::-;2665:3;1991:4470:35;2613:13:36;;;3756:37:4;;;;;1991:4470:35;3756:37:4;;;;;;:::i;:::-;;;;1991:4470:35;;1590:14:0;1991:4470:35;1590:14:0;;;;;4514:40:4;;;;;1991:4470:35;4514:40:4;;;;;;:::i;:::-;;;;1991:4470:35;;1590:14:0;1991:4470:35;1590:14:0;;;;;2902:253:36;1991:4470:35;;;;;;;;;2902:253:36;;2854:34;-1:-1:-1;;;2854:34:36;;;;;;;;;;;;;;:::i;:::-;;;;;;1991:4470:35;;1590:14:0;1991:4470:35;1590:14:0;;;;;2628:35:36;;;;;;;;3575:14;1991:4470:35;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;3575::36;;:::i;:::-;3571:51;;-1:-1:-1;;;;;;;;;;;6035:27:4;;;;1991:4470:35;;-1:-1:-1;;;6035:27:4;;1991:4470:35;;;;;;;6035:27:4;;1991:4470:35;2854:34:36;6035:27:4;;;:::i;:::-;;;;-1:-1:-1;;;;;;;;;;;6035:27:4;;;;;;;3790:50:36;6035:27:4;;;;2608:953:36;1991:4470:35;1590:14:0;1991:4470:35;;1590:14:0;;;:::i;:::-;;;3805:34:36;1991:4470:35;;;:::i;:::-;3805:34:36;;:::i;:::-;3790:50;;;:::i;6035:27:4:-;;;;;1991:4470:35;6035:27:4;;:::i;:::-;1991:4470:35;;1590:14:0;6035:27:4;;;1991:4470:35;;1590:14:0;1991:4470:35;1590:14:0;;;;;3571:51:36;3605:7;;;;;;:::o;3813:182:29:-;;1590:14:0;;;;3908:34:29;;;;:80;;;;3813:182;3901:87;;;;3813:182;:::o;3908:80::-;1991:4470:35;;;;;;;3946:19:29;1991:4470:35;;3969:19:29;3946:42;3908:80;;;;;;661:63:4;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;1991:4470:35;;;661:63:4;;2234:42:35;661:63:4:o;4775:173::-;1991:4470:35;;-1:-1:-1;;;4901:40:4;;1991:4470:35;4901:40:4;;;1991:4470:35;;-1:-1:-1;;1991:4470:35;;;;4775:173:4;1991:4470:35;;;;;;;;;:::i;:::-;;;;;;4901:40:4;;;-1:-1:-1;;;;;;;;;;;4901:40:4;;;;;;;-1:-1:-1;4901:40:4;;;4894:47;4775:173;:::o;4901:40::-;;;;;;-1:-1:-1;4901:40:4;;;;;;:::i;5548:198::-;1991:4470:35;5548:198:4;1991:4470:35;-1:-1:-1;5548:198:4;;1991:4470:35;;;1590:14:0;;;;;;;;5700:39:4;;1991:4470:35;5700:39:4;;;1991:4470:35;;;;;;:::i;:::-;;;;-1:-1:-1;;1991:4470:35;;;;;;;:::i;:::-;;;;-1:-1:-1;;1991:4470:35;;;;;;;:::i;:::-;5700:39:4;;;-1:-1:-1;;;;;;;;;;;5700:39:4;;;;;;;-1:-1:-1;5700:39:4;;;5693:46;5548:198;:::o;4641:1753:36:-;;;;1991:4470:35;;1590:14:0;;2107:15:35;;;;;;1590:14:0;;;;;;;4949:20:36;1991:4470:35;;;;;;;;;1590:14:0;;;;:::i;:::-;;1991:4470:35;;;;;;;;;2107:15;1991:4470;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1590:14:0;;;;;2107:15:35;;;;1991:4470;;;1590:14:0;;;-1:-1:-1;;;1590:14:0;;;1991:4470:35;;;;;;;;;;;;:::i;:::-;;;-1:-1:-1;;;5109:20:36;;2107:15:35;1991:4470;5109:20:36;;1991:4470:35;;-1:-1:-1;1991:4470:35;;;;;;;;:::i;:::-;5109:20:36;;-1:-1:-1;;;;;;;;;;;5109:20:36;;;;;;;1991:4470:35;5109:20:36;;;4641:1753;1991:4470:35;;2107:15;1991:4470;5092:44:36;1991:4470:35;;;;;5092:44:36;;;;;;;1590:14:0;;;2107:15:35;;;;1590:14:0;;;;;;;;;;;;;2107:15:35;;;;1590:14:0;;;;;;;5092:44:36;1590:14:0;;5092:44:36;;;;;;:::i;:::-;1991:4470:35;;1590:14:0;;;;;;;5166:28:36;;2107:15:35;1991:4470;5166:28:36;;1991:4470:35;;;;;;:::i;:::-;5166:28:36;;-1:-1:-1;;;;;;;;;;;5166:28:36;;;;;;;1991:4470:35;5166:28:36;;;4641:1753;-1:-1:-1;1590:14:0;;2107:15:35;1991:4470;;;5224:15:36;1590:14:0;;5276:23:36;;1991:4470:35;;-1:-1:-1;;;;;1991:4470:35;5323:35:36;;;5224:15;;1991:4470:35;;5323:76:36;;;;4641:1753;5323:145;;;;;4641:1753;5323:201;;;;;4641:1753;5539:6;;5535:196;;5764:112;;;1991:4470:35;5764:112:36;1991:4470:35;-1:-1:-1;;;;;1991:4470:35;;;5894:18:36;;1991:4470:35;;1590:14:0;;1991:4470:35;1590:14:0;1991:4470:35;;5953:50:36;1991:4470:35;;;;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;2107:15:35;1991:4470;;;5953:50:36;:::i;:::-;1991:4470:35;;1590:14:0;;;;:::i;:::-;1991:4470:35;;2107:15;6033:171:36;;1991:4470:35;;;2107:15;6033:171:36;;;6133:12;;1991:4470:35;;;6033:171:36;;1991:4470:35;;;;1590:14:0;;;;;;;;4949:20:36;1590:14:0;;;1991:4470:35;;;;;;;;;;;-1:-1:-1;;;;;;1991:4470:35;-1:-1:-1;;;;;1991:4470:35;;;;;;;;1590:14:0;1991:4470:35;;;;;;;;;;;;6278:79:36;;6367:20;;4641:1753;:::o;6278:79::-;4949:10;1991:4470:35;-1:-1:-1;;;1991:4470:35;;;;;;;;;;4949:10:36;1991:4470:35;;:::i;:::-;;;;;;;;;:::i;:::-;6367:20:36;4641:1753;:::o;1991:4470:35:-;1590:14:0;;;1991:4470:35;1590:14:0;1991:4470:35;;1590:14:0;1991:4470:35;;1590:14:0;1991:4470:35;;;-1:-1:-1;;;1991:4470:35;;2107:15;1991:4470;;;;;;;;1590:14:0;-1:-1:-1;;;1590:14:0;;;1991:4470:35;;;;5535:196:36;1590:14:0;;;;;;;5619:59:36;1590:14:0;;1991:4470:35;1590:14:0;;;;:::i;:::-;1991:4470:35;1590:14:0;;-1:-1:-1;;;2107:15:35;1991:4470;;;5619:59:36;:::i;5323:201::-;8387:58;;5472:52;;-1:-1:-1;5323:201:36;;:145;1991:4470:35;5415:53:36;;;;-1:-1:-1;5323:145:36;;;:76;1991:4470:35;5362:37:36;;;;-1:-1:-1;5323:76:36;;;5166:28;;;;;;1991:4470:35;5166:28:36;;;;;;:::i;:::-;;;;5109:20;1991:4470:35;5109:20:36;;;2107:15:35;5109:20:36;5092:44;5109:20;1991:4470:35;5109:20:36;;;;;;;;;;:::i;:::-;;;;;;;;;12672:174:10;;12773:65;762:159;12672:174;;12773:65;12672:174;;1991:4470:35;;12773:65:10;;;;;;;;;;;;;;:::i","linkReferences":{}},"methodIdentifiers":{"IS_SCRIPT()":"f8ccbf47","run()":"c0406226","setUp()":"0a9254e4"}}}}},"sources":{"lib/forge-std/src/Base.sol":{"id":0,"ast":{}},"lib/forge-std/src/Script.sol":{"id":1,"ast":{}},"lib/forge-std/src/StdChains.sol":{"id":2,"ast":{}},"lib/forge-std/src/StdCheats.sol":{"id":3,"ast":{}},"lib/forge-std/src/StdJson.sol":{"id":4,"ast":{}},"lib/forge-std/src/StdMath.sol":{"id":5,"ast":{}},"lib/forge-std/src/StdStorage.sol":{"id":6,"ast":{}},"lib/forge-std/src/StdStyle.sol":{"id":7,"ast":{}},"lib/forge-std/src/StdUtils.sol":{"id":8,"ast":{}},"lib/forge-std/src/Vm.sol":{"id":9,"ast":{}},"lib/forge-std/src/console.sol":{"id":10,"ast":{}},"lib/forge-std/src/console2.sol":{"id":11,"ast":{}},"lib/forge-std/src/interfaces/IERC165.sol":{"id":12,"ast":{}},"lib/forge-std/src/interfaces/IERC20.sol":{"id":13,"ast":{}},"lib/forge-std/src/interfaces/IERC721.sol":{"id":14,"ast":{}},"lib/forge-std/src/interfaces/IMulticall3.sol":{"id":15,"ast":{}},"lib/forge-std/src/mocks/MockERC20.sol":{"id":16,"ast":{}},"lib/forge-std/src/mocks/MockERC721.sol":{"id":17,"ast":{}},"lib/forge-std/src/safeconsole.sol":{"id":18,"ast":{}},"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol":{"id":21,"ast":{}},"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol":{"id":22,"ast":{}},"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol":{"id":23,"ast":{}},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"id":24,"ast":{}},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"id":25,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"id":26,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/Errors.sol":{"id":27,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"id":28,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/Strings.sol":{"id":29,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"id":30,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"id":31,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"id":32,"ast":{}},"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol":{"id":33,"ast":{}},"lib/openzeppelin-contracts/contracts//utils/structs/EnumerableSet.sol":{"id":34,"ast":{}},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"id":19,"ast":{}},"script/UpdateDiamondViewsMultisig.sol":{"id":35,"ast":{"absolutePath":"script/UpdateDiamondViewsMultisig.sol","id":41391,"exportedSymbols":{"Deployment":[42187],"ICapacityConst":[47081],"IDiamondCut":[49408],"IDiamondLoupe":[49450],"IViewer":[49575],"Script":[113],"SelectorsHelper":[44186],"UpdateDiamondViewsMultisig":[41390],"console2":[20622]},"nodeType":"SourceUnit","src":"1538:4924:35","nodes":[{"id":40966,"nodeType":"PragmaDirective","src":"1538:24:35","nodes":[],"literals":["solidity","^","0.8",".19"]},{"id":40969,"nodeType":"ImportDirective","src":"1564:54:35","nodes":[],"absolutePath":"lib/forge-std/src/Script.sol","file":"forge-std/Script.sol","nameLocation":"-1:-1:-1","scope":41391,"sourceUnit":114,"symbolAliases":[{"foreign":{"id":40967,"name":"Script","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":113,"src":"1572:6:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":40968,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"1580:8:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":40971,"nodeType":"ImportDirective","src":"1620:55:35","nodes":[],"absolutePath":"script/utils/Deployment.sol","file":"script/utils/Deployment.sol","nameLocation":"-1:-1:-1","scope":41391,"sourceUnit":42188,"symbolAliases":[{"foreign":{"id":40970,"name":"Deployment","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":42187,"src":"1628:10:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":40973,"nodeType":"ImportDirective","src":"1676:65:35","nodes":[],"absolutePath":"script/utils/SelectorsHelper.sol","file":"script/utils/SelectorsHelper.sol","nameLocation":"-1:-1:-1","scope":41391,"sourceUnit":44187,"symbolAliases":[{"foreign":{"id":40972,"name":"SelectorsHelper","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":44186,"src":"1684:15:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":40975,"nodeType":"ImportDirective","src":"1742:59:35","nodes":[],"absolutePath":"src/interfaces/IDiamondCut.sol","file":"src/interfaces/IDiamondCut.sol","nameLocation":"-1:-1:-1","scope":41391,"sourceUnit":49409,"symbolAliases":[{"foreign":{"id":40974,"name":"IDiamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49408,"src":"1750:11:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":40977,"nodeType":"ImportDirective","src":"1802:63:35","nodes":[],"absolutePath":"src/interfaces/IDiamondLoupe.sol","file":"src/interfaces/IDiamondLoupe.sol","nameLocation":"-1:-1:-1","scope":41391,"sourceUnit":49451,"symbolAliases":[{"foreign":{"id":40976,"name":"IDiamondLoupe","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49450,"src":"1810:13:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":40979,"nodeType":"ImportDirective","src":"1866:70:35","nodes":[],"absolutePath":"src/core/interfaces/ICapacityConst.sol","file":"src/core/interfaces/ICapacityConst.sol","nameLocation":"-1:-1:-1","scope":41391,"sourceUnit":47082,"symbolAliases":[{"foreign":{"id":40978,"name":"ICapacityConst","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47081,"src":"1874:14:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":40981,"nodeType":"ImportDirective","src":"1937:51:35","nodes":[],"absolutePath":"src/interfaces/IViewer.sol","file":"src/interfaces/IViewer.sol","nameLocation":"-1:-1:-1","scope":41391,"sourceUnit":49576,"symbolAliases":[{"foreign":{"id":40980,"name":"IViewer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49575,"src":"1945:7:35","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":41390,"nodeType":"ContractDefinition","src":"1991:4470:35","nodes":[{"id":40990,"nodeType":"VariableDeclaration","src":"2072:50:35","nodes":[],"constant":true,"mutability":"constant","name":"DEPLOYMENTS_PATH","nameLocation":"2088:16:35","scope":41390,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string"},"typeName":{"id":40988,"name":"string","nodeType":"ElementaryTypeName","src":"2072:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"value":{"hexValue":"2f6465706c6f796d656e74732f","id":40989,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2107:15:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_9b849f40317fba7d532c0bb5a0048fc588a330868a6212ac1ddf9bd048284b1c","typeString":"literal_string \"/deployments/\""},"value":"/deployments/"},"visibility":"internal"},{"id":40992,"nodeType":"VariableDeclaration","src":"2128:34:35","nodes":[],"constant":false,"mutability":"mutable","name":"fullDeploymentsPath","nameLocation":"2143:19:35","scope":41390,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string"},"typeName":{"id":40991,"name":"string","nodeType":"ElementaryTypeName","src":"2128:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"private"},{"id":40994,"nodeType":"VariableDeclaration","src":"2168:14:35","nodes":[],"constant":false,"mutability":"mutable","name":"envName","nameLocation":"2175:7:35","scope":41390,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string"},"typeName":{"id":40993,"name":"string","nodeType":"ElementaryTypeName","src":"2168:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"},{"id":40997,"nodeType":"VariableDeclaration","src":"2189:87:35","nodes":[],"constant":true,"mutability":"constant","name":"REAL_MULTISIG_ON_ALL_ENVS","nameLocation":"2206:25:35","scope":41390,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":40995,"name":"address","nodeType":"ElementaryTypeName","src":"2189:7:35","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":{"hexValue":"307845616639313335443131336237323032353964393233633034346436323165363034453142353333","id":40996,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2234:42:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"value":"0xEaf9135D113b720259d923c044d621e604E1B533"},"visibility":"internal"},{"id":41029,"nodeType":"FunctionDefinition","src":"2283:246:35","nodes":[],"body":{"id":41028,"nodeType":"Block","src":"2309:220:35","nodes":[],"statements":[{"expression":{"id":41005,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":41000,"name":"envName","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40994,"src":"2319:7:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"hexValue":"434f4e5452414354535f454e565f4e414d45","id":41003,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2342:20:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_4c0179ac94b699058724575bb5a668116dbb88c03ed1d3ac079b101fc50bf284","typeString":"literal_string \"CONTRACTS_ENV_NAME\""},"value":"CONTRACTS_ENV_NAME"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_4c0179ac94b699058724575bb5a668116dbb88c03ed1d3ac079b101fc50bf284","typeString":"literal_string \"CONTRACTS_ENV_NAME\""}],"expression":{"id":41001,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"2329:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41002,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2332:9:35","memberName":"envString","nodeType":"MemberAccess","referencedDeclaration":8979,"src":"2329:12:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_string_memory_ptr_$returns$_t_string_memory_ptr_$","typeString":"function (string memory) view external returns (string memory)"}},"id":41004,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2329:34:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},"src":"2319:44:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},"id":41006,"nodeType":"ExpressionStatement","src":"2319:44:35"},{"assignments":[41008],"declarations":[{"constant":false,"id":41008,"mutability":"mutable","name":"fileNames","nameLocation":"2387:9:35","nodeType":"VariableDeclaration","scope":41028,"src":"2373:23:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string"},"typeName":{"id":41007,"name":"string","nodeType":"ElementaryTypeName","src":"2373:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"}],"id":41015,"initialValue":{"arguments":[{"id":41012,"name":"envName","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40994,"src":"2413:7:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},{"hexValue":"2e6a736f6e","id":41013,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2422:7:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_94311adc0a0cd4e10be11b23bd4316b8cffa4adf693e8f96f5c075aa439a7972","typeString":"literal_string \".json\""},"value":".json"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_storage","typeString":"string storage ref"},{"typeIdentifier":"t_stringliteral_94311adc0a0cd4e10be11b23bd4316b8cffa4adf693e8f96f5c075aa439a7972","typeString":"literal_string \".json\""}],"expression":{"id":41010,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2399:6:35","typeDescriptions":{"typeIdentifier":"t_type$_t_string_storage_ptr_$","typeString":"type(string storage pointer)"},"typeName":{"id":41009,"name":"string","nodeType":"ElementaryTypeName","src":"2399:6:35","typeDescriptions":{}}},"id":41011,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2406:6:35","memberName":"concat","nodeType":"MemberAccess","src":"2399:13:35","typeDescriptions":{"typeIdentifier":"t_function_stringconcat_pure$__$returns$_t_string_memory_ptr_$","typeString":"function () pure returns (string memory)"}},"id":41014,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2399:31:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},"nodeType":"VariableDeclarationStatement","src":"2373:57:35"},{"expression":{"id":41026,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":41016,"name":"fullDeploymentsPath","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40992,"src":"2440:19:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"arguments":[],"expression":{"argumentTypes":[],"expression":{"id":41020,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"2476:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41021,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2479:11:35","memberName":"projectRoot","nodeType":"MemberAccess","referencedDeclaration":9366,"src":"2476:14:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$__$returns$_t_string_memory_ptr_$","typeString":"function () view external returns (string memory)"}},"id":41022,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2476:16:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"id":41023,"name":"DEPLOYMENTS_PATH","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40990,"src":"2494:16:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"id":41024,"name":"fileNames","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41008,"src":"2512:9:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}],"expression":{"id":41018,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2462:6:35","typeDescriptions":{"typeIdentifier":"t_type$_t_string_storage_ptr_$","typeString":"type(string storage pointer)"},"typeName":{"id":41017,"name":"string","nodeType":"ElementaryTypeName","src":"2462:6:35","typeDescriptions":{}}},"id":41019,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2469:6:35","memberName":"concat","nodeType":"MemberAccess","src":"2462:13:35","typeDescriptions":{"typeIdentifier":"t_function_stringconcat_pure$__$returns$_t_string_memory_ptr_$","typeString":"function () pure returns (string memory)"}},"id":41025,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2462:60:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},"src":"2440:82:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},"id":41027,"nodeType":"ExpressionStatement","src":"2440:82:35"}]},"functionSelector":"0a9254e4","implemented":true,"kind":"function","modifiers":[],"name":"setUp","nameLocation":"2292:5:35","parameters":{"id":40998,"nodeType":"ParameterList","parameters":[],"src":"2297:2:35"},"returnParameters":{"id":40999,"nodeType":"ParameterList","parameters":[],"src":"2309:0:35"},"scope":41390,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":41101,"nodeType":"FunctionDefinition","src":"2535:494:35","nodes":[],"body":{"id":41100,"nodeType":"Block","src":"2630:399:35","nodes":[],"statements":[{"assignments":[41039],"declarations":[{"constant":false,"id":41039,"mutability":"mutable","name":"path","nameLocation":"2654:4:35","nodeType":"VariableDeclaration","scope":41100,"src":"2640:18:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string"},"typeName":{"id":41038,"name":"string","nodeType":"ElementaryTypeName","src":"2640:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"}],"id":41050,"initialValue":{"arguments":[{"arguments":[],"expression":{"argumentTypes":[],"expression":{"id":41043,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"2675:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41044,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2678:11:35","memberName":"projectRoot","nodeType":"MemberAccess","referencedDeclaration":9366,"src":"2675:14:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$__$returns$_t_string_memory_ptr_$","typeString":"function () view external returns (string memory)"}},"id":41045,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2675:16:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"hexValue":"2f6465706c6f796d656e74732f","id":41046,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2693:15:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_9b849f40317fba7d532c0bb5a0048fc588a330868a6212ac1ddf9bd048284b1c","typeString":"literal_string \"/deployments/\""},"value":"/deployments/"},{"id":41047,"name":"env","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41031,"src":"2710:3:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"hexValue":"2e6a736f6e","id":41048,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2715:7:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_94311adc0a0cd4e10be11b23bd4316b8cffa4adf693e8f96f5c075aa439a7972","typeString":"literal_string \".json\""},"value":".json"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_stringliteral_9b849f40317fba7d532c0bb5a0048fc588a330868a6212ac1ddf9bd048284b1c","typeString":"literal_string \"/deployments/\""},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_stringliteral_94311adc0a0cd4e10be11b23bd4316b8cffa4adf693e8f96f5c075aa439a7972","typeString":"literal_string \".json\""}],"expression":{"id":41041,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2661:6:35","typeDescriptions":{"typeIdentifier":"t_type$_t_string_storage_ptr_$","typeString":"type(string storage pointer)"},"typeName":{"id":41040,"name":"string","nodeType":"ElementaryTypeName","src":"2661:6:35","typeDescriptions":{}}},"id":41042,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2668:6:35","memberName":"concat","nodeType":"MemberAccess","src":"2661:13:35","typeDescriptions":{"typeIdentifier":"t_function_stringconcat_pure$__$returns$_t_string_memory_ptr_$","typeString":"function () pure returns (string memory)"}},"id":41049,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2661:62:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},"nodeType":"VariableDeclarationStatement","src":"2640:83:35"},{"expression":{"arguments":[{"hexValue":"706174683a202573","id":41054,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2746:10:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_995d00e46f7e4bb1f941f6c8473531b7b905de1a94fb3915f4d7f562b4dfc5e8","typeString":"literal_string \"path: %s\""},"value":"path: %s"},{"id":41055,"name":"path","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41039,"src":"2758:4:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_995d00e46f7e4bb1f941f6c8473531b7b905de1a94fb3915f4d7f562b4dfc5e8","typeString":"literal_string \"path: %s\""},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}],"expression":{"id":41051,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"2733:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41053,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2742:3:35","memberName":"log","nodeType":"MemberAccess","referencedDeclaration":13283,"src":"2733:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_string_memory_ptr_$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory,string memory) pure"}},"id":41056,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2733:30:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41057,"nodeType":"ExpressionStatement","src":"2733:30:35"},{"assignments":[41059],"declarations":[{"constant":false,"id":41059,"mutability":"mutable","name":"json","nameLocation":"2787:4:35","nodeType":"VariableDeclaration","scope":41100,"src":"2773:18:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string"},"typeName":{"id":41058,"name":"string","nodeType":"ElementaryTypeName","src":"2773:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"}],"id":41064,"initialValue":{"arguments":[{"id":41062,"name":"path","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41039,"src":"2806:4:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}],"expression":{"id":41060,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"2794:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41061,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2797:8:35","memberName":"readFile","nodeType":"MemberAccess","referencedDeclaration":9450,"src":"2794:11:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_string_memory_ptr_$returns$_t_string_memory_ptr_$","typeString":"function (string memory) view external returns (string memory)"}},"id":41063,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2794:17:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},"nodeType":"VariableDeclarationStatement","src":"2773:38:35"},{"assignments":[41066],"declarations":[{"constant":false,"id":41066,"mutability":"mutable","name":"data","nameLocation":"2834:4:35","nodeType":"VariableDeclaration","scope":41100,"src":"2821:17:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":41065,"name":"bytes","nodeType":"ElementaryTypeName","src":"2821:5:35","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"id":41078,"initialValue":{"arguments":[{"id":41069,"name":"json","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41059,"src":"2854:4:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"arguments":[{"hexValue":"2e","id":41073,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2874:3:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_6f010af653ebe3cb07d297a4ef13366103d392ceffa68dd48232e6e9ff2187bf","typeString":"literal_string \".\""},"value":"."},{"id":41074,"name":"name","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41033,"src":"2879:4:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"hexValue":"2e61646472","id":41075,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2885:7:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_4dad97bd55a21a6387cc63085364307d529b15f915236b36ffd14bb4cbfbb5d0","typeString":"literal_string \".addr\""},"value":".addr"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_6f010af653ebe3cb07d297a4ef13366103d392ceffa68dd48232e6e9ff2187bf","typeString":"literal_string \".\""},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_stringliteral_4dad97bd55a21a6387cc63085364307d529b15f915236b36ffd14bb4cbfbb5d0","typeString":"literal_string \".addr\""}],"expression":{"id":41071,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2860:6:35","typeDescriptions":{"typeIdentifier":"t_type$_t_string_storage_ptr_$","typeString":"type(string storage pointer)"},"typeName":{"id":41070,"name":"string","nodeType":"ElementaryTypeName","src":"2860:6:35","typeDescriptions":{}}},"id":41072,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2867:6:35","memberName":"concat","nodeType":"MemberAccess","src":"2860:13:35","typeDescriptions":{"typeIdentifier":"t_function_stringconcat_pure$__$returns$_t_string_memory_ptr_$","typeString":"function () pure returns (string memory)"}},"id":41076,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2860:33:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}],"expression":{"id":41067,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"2841:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41068,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2844:9:35","memberName":"parseJson","nodeType":"MemberAccess","referencedDeclaration":9758,"src":"2841:12:35","typeDescriptions":{"typeIdentifier":"t_function_external_pure$_t_string_memory_ptr_$_t_string_memory_ptr_$returns$_t_bytes_memory_ptr_$","typeString":"function (string memory,string memory) pure external returns (bytes memory)"}},"id":41077,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2841:53:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"nodeType":"VariableDeclarationStatement","src":"2821:73:35"},{"assignments":[41080],"declarations":[{"constant":false,"id":41080,"mutability":"mutable","name":"c","nameLocation":"2912:1:35","nodeType":"VariableDeclaration","scope":41100,"src":"2904:9:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":41079,"name":"address","nodeType":"ElementaryTypeName","src":"2904:7:35","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":41088,"initialValue":{"arguments":[{"id":41083,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41066,"src":"2927:4:35","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},{"components":[{"id":41085,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2934:7:35","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":41084,"name":"address","nodeType":"ElementaryTypeName","src":"2934:7:35","typeDescriptions":{}}}],"id":41086,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"TupleExpression","src":"2933:9:35","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"},{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"}],"expression":{"id":41081,"name":"abi","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-1,"src":"2916:3:35","typeDescriptions":{"typeIdentifier":"t_magic_abi","typeString":"abi"}},"id":41082,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"2920:6:35","memberName":"decode","nodeType":"MemberAccess","src":"2916:10:35","typeDescriptions":{"typeIdentifier":"t_function_abidecode_pure$__$returns$__$","typeString":"function () pure"}},"id":41087,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2916:27:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"nodeType":"VariableDeclarationStatement","src":"2904:39:35"},{"expression":{"arguments":[{"hexValue":"636f6e74726163742025734025732069733a202573","id":41092,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2966:23:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_b268d6b69f28c6c078b3fb7e8792840fef69a0595dee9fb83b43473f5ecf0bdb","typeString":"literal_string \"contract %s@%s is: %s\""},"value":"contract %s@%s is: %s"},{"id":41093,"name":"name","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41033,"src":"2991:4:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"id":41094,"name":"env","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41031,"src":"2997:3:35","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"}},{"id":41095,"name":"c","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41080,"src":"3002:1:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_b268d6b69f28c6c078b3fb7e8792840fef69a0595dee9fb83b43473f5ecf0bdb","typeString":"literal_string \"contract %s@%s is: %s\""},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_string_memory_ptr","typeString":"string memory"},{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":41089,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"2953:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41091,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2962:3:35","memberName":"log","nodeType":"MemberAccess","referencedDeclaration":16757,"src":"2953:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_string_memory_ptr_$_t_string_memory_ptr_$_t_string_memory_ptr_$_t_address_$returns$__$","typeString":"function (string memory,string memory,string memory,address) pure"}},"id":41096,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2953:51:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41097,"nodeType":"ExpressionStatement","src":"2953:51:35"},{"expression":{"id":41098,"name":"c","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41080,"src":"3021:1:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":41037,"id":41099,"nodeType":"Return","src":"3014:8:35"}]},"implemented":true,"kind":"function","modifiers":[],"name":"contractAddress","nameLocation":"2544:15:35","parameters":{"id":41034,"nodeType":"ParameterList","parameters":[{"constant":false,"id":41031,"mutability":"mutable","name":"env","nameLocation":"2574:3:35","nodeType":"VariableDeclaration","scope":41101,"src":"2560:17:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string"},"typeName":{"id":41030,"name":"string","nodeType":"ElementaryTypeName","src":"2560:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"},{"constant":false,"id":41033,"mutability":"mutable","name":"name","nameLocation":"2593:4:35","nodeType":"VariableDeclaration","scope":41101,"src":"2579:18:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_string_memory_ptr","typeString":"string"},"typeName":{"id":41032,"name":"string","nodeType":"ElementaryTypeName","src":"2579:6:35","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"visibility":"internal"}],"src":"2559:39:35"},"returnParameters":{"id":41037,"nodeType":"ParameterList","parameters":[{"constant":false,"id":41036,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":41101,"src":"2621:7:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":41035,"name":"address","nodeType":"ElementaryTypeName","src":"2621:7:35","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"2620:9:35"},"scope":41390,"stateMutability":"view","virtual":false,"visibility":"private"},{"id":41251,"nodeType":"FunctionDefinition","src":"3035:1994:35","nodes":[],"body":{"id":41250,"nodeType":"Block","src":"3092:1937:35","nodes":[],"statements":[{"assignments":[41107],"declarations":[{"constant":false,"id":41107,"mutability":"mutable","name":"diamond","nameLocation":"3110:7:35","nodeType":"VariableDeclaration","scope":41250,"src":"3102:15:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":41106,"name":"address","nodeType":"ElementaryTypeName","src":"3102:7:35","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":41112,"initialValue":{"arguments":[{"id":41109,"name":"envName","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40994,"src":"3136:7:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},{"hexValue":"4469616d6f6e64","id":41110,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"3145:9:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_aadb29765cb3e4f21bde5ecd65db8e565d901b6c9394dcec22aa81b8ff2d6e2f","typeString":"literal_string \"Diamond\""},"value":"Diamond"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_storage","typeString":"string storage ref"},{"typeIdentifier":"t_stringliteral_aadb29765cb3e4f21bde5ecd65db8e565d901b6c9394dcec22aa81b8ff2d6e2f","typeString":"literal_string \"Diamond\""}],"id":41108,"name":"contractAddress","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41101,"src":"3120:15:35","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_string_memory_ptr_$_t_string_memory_ptr_$returns$_t_address_$","typeString":"function (string memory,string memory) view returns (address)"}},"id":41111,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3120:35:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"3102:53:35"},{"assignments":[41114],"declarations":[{"constant":false,"id":41114,"mutability":"mutable","name":"viewerFacet","nameLocation":"3174:11:35","nodeType":"VariableDeclaration","scope":41250,"src":"3166:19:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":41113,"name":"address","nodeType":"ElementaryTypeName","src":"3166:7:35","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":41119,"initialValue":{"arguments":[{"id":41116,"name":"envName","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40994,"src":"3204:7:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},{"hexValue":"5669657765724661636574","id":41117,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"3213:13:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_17163bc14ca589f519e924ce03713060635e27e6e081498498ca9bab560316b9","typeString":"literal_string \"ViewerFacet\""},"value":"ViewerFacet"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_storage","typeString":"string storage ref"},{"typeIdentifier":"t_stringliteral_17163bc14ca589f519e924ce03713060635e27e6e081498498ca9bab560316b9","typeString":"literal_string \"ViewerFacet\""}],"id":41115,"name":"contractAddress","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41101,"src":"3188:15:35","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_string_memory_ptr_$_t_string_memory_ptr_$returns$_t_address_$","typeString":"function (string memory,string memory) view returns (address)"}},"id":41118,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3188:39:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"3166:61:35"},{"assignments":[41125],"declarations":[{"constant":false,"id":41125,"mutability":"mutable","name":"actualFacets","nameLocation":"3574:12:35","nodeType":"VariableDeclaration","scope":41250,"src":"3545:41:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_Facet_$49417_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondLoupe.Facet[]"},"typeName":{"baseType":{"id":41123,"nodeType":"UserDefinedTypeName","pathNode":{"id":41122,"name":"IDiamondLoupe.Facet","nameLocations":["3545:13:35","3559:5:35"],"nodeType":"IdentifierPath","referencedDeclaration":49417,"src":"3545:19:35"},"referencedDeclaration":49417,"src":"3545:19:35","typeDescriptions":{"typeIdentifier":"t_struct$_Facet_$49417_storage_ptr","typeString":"struct IDiamondLoupe.Facet"}},"id":41124,"nodeType":"ArrayTypeName","src":"3545:21:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_Facet_$49417_storage_$dyn_storage_ptr","typeString":"struct IDiamondLoupe.Facet[]"}},"visibility":"internal"}],"id":41131,"initialValue":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"arguments":[{"id":41127,"name":"diamond","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41107,"src":"3603:7:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":41126,"name":"IDiamondLoupe","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49450,"src":"3589:13:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IDiamondLoupe_$49450_$","typeString":"type(contract IDiamondLoupe)"}},"id":41128,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3589:22:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IDiamondLoupe_$49450","typeString":"contract IDiamondLoupe"}},"id":41129,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"3612:6:35","memberName":"facets","nodeType":"MemberAccess","referencedDeclaration":49425,"src":"3589:29:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$__$returns$_t_array$_t_struct$_Facet_$49417_memory_ptr_$dyn_memory_ptr_$","typeString":"function () view external returns (struct IDiamondLoupe.Facet memory[] memory)"}},"id":41130,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3589:31:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_Facet_$49417_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondLoupe.Facet memory[] memory"}},"nodeType":"VariableDeclarationStatement","src":"3545:75:35"},{"assignments":[41133],"declarations":[{"constant":false,"id":41133,"mutability":"mutable","name":"found","nameLocation":"3635:5:35","nodeType":"VariableDeclaration","scope":41250,"src":"3630:10:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":41132,"name":"bool","nodeType":"ElementaryTypeName","src":"3630:4:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"id":41135,"initialValue":{"hexValue":"66616c7365","id":41134,"isConstant":false,"isLValue":false,"isPure":true,"kind":"bool","lValueRequested":false,"nodeType":"Literal","src":"3643:5:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"value":"false"},"nodeType":"VariableDeclarationStatement","src":"3630:18:35"},{"body":{"id":41160,"nodeType":"Block","src":"3708:141:35","statements":[{"condition":{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":41152,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"expression":{"baseExpression":{"id":41147,"name":"actualFacets","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41125,"src":"3726:12:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_Facet_$49417_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondLoupe.Facet memory[] memory"}},"id":41149,"indexExpression":{"id":41148,"name":"j","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41137,"src":"3739:1:35","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"3726:15:35","typeDescriptions":{"typeIdentifier":"t_struct$_Facet_$49417_memory_ptr","typeString":"struct IDiamondLoupe.Facet memory"}},"id":41150,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"3742:12:35","memberName":"facetAddress","nodeType":"MemberAccess","referencedDeclaration":49413,"src":"3726:28:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":41151,"name":"viewerFacet","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41114,"src":"3758:11:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"3726:43:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":41159,"nodeType":"IfStatement","src":"3722:117:35","trueBody":{"id":41158,"nodeType":"Block","src":"3771:68:35","statements":[{"expression":{"id":41155,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":41153,"name":"found","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41133,"src":"3789:5:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"hexValue":"74727565","id":41154,"isConstant":false,"isLValue":false,"isPure":true,"kind":"bool","lValueRequested":false,"nodeType":"Literal","src":"3797:4:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"value":"true"},"src":"3789:12:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":41156,"nodeType":"ExpressionStatement","src":"3789:12:35"},{"id":41157,"nodeType":"Break","src":"3819:5:35"}]}}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":41143,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":41140,"name":"j","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41137,"src":"3678:1:35","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"expression":{"id":41141,"name":"actualFacets","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41125,"src":"3682:12:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_Facet_$49417_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondLoupe.Facet memory[] memory"}},"id":41142,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"3695:6:35","memberName":"length","nodeType":"MemberAccess","src":"3682:19:35","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"3678:23:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":41161,"initializationExpression":{"assignments":[41137],"declarations":[{"constant":false,"id":41137,"mutability":"mutable","name":"j","nameLocation":"3671:1:35","nodeType":"VariableDeclaration","scope":41161,"src":"3663:9:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":41136,"name":"uint256","nodeType":"ElementaryTypeName","src":"3663:7:35","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":41139,"initialValue":{"hexValue":"30","id":41138,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"3675:1:35","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"3663:13:35"},"isSimpleCounterLoop":true,"loopExpression":{"expression":{"id":41145,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"3703:3:35","subExpression":{"id":41144,"name":"j","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41137,"src":"3703:1:35","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":41146,"nodeType":"ExpressionStatement","src":"3703:3:35"},"nodeType":"ForStatement","src":"3658:191:35"},{"expression":{"arguments":[{"id":41163,"name":"found","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41133,"src":"3866:5:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"5570646174654469616d6f6e6456696577734d756c74697369673a20766965776572206661636574206e6f74206d6174636865642c2070726f6261626c7920796f75206861766520756e77616e746564206c6f63616c206368616e676573","id":41164,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"3873:96:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_3d47a32b025f819d5d0cbf65efeced2a08e006ad1ee31417bcd64742d2d79589","typeString":"literal_string \"UpdateDiamondViewsMultisig: viewer facet not matched, probably you have unwanted local changes\""},"value":"UpdateDiamondViewsMultisig: viewer facet not matched, probably you have unwanted local changes"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_3d47a32b025f819d5d0cbf65efeced2a08e006ad1ee31417bcd64742d2d79589","typeString":"literal_string \"UpdateDiamondViewsMultisig: viewer facet not matched, probably you have unwanted local changes\""}],"id":41162,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18,-18],"referencedDeclaration":-18,"src":"3858:7:35","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":41165,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3858:112:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41166,"nodeType":"ExpressionStatement","src":"3858:112:35"},{"assignments":[41172],"declarations":[{"constant":false,"id":41172,"mutability":"mutable","name":"diamondCut","nameLocation":"4190:10:35","nodeType":"VariableDeclaration","scope":41250,"src":"4160:40:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondCut.FacetCut[]"},"typeName":{"baseType":{"id":41170,"nodeType":"UserDefinedTypeName","pathNode":{"id":41169,"name":"IDiamondCut.FacetCut","nameLocations":["4160:11:35","4172:8:35"],"nodeType":"IdentifierPath","referencedDeclaration":49385,"src":"4160:20:35"},"referencedDeclaration":49385,"src":"4160:20:35","typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_storage_ptr","typeString":"struct IDiamondCut.FacetCut"}},"id":41171,"nodeType":"ArrayTypeName","src":"4160:22:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_storage_$dyn_storage_ptr","typeString":"struct IDiamondCut.FacetCut[]"}},"visibility":"internal"}],"id":41179,"initialValue":{"arguments":[{"hexValue":"32","id":41177,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4230:1:35","typeDescriptions":{"typeIdentifier":"t_rational_2_by_1","typeString":"int_const 2"},"value":"2"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_2_by_1","typeString":"int_const 2"}],"id":41176,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"4203:26:35","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_struct$_FacetCut_$49385_memory_ptr_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (struct IDiamondCut.FacetCut memory[] memory)"},"typeName":{"baseType":{"id":41174,"nodeType":"UserDefinedTypeName","pathNode":{"id":41173,"name":"IDiamondCut.FacetCut","nameLocations":["4207:11:35","4219:8:35"],"nodeType":"IdentifierPath","referencedDeclaration":49385,"src":"4207:20:35"},"referencedDeclaration":49385,"src":"4207:20:35","typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_storage_ptr","typeString":"struct IDiamondCut.FacetCut"}},"id":41175,"nodeType":"ArrayTypeName","src":"4207:22:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_storage_$dyn_storage_ptr","typeString":"struct IDiamondCut.FacetCut[]"}}},"id":41178,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4203:29:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory[] memory"}},"nodeType":"VariableDeclarationStatement","src":"4160:72:35"},{"assignments":[41184],"declarations":[{"constant":false,"id":41184,"mutability":"mutable","name":"facetFunctionSelectors","nameLocation":"4258:22:35","nodeType":"VariableDeclaration","scope":41250,"src":"4242:38:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes4_$dyn_memory_ptr","typeString":"bytes4[]"},"typeName":{"baseType":{"id":41182,"name":"bytes4","nodeType":"ElementaryTypeName","src":"4242:6:35","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"id":41183,"nodeType":"ArrayTypeName","src":"4242:8:35","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes4_$dyn_storage_ptr","typeString":"bytes4[]"}},"visibility":"internal"}],"id":41191,"initialValue":{"arguments":[{"id":41189,"name":"viewerFacet","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41114,"src":"4329:11:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"arguments":[{"id":41186,"name":"diamond","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41107,"src":"4297:7:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":41185,"name":"IDiamondLoupe","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49450,"src":"4283:13:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IDiamondLoupe_$49450_$","typeString":"type(contract IDiamondLoupe)"}},"id":41187,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4283:22:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IDiamondLoupe_$49450","typeString":"contract IDiamondLoupe"}},"id":41188,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4306:22:35","memberName":"facetFunctionSelectors","nodeType":"MemberAccess","referencedDeclaration":49434,"src":"4283:45:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_address_$returns$_t_array$_t_bytes4_$dyn_memory_ptr_$","typeString":"function (address) view external returns (bytes4[] memory)"}},"id":41190,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4283:58:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_bytes4_$dyn_memory_ptr","typeString":"bytes4[] memory"}},"nodeType":"VariableDeclarationStatement","src":"4242:99:35"},{"expression":{"id":41206,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":41192,"name":"diamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41172,"src":"4351:10:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory[] memory"}},"id":41194,"indexExpression":{"hexValue":"30","id":41193,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4362:1:35","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"4351:13:35","typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"arguments":[{"hexValue":"30","id":41199,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4424:1:35","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":41198,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4416:7:35","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":41197,"name":"address","nodeType":"ElementaryTypeName","src":"4416:7:35","typeDescriptions":{}}},"id":41200,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4416:10:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"expression":{"expression":{"id":41201,"name":"IDiamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49408,"src":"4448:11:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IDiamondCut_$49408_$","typeString":"type(contract IDiamondCut)"}},"id":41202,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4460:14:35","memberName":"FacetCutAction","nodeType":"MemberAccess","referencedDeclaration":49376,"src":"4448:26:35","typeDescriptions":{"typeIdentifier":"t_type$_t_enum$_FacetCutAction_$49376_$","typeString":"type(enum IDiamondCut.FacetCutAction)"}},"id":41203,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"4475:6:35","memberName":"Remove","nodeType":"MemberAccess","referencedDeclaration":49375,"src":"4448:33:35","typeDescriptions":{"typeIdentifier":"t_enum$_FacetCutAction_$49376","typeString":"enum IDiamondCut.FacetCutAction"}},{"id":41204,"name":"facetFunctionSelectors","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41184,"src":"4514:22:35","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes4_$dyn_memory_ptr","typeString":"bytes4[] memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_enum$_FacetCutAction_$49376","typeString":"enum IDiamondCut.FacetCutAction"},{"typeIdentifier":"t_array$_t_bytes4_$dyn_memory_ptr","typeString":"bytes4[] memory"}],"expression":{"id":41195,"name":"IDiamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49408,"src":"4367:11:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IDiamondCut_$49408_$","typeString":"type(contract IDiamondCut)"}},"id":41196,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4379:8:35","memberName":"FacetCut","nodeType":"MemberAccess","referencedDeclaration":49385,"src":"4367:20:35","typeDescriptions":{"typeIdentifier":"t_type$_t_struct$_FacetCut_$49385_storage_ptr_$","typeString":"type(struct IDiamondCut.FacetCut storage pointer)"}},"id":41205,"isConstant":false,"isLValue":false,"isPure":false,"kind":"structConstructorCall","lValueRequested":false,"nameLocations":["4402:12:35","4440:6:35","4495:17:35"],"names":["facetAddress","action","functionSelectors"],"nodeType":"FunctionCall","src":"4367:180:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory"}},"src":"4351:196:35","typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory"}},"id":41207,"nodeType":"ExpressionStatement","src":"4351:196:35"},{"assignments":[41209],"declarations":[{"constant":false,"id":41209,"mutability":"mutable","name":"newViewerFacet","nameLocation":"4595:14:35","nodeType":"VariableDeclaration","scope":41250,"src":"4587:22:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":41208,"name":"address","nodeType":"ElementaryTypeName","src":"4587:7:35","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":41218,"initialValue":{"arguments":[{"hexValue":"5669657765724661636574","id":41211,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"4628:13:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_17163bc14ca589f519e924ce03713060635e27e6e081498498ca9bab560316b9","typeString":"literal_string \"ViewerFacet\""},"value":"ViewerFacet"},{"hexValue":"5669657765724661636574","id":41212,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"4643:13:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_17163bc14ca589f519e924ce03713060635e27e6e081498498ca9bab560316b9","typeString":"literal_string \"ViewerFacet\""},"value":"ViewerFacet"},{"arguments":[{"hexValue":"30","id":41215,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4668:1:35","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":41214,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"4658:9:35","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_bytes_memory_ptr_$","typeString":"function (uint256) pure returns (bytes memory)"},"typeName":{"id":41213,"name":"bytes","nodeType":"ElementaryTypeName","src":"4662:5:35","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}}},"id":41216,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4658:12:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_17163bc14ca589f519e924ce03713060635e27e6e081498498ca9bab560316b9","typeString":"literal_string \"ViewerFacet\""},{"typeIdentifier":"t_stringliteral_17163bc14ca589f519e924ce03713060635e27e6e081498498ca9bab560316b9","typeString":"literal_string \"ViewerFacet\""},{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"id":41210,"name":"_deployContract","nodeType":"Identifier","overloadedDeclarations":[41751,41776],"referencedDeclaration":41751,"src":"4612:15:35","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_string_memory_ptr_$_t_string_memory_ptr_$_t_bytes_memory_ptr_$returns$_t_address_$","typeString":"function (string memory,string memory,bytes memory) returns (address)"}},"id":41217,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4612:59:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"4587:84:35"},{"expression":{"id":41231,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":41219,"name":"diamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41172,"src":"4682:10:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory[] memory"}},"id":41221,"indexExpression":{"hexValue":"31","id":41220,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4693:1:35","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"4682:13:35","typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":41224,"name":"newViewerFacet","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41209,"src":"4747:14:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"expression":{"expression":{"id":41225,"name":"IDiamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49408,"src":"4783:11:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IDiamondCut_$49408_$","typeString":"type(contract IDiamondCut)"}},"id":41226,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4795:14:35","memberName":"FacetCutAction","nodeType":"MemberAccess","referencedDeclaration":49376,"src":"4783:26:35","typeDescriptions":{"typeIdentifier":"t_type$_t_enum$_FacetCutAction_$49376_$","typeString":"type(enum IDiamondCut.FacetCutAction)"}},"id":41227,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"4810:3:35","memberName":"Add","nodeType":"MemberAccess","referencedDeclaration":49373,"src":"4783:30:35","typeDescriptions":{"typeIdentifier":"t_enum$_FacetCutAction_$49376","typeString":"enum IDiamondCut.FacetCutAction"}},{"arguments":[],"expression":{"argumentTypes":[],"id":41228,"name":"getViewerSelectors","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":44185,"src":"4846:18:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$__$returns$_t_array$_t_bytes4_$dyn_memory_ptr_$","typeString":"function () pure returns (bytes4[] memory)"}},"id":41229,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4846:20:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_bytes4_$dyn_memory_ptr","typeString":"bytes4[] memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_enum$_FacetCutAction_$49376","typeString":"enum IDiamondCut.FacetCutAction"},{"typeIdentifier":"t_array$_t_bytes4_$dyn_memory_ptr","typeString":"bytes4[] memory"}],"expression":{"id":41222,"name":"IDiamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49408,"src":"4698:11:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IDiamondCut_$49408_$","typeString":"type(contract IDiamondCut)"}},"id":41223,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4710:8:35","memberName":"FacetCut","nodeType":"MemberAccess","referencedDeclaration":49385,"src":"4698:20:35","typeDescriptions":{"typeIdentifier":"t_type$_t_struct$_FacetCut_$49385_storage_ptr_$","typeString":"type(struct IDiamondCut.FacetCut storage pointer)"}},"id":41230,"isConstant":false,"isLValue":false,"isPure":false,"kind":"structConstructorCall","lValueRequested":false,"nameLocations":["4733:12:35","4775:6:35","4827:17:35"],"names":["facetAddress","action","functionSelectors"],"nodeType":"FunctionCall","src":"4698:179:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory"}},"src":"4682:195:35","typeDescriptions":{"typeIdentifier":"t_struct$_FacetCut_$49385_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory"}},"id":41232,"nodeType":"ExpressionStatement","src":"4682:195:35"},{"assignments":[41234],"declarations":[{"constant":false,"id":41234,"mutability":"mutable","name":"_calldata","nameLocation":"4900:9:35","nodeType":"VariableDeclaration","scope":41250,"src":"4887:22:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":41233,"name":"bytes","nodeType":"ElementaryTypeName","src":"4887:5:35","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"id":41247,"initialValue":{"arguments":[{"expression":{"expression":{"id":41237,"name":"IDiamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":49408,"src":"4935:11:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IDiamondCut_$49408_$","typeString":"type(contract IDiamondCut)"}},"id":41238,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"4947:10:35","memberName":"diamondCut","nodeType":"MemberAccess","referencedDeclaration":49397,"src":"4935:22:35","typeDescriptions":{"typeIdentifier":"t_function_declaration_nonpayable$_t_array$_t_struct$_FacetCut_$49385_calldata_ptr_$dyn_calldata_ptr_$_t_address_$_t_bytes_calldata_ptr_$returns$__$","typeString":"function IDiamondCut.diamondCut(struct IDiamondCut.FacetCut calldata[] calldata,address,bytes calldata)"}},"id":41239,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"4958:8:35","memberName":"selector","nodeType":"MemberAccess","src":"4935:31:35","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},{"id":41240,"name":"diamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41172,"src":"4968:10:35","typeDescriptions":{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory[] memory"}},{"arguments":[{"hexValue":"30","id":41243,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4988:1:35","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":41242,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4980:7:35","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":41241,"name":"address","nodeType":"ElementaryTypeName","src":"4980:7:35","typeDescriptions":{}}},"id":41244,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4980:10:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"hexValue":"","id":41245,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"4992:2:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470","typeString":"literal_string \"\""},"value":""}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes4","typeString":"bytes4"},{"typeIdentifier":"t_array$_t_struct$_FacetCut_$49385_memory_ptr_$dyn_memory_ptr","typeString":"struct IDiamondCut.FacetCut memory[] memory"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_stringliteral_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470","typeString":"literal_string \"\""}],"expression":{"id":41235,"name":"abi","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-1,"src":"4912:3:35","typeDescriptions":{"typeIdentifier":"t_magic_abi","typeString":"abi"}},"id":41236,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"4916:18:35","memberName":"encodeWithSelector","nodeType":"MemberAccess","src":"4912:22:35","typeDescriptions":{"typeIdentifier":"t_function_abiencodewithselector_pure$_t_bytes4_$returns$_t_bytes_memory_ptr_$","typeString":"function (bytes4) pure returns (bytes memory)"}},"id":41246,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4912:83:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"nodeType":"VariableDeclarationStatement","src":"4887:108:35"},{"expression":{"id":41248,"name":"_calldata","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41234,"src":"5013:9:35","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"functionReturnParameters":41105,"id":41249,"nodeType":"Return","src":"5006:16:35"}]},"implemented":true,"kind":"function","modifiers":[],"name":"makeDiamondCut","nameLocation":"3044:14:35","parameters":{"id":41102,"nodeType":"ParameterList","parameters":[],"src":"3058:2:35"},"returnParameters":{"id":41105,"nodeType":"ParameterList","parameters":[{"constant":false,"id":41104,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":41251,"src":"3078:12:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":41103,"name":"bytes","nodeType":"ElementaryTypeName","src":"3078:5:35","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"3077:14:35"},"scope":41390,"stateMutability":"nonpayable","virtual":false,"visibility":"private"},{"id":41265,"nodeType":"FunctionDefinition","src":"5035:141:35","nodes":[],"body":{"id":41264,"nodeType":"Block","src":"5076:100:35","nodes":[],"statements":[{"expression":{"arguments":[{"id":41255,"name":"fullDeploymentsPath","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40992,"src":"5102:19:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}],"id":41254,"name":"_loadDeployment","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41585,"src":"5086:15:35","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory)"}},"id":41256,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5086:36:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41257,"nodeType":"ExpressionStatement","src":"5086:36:35"},{"expression":{"arguments":[{"hexValue":"0a5374617274206465706c6f79696e672e2e2e","id":41261,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"5146:22:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_464e97289870c3f172c3cb98638889e28752dcbe2f3897d65e42d00f18599266","typeString":"literal_string hex\"0a5374617274206465706c6f79696e672e2e2e\""},"value":"\nStart deploying..."}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_464e97289870c3f172c3cb98638889e28752dcbe2f3897d65e42d00f18599266","typeString":"literal_string hex\"0a5374617274206465706c6f79696e672e2e2e\""}],"expression":{"id":41258,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"5133:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41260,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5142:3:35","memberName":"log","nodeType":"MemberAccess","referencedDeclaration":13136,"src":"5133:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory) pure"}},"id":41262,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5133:36:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41263,"nodeType":"ExpressionStatement","src":"5133:36:35"}]},"implemented":true,"kind":"function","modifiers":[],"name":"_startDeploy","nameLocation":"5044:12:35","parameters":{"id":41252,"nodeType":"ParameterList","parameters":[],"src":"5056:2:35"},"returnParameters":{"id":41253,"nodeType":"ParameterList","parameters":[],"src":"5076:0:35"},"scope":41390,"stateMutability":"nonpayable","virtual":true,"visibility":"internal"},{"id":41282,"nodeType":"FunctionDefinition","src":"5182:166:35","nodes":[],"body":{"id":41281,"nodeType":"Block","src":"5222:126:35","nodes":[],"statements":[{"expression":{"arguments":[],"expression":{"argumentTypes":[],"id":41268,"name":"_printDeployments","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":42131,"src":"5232:17:35","typeDescriptions":{"typeIdentifier":"t_function_internal_view$__$returns$__$","typeString":"function () view"}},"id":41269,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5232:19:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41270,"nodeType":"ExpressionStatement","src":"5232:19:35"},{"expression":{"arguments":[{"id":41272,"name":"fullDeploymentsPath","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40992,"src":"5277:19:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}],"id":41271,"name":"_saveDeployment","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41729,"src":"5261:15:35","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory)"}},"id":41273,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5261:36:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41274,"nodeType":"ExpressionStatement","src":"5261:36:35"},{"expression":{"arguments":[{"hexValue":"0a4465706c6f792066696e6973686564","id":41278,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"5321:19:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_ed7bcc69b27c447ad6ab9c564b3f5aff1ebc26228d823e21cb32bad8502c3b01","typeString":"literal_string hex\"0a4465706c6f792066696e6973686564\""},"value":"\nDeploy finished"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_ed7bcc69b27c447ad6ab9c564b3f5aff1ebc26228d823e21cb32bad8502c3b01","typeString":"literal_string hex\"0a4465706c6f792066696e6973686564\""}],"expression":{"id":41275,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"5308:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41277,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5317:3:35","memberName":"log","nodeType":"MemberAccess","referencedDeclaration":13136,"src":"5308:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory) pure"}},"id":41279,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5308:33:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41280,"nodeType":"ExpressionStatement","src":"5308:33:35"}]},"implemented":true,"kind":"function","modifiers":[],"name":"_stopDeploy","nameLocation":"5191:11:35","parameters":{"id":41266,"nodeType":"ParameterList","parameters":[],"src":"5202:2:35"},"returnParameters":{"id":41267,"nodeType":"ParameterList","parameters":[],"src":"5222:0:35"},"scope":41390,"stateMutability":"nonpayable","virtual":true,"visibility":"internal"},{"id":41389,"nodeType":"FunctionDefinition","src":"5355:1104:35","nodes":[],"body":{"id":41388,"nodeType":"Block","src":"5379:1080:35","nodes":[],"statements":[{"expression":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"id":41285,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"5389:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41287,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5392:14:35","memberName":"startBroadcast","nodeType":"MemberAccess","referencedDeclaration":10017,"src":"5389:17:35","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$__$returns$__$","typeString":"function () external"}},"id":41288,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5389:19:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41289,"nodeType":"ExpressionStatement","src":"5389:19:35"},{"expression":{"arguments":[],"expression":{"argumentTypes":[],"id":41290,"name":"_startDeploy","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41265,"src":"5418:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$__$returns$__$","typeString":"function ()"}},"id":41291,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5418:14:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41292,"nodeType":"ExpressionStatement","src":"5418:14:35"},{"assignments":[41294],"declarations":[{"constant":false,"id":41294,"mutability":"mutable","name":"diamond","nameLocation":"5451:7:35","nodeType":"VariableDeclaration","scope":41388,"src":"5443:15:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":41293,"name":"address","nodeType":"ElementaryTypeName","src":"5443:7:35","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":41299,"initialValue":{"arguments":[{"id":41296,"name":"envName","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40994,"src":"5477:7:35","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string storage ref"}},{"hexValue":"4469616d6f6e64","id":41297,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"5486:9:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_aadb29765cb3e4f21bde5ecd65db8e565d901b6c9394dcec22aa81b8ff2d6e2f","typeString":"literal_string \"Diamond\""},"value":"Diamond"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_string_storage","typeString":"string storage ref"},{"typeIdentifier":"t_stringliteral_aadb29765cb3e4f21bde5ecd65db8e565d901b6c9394dcec22aa81b8ff2d6e2f","typeString":"literal_string \"Diamond\""}],"id":41295,"name":"contractAddress","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41101,"src":"5461:15:35","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_string_memory_ptr_$_t_string_memory_ptr_$returns$_t_address_$","typeString":"function (string memory,string memory) view returns (address)"}},"id":41298,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5461:35:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"5443:53:35"},{"assignments":[41301],"declarations":[{"constant":false,"id":41301,"mutability":"mutable","name":"_tx","nameLocation":"5520:3:35","nodeType":"VariableDeclaration","scope":41388,"src":"5507:16:35","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":41300,"name":"bytes","nodeType":"ElementaryTypeName","src":"5507:5:35","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"id":41304,"initialValue":{"arguments":[],"expression":{"argumentTypes":[],"id":41302,"name":"makeDiamondCut","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41251,"src":"5526:14:35","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$__$returns$_t_bytes_memory_ptr_$","typeString":"function () returns (bytes memory)"}},"id":41303,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5526:16:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"nodeType":"VariableDeclarationStatement","src":"5507:35:35"},{"expression":{"arguments":[],"expression":{"argumentTypes":[],"id":41305,"name":"_stopDeploy","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41282,"src":"5553:11:35","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$__$returns$__$","typeString":"function ()"}},"id":41306,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5553:13:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41307,"nodeType":"ExpressionStatement","src":"5553:13:35"},{"expression":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"id":41308,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"5576:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41310,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5579:13:35","memberName":"stopBroadcast","nodeType":"MemberAccess","referencedDeclaration":10033,"src":"5576:16:35","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$__$returns$__$","typeString":"function () external"}},"id":41311,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5576:18:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41312,"nodeType":"ExpressionStatement","src":"5576:18:35"},{"expression":{"arguments":[{"hexValue":"0a0a0a557067726164652062797465636f64653a0a","id":41316,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"5708:27:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_073da16861544d8d9293996463cdcb0c22ed4ad4386f19f99f1a63ef94727cf9","typeString":"literal_string hex\"0a0a0a557067726164652062797465636f64653a0a\""},"value":"\n\n\nUpgrade bytecode:\n"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_073da16861544d8d9293996463cdcb0c22ed4ad4386f19f99f1a63ef94727cf9","typeString":"literal_string hex\"0a0a0a557067726164652062797465636f64653a0a\""}],"expression":{"id":41313,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"5695:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41315,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5704:3:35","memberName":"log","nodeType":"MemberAccess","referencedDeclaration":13136,"src":"5695:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory) pure"}},"id":41317,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5695:41:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41318,"nodeType":"ExpressionStatement","src":"5695:41:35"},{"expression":{"arguments":[{"id":41322,"name":"_tx","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41301,"src":"5764:3:35","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"expression":{"id":41319,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"5746:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41321,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5755:8:35","memberName":"logBytes","nodeType":"MemberAccess","referencedDeclaration":12646,"src":"5746:17:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes_memory_ptr_$returns$__$","typeString":"function (bytes memory) pure"}},"id":41323,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5746:22:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41324,"nodeType":"ExpressionStatement","src":"5746:22:35"},{"expression":{"arguments":[{"hexValue":"0a0a0a3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d0a","id":41328,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"5814:27:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_e78db13bbd09f1adc2dd33f43881a058fab891f8ff835cc1a5062f77288f7356","typeString":"literal_string hex\"0a0a0a3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d0a\""},"value":"\n\n\n=================\n"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_e78db13bbd09f1adc2dd33f43881a058fab891f8ff835cc1a5062f77288f7356","typeString":"literal_string hex\"0a0a0a3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d0a\""}],"expression":{"id":41325,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"5801:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41327,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5810:3:35","memberName":"log","nodeType":"MemberAccess","referencedDeclaration":13136,"src":"5801:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory) pure"}},"id":41329,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5801:41:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41330,"nodeType":"ExpressionStatement","src":"5801:41:35"},{"assignments":[41332],"declarations":[{"constant":false,"id":41332,"mutability":"mutable","name":"difficultyBefore","nameLocation":"5935:16:35","nodeType":"VariableDeclaration","scope":41388,"src":"5927:24:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":41331,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5927:7:35","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":41338,"initialValue":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"arguments":[{"id":41334,"name":"diamond","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41294,"src":"5969:7:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":41333,"name":"ICapacityConst","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47081,"src":"5954:14:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_ICapacityConst_$47081_$","typeString":"type(contract ICapacityConst)"}},"id":41335,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5954:23:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_ICapacityConst_$47081","typeString":"contract ICapacityConst"}},"id":41336,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5978:10:35","memberName":"difficulty","nodeType":"MemberAccess","referencedDeclaration":47025,"src":"5954:34:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$__$returns$_t_bytes32_$","typeString":"function () view external returns (bytes32)"}},"id":41337,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5954:36:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"5927:63:35"},{"expression":{"arguments":[{"id":41342,"name":"REAL_MULTISIG_ON_ALL_ENVS","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":40997,"src":"6015:25:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":41339,"name":"vm","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":58,"src":"6001:2:35","typeDescriptions":{"typeIdentifier":"t_contract$_Vm_$12498","typeString":"contract Vm"}},"id":41341,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6004:10:35","memberName":"startPrank","nodeType":"MemberAccess","referencedDeclaration":12239,"src":"6001:13:35","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$returns$__$","typeString":"function (address) external"}},"id":41343,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6001:40:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41344,"nodeType":"ExpressionStatement","src":"6001:40:35"},{"assignments":[41346,null],"declarations":[{"constant":false,"id":41346,"mutability":"mutable","name":"success","nameLocation":"6057:7:35","nodeType":"VariableDeclaration","scope":41388,"src":"6052:12:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":41345,"name":"bool","nodeType":"ElementaryTypeName","src":"6052:4:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},null],"id":41351,"initialValue":{"arguments":[{"id":41349,"name":"_tx","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41301,"src":"6083:3:35","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"expression":{"id":41347,"name":"diamond","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41294,"src":"6070:7:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":41348,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6078:4:35","memberName":"call","nodeType":"MemberAccess","src":"6070:12:35","typeDescriptions":{"typeIdentifier":"t_function_barecall_payable$_t_bytes_memory_ptr_$returns$_t_bool_$_t_bytes_memory_ptr_$","typeString":"function (bytes memory) payable returns (bool,bytes memory)"}},"id":41350,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6070:17:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$_t_bool_$_t_bytes_memory_ptr_$","typeString":"tuple(bool,bytes memory)"}},"nodeType":"VariableDeclarationStatement","src":"6051:36:35"},{"expression":{"arguments":[{"id":41353,"name":"success","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41346,"src":"6105:7:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"5570646174654469616d6f6e644d756c74697369673a206661696c656420746f20757064617465206469616d6f6e64","id":41354,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"6114:49:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_7e212865f41947dc1a1241d5d92e9eb90af53c70ed5f5c620f45dca374ce7e82","typeString":"literal_string \"UpdateDiamondMultisig: failed to update diamond\""},"value":"UpdateDiamondMultisig: failed to update diamond"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_7e212865f41947dc1a1241d5d92e9eb90af53c70ed5f5c620f45dca374ce7e82","typeString":"literal_string \"UpdateDiamondMultisig: failed to update diamond\""}],"id":41352,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18,-18],"referencedDeclaration":-18,"src":"6097:7:35","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":41355,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6097:67:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41356,"nodeType":"ExpressionStatement","src":"6097:67:35"},{"assignments":[41358],"declarations":[{"constant":false,"id":41358,"mutability":"mutable","name":"difficultyAfter","nameLocation":"6183:15:35","nodeType":"VariableDeclaration","scope":41388,"src":"6175:23:35","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":41357,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6175:7:35","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":41364,"initialValue":{"arguments":[],"expression":{"argumentTypes":[],"expression":{"arguments":[{"id":41360,"name":"diamond","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41294,"src":"6216:7:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":41359,"name":"ICapacityConst","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47081,"src":"6201:14:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_ICapacityConst_$47081_$","typeString":"type(contract ICapacityConst)"}},"id":41361,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6201:23:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_ICapacityConst_$47081","typeString":"contract ICapacityConst"}},"id":41362,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6225:10:35","memberName":"difficulty","nodeType":"MemberAccess","referencedDeclaration":47025,"src":"6201:34:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$__$returns$_t_bytes32_$","typeString":"function () view external returns (bytes32)"}},"id":41363,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6201:36:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"6175:62:35"},{"expression":{"arguments":[{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":41368,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":41366,"name":"difficultyBefore","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41332,"src":"6255:16:35","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":41367,"name":"difficultyAfter","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41358,"src":"6275:15:35","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"6255:35:35","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"5570646174654469616d6f6e644d756c74697369673a20646966666963756c7479206368616e676564","id":41369,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"6292:43:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_1f687f2a96e72aa01730c6c829d4abe9b74761b19a12f365bc182e406943e1dc","typeString":"literal_string \"UpdateDiamondMultisig: difficulty changed\""},"value":"UpdateDiamondMultisig: difficulty changed"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_1f687f2a96e72aa01730c6c829d4abe9b74761b19a12f365bc182e406943e1dc","typeString":"literal_string \"UpdateDiamondMultisig: difficulty changed\""}],"id":41365,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18,-18],"referencedDeclaration":-18,"src":"6247:7:35","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":41370,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6247:89:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41371,"nodeType":"ExpressionStatement","src":"6247:89:35"},{"expression":{"arguments":[{"hexValue":"446966666963756c7479206e6f74206368616e6765643a","id":41375,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"6359:25:35","typeDescriptions":{"typeIdentifier":"t_stringliteral_2b72ec548ebe24a554bb32d6af067b28a1395079d6ff44441af4a5326887b396","typeString":"literal_string \"Difficulty not changed:\""},"value":"Difficulty not changed:"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_stringliteral_2b72ec548ebe24a554bb32d6af067b28a1395079d6ff44441af4a5326887b396","typeString":"literal_string \"Difficulty not changed:\""}],"expression":{"id":41372,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"6346:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41374,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6355:3:35","memberName":"log","nodeType":"MemberAccess","referencedDeclaration":13136,"src":"6346:12:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_string_memory_ptr_$returns$__$","typeString":"function (string memory) pure"}},"id":41376,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6346:39:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41377,"nodeType":"ExpressionStatement","src":"6346:39:35"},{"expression":{"arguments":[{"arguments":[],"expression":{"argumentTypes":[],"expression":{"arguments":[{"id":41382,"name":"diamond","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":41294,"src":"6430:7:35","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":41381,"name":"ICapacityConst","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47081,"src":"6415:14:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_ICapacityConst_$47081_$","typeString":"type(contract ICapacityConst)"}},"id":41383,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6415:23:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_ICapacityConst_$47081","typeString":"contract ICapacityConst"}},"id":41384,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6439:10:35","memberName":"difficulty","nodeType":"MemberAccess","referencedDeclaration":47025,"src":"6415:34:35","typeDescriptions":{"typeIdentifier":"t_function_external_view$__$returns$_t_bytes32_$","typeString":"function () view external returns (bytes32)"}},"id":41385,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6415:36:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"id":41378,"name":"console2","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":20622,"src":"6395:8:35","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_console_$20622_$","typeString":"type(library console)"}},"id":41380,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6404:10:35","memberName":"logBytes32","nodeType":"MemberAccess","referencedDeclaration":13094,"src":"6395:19:35","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$returns$__$","typeString":"function (bytes32) pure"}},"id":41386,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6395:57:35","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":41387,"nodeType":"ExpressionStatement","src":"6395:57:35"}]},"functionSelector":"c0406226","implemented":true,"kind":"function","modifiers":[],"name":"run","nameLocation":"5364:3:35","parameters":{"id":41283,"nodeType":"ParameterList","parameters":[],"src":"5367:2:35"},"returnParameters":{"id":41284,"nodeType":"ParameterList","parameters":[],"src":"5379:0:35"},"scope":41390,"stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"abstract":false,"baseContracts":[{"baseName":{"id":40982,"name":"Script","nameLocations":["2030:6:35"],"nodeType":"IdentifierPath","referencedDeclaration":113,"src":"2030:6:35"},"id":40983,"nodeType":"InheritanceSpecifier","src":"2030:6:35"},{"baseName":{"id":40984,"name":"Deployment","nameLocations":["2038:10:35"],"nodeType":"IdentifierPath","referencedDeclaration":42187,"src":"2038:10:35"},"id":40985,"nodeType":"InheritanceSpecifier","src":"2038:10:35"},{"baseName":{"id":40986,"name":"SelectorsHelper","nameLocations":["2050:15:35"],"nodeType":"IdentifierPath","referencedDeclaration":44186,"src":"2050:15:35"},"id":40987,"nodeType":"InheritanceSpecifier","src":"2050:15:35"}],"canonicalName":"UpdateDiamondViewsMultisig","contractDependencies":[],"contractKind":"contract","fullyImplemented":true,"internalFunctionIDs":{"12551":1},"linearizedBaseContracts":[41390,44186,42187,113,8519,3000,940,74,62],"name":"UpdateDiamondViewsMultisig","nameLocation":"2000:26:35","scope":41391,"usedErrors":[],"usedEvents":[]}]}},"script/utils/Deployment.sol":{"id":36,"ast":{}},"script/utils/SelectorsHelper.sol":{"id":37,"ast":{}},"src/balance-keeper/IBalanceKeeper.sol":{"id":38,"ast":{}},"src/core/DealStakerRewards.sol":{"id":39,"ast":{}},"src/core/Snapshot.sol":{"id":40,"ast":{}},"src/core/Vesting.sol":{"id":41,"ast":{}},"src/core/interfaces/IBaseOffer.sol":{"id":42,"ast":{}},"src/core/interfaces/ICapacity.sol":{"id":43,"ast":{}},"src/core/interfaces/ICapacityConst.sol":{"id":44,"ast":{}},"src/core/interfaces/ICore.sol":{"id":45,"ast":{}},"src/core/interfaces/IDealFactory.sol":{"id":46,"ast":{}},"src/core/interfaces/IEpochController.sol":{"id":47,"ast":{}},"src/core/interfaces/IGlobalConst.sol":{"id":48,"ast":{}},"src/core/interfaces/IMarket.sol":{"id":49,"ast":{}},"src/core/interfaces/IMarketV2.sol":{"id":50,"ast":{}},"src/core/interfaces/IOffer.sol":{"id":51,"ast":{}},"src/core/interfaces/IOfferV2.sol":{"id":52,"ast":{}},"src/deal/interfaces/IConfig.sol":{"id":53,"ast":{}},"src/deal/interfaces/IDeal.sol":{"id":54,"ast":{}},"src/deal/interfaces/IWorkerManager.sol":{"id":55,"ast":{}},"src/deal/v1/interfaces/IConfig.sol":{"id":56,"ast":{}},"src/deal/v1/interfaces/IDeal.sol":{"id":57,"ast":{}},"src/deal/v1/interfaces/IWorkerManager.sol":{"id":58,"ast":{}},"src/interfaces/IDiamond.sol":{"id":59,"ast":{}},"src/interfaces/IDiamondCut.sol":{"id":60,"ast":{}},"src/interfaces/IDiamondLoupe.sol":{"id":61,"ast":{}},"src/interfaces/IERC165.sol":{"id":62,"ast":{}},"src/interfaces/IERC173.sol":{"id":63,"ast":{}},"src/interfaces/IMulticall.sol":{"id":64,"ast":{}},"src/interfaces/IViewer.sol":{"id":65,"ast":{}},"src/interfaces/IWhitelist.sol":{"id":66,"ast":{}},"src/lib/LibBaseOffer.sol":{"id":67,"ast":{}},"src/lib/LibCapacity.sol":{"id":68,"ast":{}},"src/lib/LibCapacityConst.sol":{"id":69,"ast":{}},"src/lib/LibDiamond.sol":{"id":70,"ast":{}},"src/lib/LibEpochController.sol":{"id":71,"ast":{}},"src/lib/LibGlobalConst.sol":{"id":72,"ast":{}},"src/lib/LibOffer.sol":{"id":73,"ast":{}},"src/lib/LibOfferV2.sol":{"id":74,"ast":{}},"src/lib/LibOraclePrice.sol":{"id":75,"ast":{}},"src/lib/LibSendValue.sol":{"id":76,"ast":{}},"src/utils/Common.sol":{"id":77,"ast":{}},"src/utils/OwnableUpgradableDiamond.sol":{"id":78,"ast":{}}}},"solcLongVersion":"0.8.26","solcVersion":"0.8.26"}